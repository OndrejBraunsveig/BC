(function () {
  'use strict';

  const head = document.querySelector('head');
  if (head) {
    [16, 32, 96, 160, 196].forEach(resolution => {
      const link = document.createElement('link');
      link.setAttribute('rel', 'icon');
      link.setAttribute('href', `https://kitware.github.io/vtk-js/icon/favicon-${resolution}x${resolution}.png`);
      link.setAttribute('sizes', `${resolution}x${resolution}`);
      link.setAttribute('type', 'image/png');
      head.appendChild(link);
    });
  }

  /**
   * Common utilities
   * @module glMatrix
   */
  // Configuration Constants
  var EPSILON$3 = 0.000001;
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
  var degree = Math.PI / 180;
  /**
   * Convert Degree To Radian
   *
   * @param {Number} a Angle in Degrees
   */

  function toRadian(a) {
    return a * degree;
  }
  if (!Math.hypot) Math.hypot = function () {
    var y = 0,
        i = arguments.length;

    while (i--) {
      y += arguments[i] * arguments[i];
    }

    return Math.sqrt(y);
  };

  /**
   * 3x3 Matrix
   * @module mat3
   */

  /**
   * Creates a new identity mat3
   *
   * @returns {mat3} a new 3x3 matrix
   */

  function create$4() {
    var out = new ARRAY_TYPE(9);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }

    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the upper-left 3x3 values into the given mat3.
   *
   * @param {mat3} out the receiving 3x3 matrix
   * @param {ReadonlyMat4} a   the source 4x4 matrix
   * @returns {mat3} out
   */

  function fromMat4(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
  }
  /**
   * Creates a new mat3 initialized with values from an existing matrix
   *
   * @param {ReadonlyMat3} a matrix to clone
   * @returns {mat3} a new 3x3 matrix
   */

  function clone$1(a) {
    var out = new ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Copy the values from one mat3 to another
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */

  function copy$2(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Create a new mat3 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} A new mat3
   */

  function fromValues$4(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  /**
   * Set the components of a mat3 to the given values
   *
   * @param {mat3} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m10 Component in column 1, row 0 position (index 3)
   * @param {Number} m11 Component in column 1, row 1 position (index 4)
   * @param {Number} m12 Component in column 1, row 2 position (index 5)
   * @param {Number} m20 Component in column 2, row 0 position (index 6)
   * @param {Number} m21 Component in column 2, row 1 position (index 7)
   * @param {Number} m22 Component in column 2, row 2 position (index 8)
   * @returns {mat3} out
   */

  function set$3(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  /**
   * Set a mat3 to the identity matrix
   *
   * @param {mat3} out the receiving matrix
   * @returns {mat3} out
   */

  function identity$4(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */

  function transpose$1(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a12 = a[5];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a01;
      out[5] = a[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a[0];
      out[1] = a[3];
      out[2] = a[6];
      out[3] = a[1];
      out[4] = a[4];
      out[5] = a[7];
      out[6] = a[2];
      out[7] = a[5];
      out[8] = a[8];
    }

    return out;
  }
  /**
   * Inverts a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */

  function invert$1(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

    var det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the source matrix
   * @returns {mat3} out
   */

  function adjoint$1(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  /**
   * Calculates the determinant of a mat3
   *
   * @param {ReadonlyMat3} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant$1(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  /**
   * Multiplies two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */

  function multiply$2(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2];
    var a10 = a[3],
        a11 = a[4],
        a12 = a[5];
    var a20 = a[6],
        a21 = a[7],
        a22 = a[8];
    var b00 = b[0],
        b01 = b[1],
        b02 = b[2];
    var b10 = b[3],
        b11 = b[4],
        b12 = b[5];
    var b20 = b[6],
        b21 = b[7],
        b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  /**
   * Translate a mat3 by the given vector
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to translate
   * @param {ReadonlyVec2} v vector to translate by
   * @returns {mat3} out
   */

  function translate$1(out, a, v) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        x = v[0],
        y = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
  }
  /**
   * Rotates a mat3 by the given angle
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function rotate$1(out, a, rad) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a10 = a[3],
        a11 = a[4],
        a12 = a[5],
        a20 = a[6],
        a21 = a[7],
        a22 = a[8],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;
    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  /**
   * Scales the mat3 by the dimensions in the given vec2
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to rotate
   * @param {ReadonlyVec2} v the vec2 to scale the matrix by
   * @returns {mat3} out
   **/

  function scale$3(out, a, v) {
    var x = v[0],
        y = v[1];
    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];
    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.translate(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyVec2} v Translation vector
   * @returns {mat3} out
   */

  function fromTranslation$1(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.rotate(dest, dest, rad);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat3} out
   */

  function fromRotation$1(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = -s;
    out[4] = c;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat3.identity(dest);
   *     mat3.scale(dest, dest, vec);
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyVec2} v Scaling vector
   * @returns {mat3} out
   */

  function fromScaling$1(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  /**
   * Copies the values from a mat2d into a mat3
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat2d} a the matrix to copy
   * @returns {mat3} out
   **/

  function fromMat2d(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;
    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;
    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
  }
  /**
   * Calculates a 3x3 matrix from the given quaternion
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyQuat} q Quaternion to create matrix from
   *
   * @returns {mat3} out
   */

  function fromQuat$1(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;
    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;
    return out;
  }
  /**
   * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
   *
   * @param {mat3} out mat3 receiving operation result
   * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
   *
   * @returns {mat3} out
   */

  function normalFromMat4(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  /**
   * Generates a 2D projection matrix with the given bounds
   *
   * @param {mat3} out mat3 frustum matrix will be written into
   * @param {number} width Width of your gl context
   * @param {number} height Height of gl context
   * @returns {mat3} out
   */

  function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
  }
  /**
   * Returns a string representation of a mat3
   *
   * @param {ReadonlyMat3} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str$1(a) {
    return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
  }
  /**
   * Returns Frobenius norm of a mat3
   *
   * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob$1(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
  }
  /**
   * Adds two mat3's
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */

  function add$3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @returns {mat3} out
   */

  function subtract$3(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat3} out the receiving matrix
   * @param {ReadonlyMat3} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat3} out
   */

  function multiplyScalar$1(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
  }
  /**
   * Adds two mat3's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat3} out the receiving vector
   * @param {ReadonlyMat3} a the first operand
   * @param {ReadonlyMat3} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat3} out
   */

  function multiplyScalarAndAdd$1(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyMat3} a The first matrix.
   * @param {ReadonlyMat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$2(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {ReadonlyMat3} a The first matrix.
   * @param {ReadonlyMat3} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$3(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3],
        a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7],
        a8 = a[8];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7],
        b8 = b[8];
    return Math.abs(a0 - b0) <= EPSILON$3 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$3 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON$3 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON$3 * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON$3 * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON$3 * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON$3 * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON$3 * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON$3 * Math.max(1.0, Math.abs(a8), Math.abs(b8));
  }
  /**
   * Alias for {@link mat3.multiply}
   * @function
   */

  var mul$1 = multiply$2;
  /**
   * Alias for {@link mat3.subtract}
   * @function
   */

  var sub$2 = subtract$3;

  var mat3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add: add$3,
    adjoint: adjoint$1,
    clone: clone$1,
    copy: copy$2,
    create: create$4,
    determinant: determinant$1,
    equals: equals$3,
    exactEquals: exactEquals$2,
    frob: frob$1,
    fromMat2d: fromMat2d,
    fromMat4: fromMat4,
    fromQuat: fromQuat$1,
    fromRotation: fromRotation$1,
    fromScaling: fromScaling$1,
    fromTranslation: fromTranslation$1,
    fromValues: fromValues$4,
    identity: identity$4,
    invert: invert$1,
    mul: mul$1,
    multiply: multiply$2,
    multiplyScalar: multiplyScalar$1,
    multiplyScalarAndAdd: multiplyScalarAndAdd$1,
    normalFromMat4: normalFromMat4,
    projection: projection,
    rotate: rotate$1,
    scale: scale$3,
    set: set$3,
    str: str$1,
    sub: sub$2,
    subtract: subtract$3,
    translate: translate$1,
    transpose: transpose$1
  });

  /**
   * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
   * @module mat4
   */

  /**
   * Creates a new identity mat4
   *
   * @returns {mat4} a new 4x4 matrix
   */

  function create$3() {
    var out = new ARRAY_TYPE(16);

    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }

    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 initialized with values from an existing matrix
   *
   * @param {ReadonlyMat4} a matrix to clone
   * @returns {mat4} a new 4x4 matrix
   */

  function clone(a) {
    var out = new ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Copy the values from one mat4 to another
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function copy$1(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Create a new mat4 with the given values
   *
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} A new mat4
   */

  function fromValues$3(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set the components of a mat4 to the given values
   *
   * @param {mat4} out the receiving matrix
   * @param {Number} m00 Component in column 0, row 0 position (index 0)
   * @param {Number} m01 Component in column 0, row 1 position (index 1)
   * @param {Number} m02 Component in column 0, row 2 position (index 2)
   * @param {Number} m03 Component in column 0, row 3 position (index 3)
   * @param {Number} m10 Component in column 1, row 0 position (index 4)
   * @param {Number} m11 Component in column 1, row 1 position (index 5)
   * @param {Number} m12 Component in column 1, row 2 position (index 6)
   * @param {Number} m13 Component in column 1, row 3 position (index 7)
   * @param {Number} m20 Component in column 2, row 0 position (index 8)
   * @param {Number} m21 Component in column 2, row 1 position (index 9)
   * @param {Number} m22 Component in column 2, row 2 position (index 10)
   * @param {Number} m23 Component in column 2, row 3 position (index 11)
   * @param {Number} m30 Component in column 3, row 0 position (index 12)
   * @param {Number} m31 Component in column 3, row 1 position (index 13)
   * @param {Number} m32 Component in column 3, row 2 position (index 14)
   * @param {Number} m33 Component in column 3, row 3 position (index 15)
   * @returns {mat4} out
   */

  function set$2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  /**
   * Set a mat4 to the identity matrix
   *
   * @param {mat4} out the receiving matrix
   * @returns {mat4} out
   */

  function identity$3(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a03 = a[3];
      var a12 = a[6],
          a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Inverts a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function invert(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  /**
   * Calculates the adjugate of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the source matrix
   * @returns {mat4} out
   */

  function adjoint(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  /**
   * Calculates the determinant of a mat4
   *
   * @param {ReadonlyMat4} a the source matrix
   * @returns {Number} determinant of a
   */

  function determinant(a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  /**
   * Multiplies two mat4s
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function multiply$1(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15]; // Cache only the current line of the second matrix

    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  /**
   * Translate a mat4 by the given vector
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to translate
   * @param {ReadonlyVec3} v vector to translate by
   * @returns {mat4} out
   */

  function translate(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;

    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
  }
  /**
   * Scales the mat4 by the dimensions in the given vec3 not using vectorization
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to scale
   * @param {ReadonlyVec3} v the vec3 to scale the matrix by
   * @returns {mat4} out
   **/

  function scale$2(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Rotates a mat4 by the given angle around the given axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @param {ReadonlyVec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function rotate(out, a, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;

    if (len < EPSILON$3) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11]; // Construct the elements of the rotation matrix

    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateX(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateY(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged rows
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to rotate
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function rotateZ(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];

    if (a !== out) {
      // If the source and destination differ, copy the unchanged last row
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    } // Perform axis-specific matrix multiplication


    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  /**
   * Creates a matrix from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyVec3} v Translation vector
   * @returns {mat4} out
   */

  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyVec3} v Scaling vector
   * @returns {mat4} out
   */

  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @param {ReadonlyVec3} axis the axis to rotate around
   * @returns {mat4} out
   */

  function fromRotation(out, rad, axis) {
    var x = axis[0],
        y = axis[1],
        z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;

    if (len < EPSILON$3) {
      return null;
    }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c; // Perform rotation-specific matrix multiplication

    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromXRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromYRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {Number} rad the angle to rotate the matrix by
   * @returns {mat4} out
   */

  function fromZRotation(out, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad); // Perform axis-specific matrix multiplication

    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @returns {mat4} out
   */

  function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a new mat4 from a dual quat.
   *
   * @param {mat4} out Matrix
   * @param {ReadonlyQuat2} a Dual Quaternion
   * @returns {mat4} mat4 receiving operation result
   */

  function fromQuat2(out, a) {
    var translation = new ARRAY_TYPE(3);
    var bx = -a[0],
        by = -a[1],
        bz = -a[2],
        bw = a[3],
        ax = a[4],
        ay = a[5],
        az = a[6],
        aw = a[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }

    fromRotationTranslation(out, a, translation);
    return out;
  }
  /**
   * Returns the translation vector component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslation,
   *  the returned vector will be the same as the translation vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive translation component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  /**
   * Returns the scaling factor component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslationScale
   *  with a normalized Quaternion paramter, the returned vector will be
   *  the same as the scaling vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  /**
   * Returns a quaternion representing the rotational component
   *  of a transformation matrix. If a matrix is built with
   *  fromRotationTranslation, the returned quaternion will be the
   *  same as the quaternion originally supplied.
   * @param {quat} out Quaternion to receive the rotation component
   * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {quat} out
   */

  function getRotation(out, mat) {
    var scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;

    if (trace > 0) {
      S = Math.sqrt(trace + 1.0) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }

    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @param {ReadonlyVec3} s Scaling vector
   * @returns {mat4} out
   */

  function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     mat4.translate(dest, origin);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *     mat4.translate(dest, negativeOrigin);
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {ReadonlyVec3} v Translation vector
   * @param {ReadonlyVec3} s Scaling vector
   * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
   * @returns {mat4} out
   */

  function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {ReadonlyQuat} q Quaternion to create matrix from
   *
   * @returns {mat4} out
   */

  function fromQuat(out, q) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a frustum matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Number} left Left bound of the frustum
   * @param {Number} right Right bound of the frustum
   * @param {Number} bottom Bottom bound of the frustum
   * @param {Number} top Top bound of the frustum
   * @param {Number} near Near bound of the frustum
   * @param {Number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} fovy Vertical field of view in radians
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum, can be null or Infinity
   * @returns {mat4} out
   */

  function perspectiveNO(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;

    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }

    return out;
  }
  /**
   * Alias for {@link mat4.perspectiveNO}
   * @function
   */

  var perspective = perspectiveNO;
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} fovy Vertical field of view in radians
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum, can be null or Infinity
   * @returns {mat4} out
   */

  function perspectiveZO(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;

    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = far * nf;
      out[14] = far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -near;
    }

    return out;
  }
  /**
   * Generates a perspective projection matrix with the given field of view.
   * This is primarily useful for generating projection matrices to be used
   * with the still experiemental WebVR API.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
    var xScale = 2.0 / (leftTan + rightTan);
    var yScale = 2.0 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = far * near / (near - far);
    out[15] = 0.0;
    return out;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function orthoNO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Alias for {@link mat4.orthoNO}
   * @function
   */

  var ortho = orthoNO;
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function orthoZO(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis.
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {ReadonlyVec3} eye Position of the viewer
   * @param {ReadonlyVec3} center Point the viewer is looking at
   * @param {ReadonlyVec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];

    if (Math.abs(eyex - centerx) < EPSILON$3 && Math.abs(eyey - centery) < EPSILON$3 && Math.abs(eyez - centerz) < EPSILON$3) {
      return identity$3(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);

    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.hypot(y0, y1, y2);

    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  /**
   * Generates a matrix that makes something look at something else.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {ReadonlyVec3} eye Position of the viewer
   * @param {ReadonlyVec3} center Point the viewer is looking at
   * @param {ReadonlyVec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function targetTo(out, eye, target, up) {
    var eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2];
    var z0 = eyex - target[0],
        z1 = eyey - target[1],
        z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      z0 *= len;
      z1 *= len;
      z2 *= len;
    }

    var x0 = upy * z2 - upz * z1,
        x1 = upz * z0 - upx * z2,
        x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  /**
   * Returns a string representation of a mat4
   *
   * @param {ReadonlyMat4} a matrix to represent as a string
   * @returns {String} string representation of the matrix
   */

  function str(a) {
    return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
  }
  /**
   * Returns Frobenius norm of a mat4
   *
   * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
   * @returns {Number} Frobenius norm
   */

  function frob(a) {
    return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
  }
  /**
   * Adds two mat4's
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function add$2(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @returns {mat4} out
   */

  function subtract$2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   *
   * @param {mat4} out the receiving matrix
   * @param {ReadonlyMat4} a the matrix to scale
   * @param {Number} b amount to scale the matrix's elements by
   * @returns {mat4} out
   */

  function multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
  }
  /**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   *
   * @param {mat4} out the receiving vector
   * @param {ReadonlyMat4} a the first operand
   * @param {ReadonlyMat4} b the second operand
   * @param {Number} scale the amount to scale b's elements by before adding
   * @returns {mat4} out
   */

  function multiplyScalarAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    out[9] = a[9] + b[9] * scale;
    out[10] = a[10] + b[10] * scale;
    out[11] = a[11] + b[11] * scale;
    out[12] = a[12] + b[12] * scale;
    out[13] = a[13] + b[13] * scale;
    out[14] = a[14] + b[14] * scale;
    out[15] = a[15] + b[15] * scale;
    return out;
  }
  /**
   * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyMat4} a The first matrix.
   * @param {ReadonlyMat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function exactEquals$1(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
  }
  /**
   * Returns whether or not the matrices have approximately the same elements in the same position.
   *
   * @param {ReadonlyMat4} a The first matrix.
   * @param {ReadonlyMat4} b The second matrix.
   * @returns {Boolean} True if the matrices are equal, false otherwise.
   */

  function equals$2(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2],
        a3 = a[3];
    var a4 = a[4],
        a5 = a[5],
        a6 = a[6],
        a7 = a[7];
    var a8 = a[8],
        a9 = a[9],
        a10 = a[10],
        a11 = a[11];
    var a12 = a[12],
        a13 = a[13],
        a14 = a[14],
        a15 = a[15];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    var b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7];
    var b8 = b[8],
        b9 = b[9],
        b10 = b[10],
        b11 = b[11];
    var b12 = b[12],
        b13 = b[13],
        b14 = b[14],
        b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON$3 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$3 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON$3 * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON$3 * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON$3 * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON$3 * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON$3 * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON$3 * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON$3 * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON$3 * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON$3 * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON$3 * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON$3 * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON$3 * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON$3 * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON$3 * Math.max(1.0, Math.abs(a15), Math.abs(b15));
  }
  /**
   * Alias for {@link mat4.multiply}
   * @function
   */

  var mul = multiply$1;
  /**
   * Alias for {@link mat4.subtract}
   * @function
   */

  var sub$1 = subtract$2;

  var mat4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add: add$2,
    adjoint: adjoint,
    clone: clone,
    copy: copy$1,
    create: create$3,
    determinant: determinant,
    equals: equals$2,
    exactEquals: exactEquals$1,
    frob: frob,
    fromQuat: fromQuat,
    fromQuat2: fromQuat2,
    fromRotation: fromRotation,
    fromRotationTranslation: fromRotationTranslation,
    fromRotationTranslationScale: fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: fromRotationTranslationScaleOrigin,
    fromScaling: fromScaling,
    fromTranslation: fromTranslation,
    fromValues: fromValues$3,
    fromXRotation: fromXRotation,
    fromYRotation: fromYRotation,
    fromZRotation: fromZRotation,
    frustum: frustum,
    getRotation: getRotation,
    getScaling: getScaling,
    getTranslation: getTranslation,
    identity: identity$3,
    invert: invert,
    lookAt: lookAt,
    mul: mul,
    multiply: multiply$1,
    multiplyScalar: multiplyScalar,
    multiplyScalarAndAdd: multiplyScalarAndAdd,
    ortho: ortho,
    orthoNO: orthoNO,
    orthoZO: orthoZO,
    perspective: perspective,
    perspectiveFromFieldOfView: perspectiveFromFieldOfView,
    perspectiveNO: perspectiveNO,
    perspectiveZO: perspectiveZO,
    rotate: rotate,
    rotateX: rotateX,
    rotateY: rotateY,
    rotateZ: rotateZ,
    scale: scale$2,
    set: set$2,
    str: str,
    sub: sub$1,
    subtract: subtract$2,
    targetTo: targetTo,
    translate: translate,
    transpose: transpose
  });

  /**
   * 3 Dimensional Vector
   * @module vec3
   */

  /**
   * Creates a new, empty vec3
   *
   * @returns {vec3} a new 3D vector
   */

  function create$2() {
    var out = new ARRAY_TYPE(3);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    return out;
  }
  /**
   * Calculates the length of a vec3
   *
   * @param {ReadonlyVec3} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.hypot(x, y, z);
  }
  /**
   * Creates a new vec3 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} a new 3D vector
   */

  function fromValues$2(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Set the components of a vec3 to the given values
   *
   * @param {vec3} out the receiving vector
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} out
   */

  function set$1(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Adds two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function add$1(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function subtract$1(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  /**
   * Scales a vec3 by a scalar number
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to scale
   * @param {Number} b amount to scale the vector by
   * @returns {vec3} out
   */

  function scale$1(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
  }
  /**
   * Returns the inverse of the components of a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to invert
   * @returns {vec3} out
   */

  function inverse(out, a) {
    out[0] = 1.0 / a[0];
    out[1] = 1.0 / a[1];
    out[2] = 1.0 / a[2];
    return out;
  }
  /**
   * Normalize a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a vector to normalize
   * @returns {vec3} out
   */

  function normalize$4(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len = x * x + y * y + z * z;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
    }

    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec3's
   *
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot$1(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Computes the cross product of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the first operand
   * @param {ReadonlyVec3} b the second operand
   * @returns {vec3} out
   */

  function cross$1(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    var bx = b[0],
        by = b[1],
        bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   *
   * @param {vec3} out the receiving vector
   * @param {ReadonlyVec3} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec3} out
   */

  function transformMat4$1(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   *
   * @param {ReadonlyVec3} a The first vector.
   * @param {ReadonlyVec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   *
   * @param {ReadonlyVec3} a The first vector.
   * @param {ReadonlyVec3} b The second vector.
   * @returns {Boolean} True if the vectors are equal, false otherwise.
   */

  function equals$1(a, b) {
    var a0 = a[0],
        a1 = a[1],
        a2 = a[2];
    var b0 = b[0],
        b1 = b[1],
        b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON$3 * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON$3 * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON$3 * Math.max(1.0, Math.abs(a2), Math.abs(b2));
  }
  /**
   * Alias for {@link vec3.subtract}
   * @function
   */

  var sub = subtract$1;
  /**
   * Alias for {@link vec3.length}
   * @function
   */

  var len = length;
  /**
   * Perform some operation over an array of vec3s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  (function () {
    var vec = create$2();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 3;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }

      return a;
    };
  })();

  /**
   * 4 Dimensional Vector
   * @module vec4
   */

  /**
   * Creates a new, empty vec4
   *
   * @returns {vec4} a new 4D vector
   */

  function create$1() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }

    return out;
  }
  /**
   * Creates a new vec4 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {vec4} a new 4D vector
   */

  function fromValues$1(x, y, z, w) {
    var out = new ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }
  /**
   * Normalize a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a vector to normalize
   * @returns {vec4} out
   */

  function normalize$3(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len = x * x + y * y + z * z + w * w;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
    }

    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
    return out;
  }
  /**
   * Transforms the vec4 with a mat4.
   *
   * @param {vec4} out the receiving vector
   * @param {ReadonlyVec4} a the vector to transform
   * @param {ReadonlyMat4} m matrix to transform with
   * @returns {vec4} out
   */

  function transformMat4(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  /**
   * Perform some operation over an array of vec4s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  (function () {
    var vec = create$1();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 4;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }

      return a;
    };
  })();

  /**
   * Quaternion
   * @module quat
   */

  /**
   * Creates a new identity quat
   *
   * @returns {quat} a new quaternion
   */

  function create() {
    var out = new ARRAY_TYPE(4);

    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }

    out[3] = 1;
    return out;
  }
  /**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyVec3} axis the axis around which to rotate
   * @param {Number} rad the angle in radians
   * @returns {quat} out
   **/

  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  /**
   * Gets the rotation axis and angle for a given
   *  quaternion. If a quaternion is created with
   *  setAxisAngle, this method will return the same
   *  values as providied in the original parameter list
   *  OR functionally equivalent values.
   * Example: The quaternion formed by axis [0, 0, 1] and
   *  angle -90 is the same as the quaternion formed by
   *  [0, 0, 1] and 270. This method favors the latter.
   * @param  {vec3} out_axis  Vector receiving the axis of rotation
   * @param  {ReadonlyQuat} q     Quaternion to be decomposed
   * @return {Number}     Angle, in radians, of the rotation
   */

  function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);

    if (s > EPSILON$3) {
      out_axis[0] = q[0] / s;
      out_axis[1] = q[1] / s;
      out_axis[2] = q[2] / s;
    } else {
      // If s is zero, return any axis (no rotation - axis does not matter)
      out_axis[0] = 1;
      out_axis[1] = 0;
      out_axis[2] = 0;
    }

    return rad;
  }
  /**
   * Multiplies two quat's
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @returns {quat} out
   */

  function multiply(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    var omega, cosom, sinom, scale0, scale1; // calc cosine

    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    } // calculate coefficients


    if (1.0 - cosom > EPSILON$3) {
      // standard case (slerp)
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      // "from" and "to" quaternions are very close
      //  ... so we can do a linear interpolation
      scale0 = 1.0 - t;
      scale1 = t;
    } // calculate final values


    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  /**
   * Calculates the conjugate of a quat
   * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quat to calculate conjugate of
   * @returns {quat} out
   */

  function conjugate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyMat3} m rotation matrix
   * @returns {quat} out
   * @function
   */

  function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if (fTrace > 0.0) {
      // |w| > 1/2, may as well choose w > 1/2
      fRoot = Math.sqrt(fTrace + 1.0); // 2w

      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot; // 1/(4w)

      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      // |w| <= 1/2
      var i = 0;
      if (m[4] > m[0]) i = 1;
      if (m[8] > m[i * 3 + i]) i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }

    return out;
  }
  /**
   * Creates a new quat initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @param {Number} w W component
   * @returns {quat} a new quaternion
   * @function
   */

  var fromValues = fromValues$1;
  /**
   * Normalize a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a quaternion to normalize
   * @returns {quat} out
   * @function
   */

  var normalize$2 = normalize$3;
  /**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   *
   * Both vectors are assumed to be unit length.
   *
   * @param {quat} out the receiving quaternion.
   * @param {ReadonlyVec3} a the initial vector
   * @param {ReadonlyVec3} b the destination vector
   * @returns {quat} out
   */

  (function () {
    var tmpvec3 = create$2();
    var xUnitVec3 = fromValues$2(1, 0, 0);
    var yUnitVec3 = fromValues$2(0, 1, 0);
    return function (out, a, b) {
      var dot = dot$1(a, b);

      if (dot < -0.999999) {
        cross$1(tmpvec3, xUnitVec3, a);
        if (len(tmpvec3) < 0.000001) cross$1(tmpvec3, yUnitVec3, a);
        normalize$4(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross$1(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot;
        return normalize$2(out, out);
      }
    };
  })();
  /**
   * Performs a spherical linear interpolation with two control points
   *
   * @param {quat} out the receiving quaternion
   * @param {ReadonlyQuat} a the first operand
   * @param {ReadonlyQuat} b the second operand
   * @param {ReadonlyQuat} c the third operand
   * @param {ReadonlyQuat} d the fourth operand
   * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
   * @returns {quat} out
   */

  (function () {
    var temp1 = create();
    var temp2 = create();
    return function (out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  })();
  /**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   *
   * @param {ReadonlyVec3} view  the vector representing the viewing direction
   * @param {ReadonlyVec3} right the vector representing the local "right" direction
   * @param {ReadonlyVec3} up    the vector representing the local "up" direction
   * @returns {quat} out
   */

  (function () {
    var matr = create$4();
    return function (out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize$2(out, fromMat3(out, matr));
    };
  })();

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  // do not edit .js files directly - edit src/index.jst



  var fastDeepEqual = function equal(a, b) {
    if (a === b) return true;

    if (a && b && typeof a == 'object' && typeof b == 'object') {
      if (a.constructor !== b.constructor) return false;

      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0;)
          if (!equal(a[i], b[i])) return false;
        return true;
      }



      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;

      for (i = length; i-- !== 0;)
        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

      for (i = length; i-- !== 0;) {
        var key = keys[i];

        if (!equal(a[key], b[key])) return false;
      }

      return true;
    }

    // true if both NaN, false otherwise
    return a!==a && b!==b;
  };

  var DeepEqual = /*@__PURE__*/getDefaultExportFromCjs(fastDeepEqual);

  var toStr$2 = Object.prototype.toString;

  var isArguments = function isArguments(value) {
  	var str = toStr$2.call(value);
  	var isArgs = str === '[object Arguments]';
  	if (!isArgs) {
  		isArgs = str !== '[object Array]' &&
  			value !== null &&
  			typeof value === 'object' &&
  			typeof value.length === 'number' &&
  			value.length >= 0 &&
  			toStr$2.call(value.callee) === '[object Function]';
  	}
  	return isArgs;
  };

  var implementation$5;
  var hasRequiredImplementation;

  function requireImplementation () {
  	if (hasRequiredImplementation) return implementation$5;
  	hasRequiredImplementation = 1;

  	var keysShim;
  	if (!Object.keys) {
  		// modified from https://github.com/es-shims/es5-shim
  		var has = Object.prototype.hasOwnProperty;
  		var toStr = Object.prototype.toString;
  		var isArgs = isArguments; // eslint-disable-line global-require
  		var isEnumerable = Object.prototype.propertyIsEnumerable;
  		var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
  		var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
  		var dontEnums = [
  			'toString',
  			'toLocaleString',
  			'valueOf',
  			'hasOwnProperty',
  			'isPrototypeOf',
  			'propertyIsEnumerable',
  			'constructor'
  		];
  		var equalsConstructorPrototype = function (o) {
  			var ctor = o.constructor;
  			return ctor && ctor.prototype === o;
  		};
  		var excludedKeys = {
  			$applicationCache: true,
  			$console: true,
  			$external: true,
  			$frame: true,
  			$frameElement: true,
  			$frames: true,
  			$innerHeight: true,
  			$innerWidth: true,
  			$onmozfullscreenchange: true,
  			$onmozfullscreenerror: true,
  			$outerHeight: true,
  			$outerWidth: true,
  			$pageXOffset: true,
  			$pageYOffset: true,
  			$parent: true,
  			$scrollLeft: true,
  			$scrollTop: true,
  			$scrollX: true,
  			$scrollY: true,
  			$self: true,
  			$webkitIndexedDB: true,
  			$webkitStorageInfo: true,
  			$window: true
  		};
  		var hasAutomationEqualityBug = (function () {
  			/* global window */
  			if (typeof window === 'undefined') { return false; }
  			for (var k in window) {
  				try {
  					if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
  						try {
  							equalsConstructorPrototype(window[k]);
  						} catch (e) {
  							return true;
  						}
  					}
  				} catch (e) {
  					return true;
  				}
  			}
  			return false;
  		}());
  		var equalsConstructorPrototypeIfNotBuggy = function (o) {
  			/* global window */
  			if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
  				return equalsConstructorPrototype(o);
  			}
  			try {
  				return equalsConstructorPrototype(o);
  			} catch (e) {
  				return false;
  			}
  		};

  		keysShim = function keys(object) {
  			var isObject = object !== null && typeof object === 'object';
  			var isFunction = toStr.call(object) === '[object Function]';
  			var isArguments = isArgs(object);
  			var isString = isObject && toStr.call(object) === '[object String]';
  			var theKeys = [];

  			if (!isObject && !isFunction && !isArguments) {
  				throw new TypeError('Object.keys called on a non-object');
  			}

  			var skipProto = hasProtoEnumBug && isFunction;
  			if (isString && object.length > 0 && !has.call(object, 0)) {
  				for (var i = 0; i < object.length; ++i) {
  					theKeys.push(String(i));
  				}
  			}

  			if (isArguments && object.length > 0) {
  				for (var j = 0; j < object.length; ++j) {
  					theKeys.push(String(j));
  				}
  			} else {
  				for (var name in object) {
  					if (!(skipProto && name === 'prototype') && has.call(object, name)) {
  						theKeys.push(String(name));
  					}
  				}
  			}

  			if (hasDontEnumBug) {
  				var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

  				for (var k = 0; k < dontEnums.length; ++k) {
  					if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
  						theKeys.push(dontEnums[k]);
  					}
  				}
  			}
  			return theKeys;
  		};
  	}
  	implementation$5 = keysShim;
  	return implementation$5;
  }

  var slice = Array.prototype.slice;
  var isArgs = isArguments;

  var origKeys = Object.keys;
  var keysShim = origKeys ? function keys(o) { return origKeys(o); } : requireImplementation();

  var originalKeys = Object.keys;

  keysShim.shim = function shimObjectKeys() {
  	if (Object.keys) {
  		var keysWorksWithArguments = (function () {
  			// Safari 5.0 bug
  			var args = Object.keys(arguments);
  			return args && args.length === arguments.length;
  		}(1, 2));
  		if (!keysWorksWithArguments) {
  			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
  				if (isArgs(object)) {
  					return originalKeys(slice.call(object));
  				}
  				return originalKeys(object);
  			};
  		}
  	} else {
  		Object.keys = keysShim;
  	}
  	return Object.keys || keysShim;
  };

  var objectKeys = keysShim;

  /** @type {import('.')} */
  var esErrors = Error;

  /** @type {import('./eval')} */
  var _eval = EvalError;

  /** @type {import('./range')} */
  var range = RangeError;

  /** @type {import('./ref')} */
  var ref = ReferenceError;

  /** @type {import('./syntax')} */
  var syntax = SyntaxError;

  /** @type {import('./type')} */
  var type = TypeError;

  /** @type {import('./uri')} */
  var uri = URIError;

  /* eslint complexity: [2, 18], max-statements: [2, 33] */
  var shams = function hasSymbols() {
  	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
  	if (typeof Symbol.iterator === 'symbol') { return true; }

  	var obj = {};
  	var sym = Symbol('test');
  	var symObj = Object(sym);
  	if (typeof sym === 'string') { return false; }

  	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
  	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

  	// temp disabled per https://github.com/ljharb/object.assign/issues/17
  	// if (sym instanceof Symbol) { return false; }
  	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  	// if (!(symObj instanceof Symbol)) { return false; }

  	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
  	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

  	var symVal = 42;
  	obj[sym] = symVal;
  	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
  	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

  	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

  	var syms = Object.getOwnPropertySymbols(obj);
  	if (syms.length !== 1 || syms[0] !== sym) { return false; }

  	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

  	if (typeof Object.getOwnPropertyDescriptor === 'function') {
  		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
  		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
  	}

  	return true;
  };

  var origSymbol = typeof Symbol !== 'undefined' && Symbol;
  var hasSymbolSham = shams;

  var hasSymbols$2 = function hasNativeSymbols() {
  	if (typeof origSymbol !== 'function') { return false; }
  	if (typeof Symbol !== 'function') { return false; }
  	if (typeof origSymbol('foo') !== 'symbol') { return false; }
  	if (typeof Symbol('bar') !== 'symbol') { return false; }

  	return hasSymbolSham();
  };

  var test = {
  	__proto__: null,
  	foo: {}
  };

  var $Object = Object;

  /** @type {import('.')} */
  var hasProto$1 = function hasProto() {
  	// @ts-expect-error: TS errors on an inherited property for some reason
  	return { __proto__: test }.foo === test.foo
  		&& !(test instanceof $Object);
  };

  /* eslint no-invalid-this: 1 */

  var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
  var toStr$1 = Object.prototype.toString;
  var max$1 = Math.max;
  var funcType = '[object Function]';

  var concatty = function concatty(a, b) {
      var arr = [];

      for (var i = 0; i < a.length; i += 1) {
          arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
          arr[j + a.length] = b[j];
      }

      return arr;
  };

  var slicy = function slicy(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
          arr[j] = arrLike[i];
      }
      return arr;
  };

  var joiny = function (arr, joiner) {
      var str = '';
      for (var i = 0; i < arr.length; i += 1) {
          str += arr[i];
          if (i + 1 < arr.length) {
              str += joiner;
          }
      }
      return str;
  };

  var implementation$4 = function bind(that) {
      var target = this;
      if (typeof target !== 'function' || toStr$1.apply(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);

      var bound;
      var binder = function () {
          if (this instanceof bound) {
              var result = target.apply(
                  this,
                  concatty(args, arguments)
              );
              if (Object(result) === result) {
                  return result;
              }
              return this;
          }
          return target.apply(
              that,
              concatty(args, arguments)
          );

      };

      var boundLength = max$1(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
          boundArgs[i] = '$' + i;
      }

      bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

      if (target.prototype) {
          var Empty = function Empty() {};
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
      }

      return bound;
  };

  var implementation$3 = implementation$4;

  var functionBind = Function.prototype.bind || implementation$3;

  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind$1 = functionBind;

  /** @type {import('.')} */
  var hasown = bind$1.call(call, $hasOwn);

  var undefined$1;

  var $Error = esErrors;
  var $EvalError = _eval;
  var $RangeError = range;
  var $ReferenceError = ref;
  var $SyntaxError$1 = syntax;
  var $TypeError$1 = type;
  var $URIError = uri;

  var $Function = Function;

  // eslint-disable-next-line consistent-return
  var getEvalledConstructor = function (expressionSyntax) {
  	try {
  		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  	} catch (e) {}
  };

  var $gOPD$1 = Object.getOwnPropertyDescriptor;
  if ($gOPD$1) {
  	try {
  		$gOPD$1({}, '');
  	} catch (e) {
  		$gOPD$1 = null; // this is IE 8, which has a broken gOPD
  	}
  }

  var throwTypeError = function () {
  	throw new $TypeError$1();
  };
  var ThrowTypeError = $gOPD$1
  	? (function () {
  		try {
  			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
  			arguments.callee; // IE 8 does not throw here
  			return throwTypeError;
  		} catch (calleeThrows) {
  			try {
  				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
  				return $gOPD$1(arguments, 'callee').get;
  			} catch (gOPDthrows) {
  				return throwTypeError;
  			}
  		}
  	}())
  	: throwTypeError;

  var hasSymbols$1 = hasSymbols$2();
  var hasProto = hasProto$1();

  var getProto = Object.getPrototypeOf || (
  	hasProto
  		? function (x) { return x.__proto__; } // eslint-disable-line no-proto
  		: null
  );

  var needsEval = {};

  var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined$1 : getProto(Uint8Array);

  var INTRINSICS = {
  	__proto__: null,
  	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
  	'%Array%': Array,
  	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
  	'%ArrayIteratorPrototype%': hasSymbols$1 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  	'%AsyncFromSyncIteratorPrototype%': undefined$1,
  	'%AsyncFunction%': needsEval,
  	'%AsyncGenerator%': needsEval,
  	'%AsyncGeneratorFunction%': needsEval,
  	'%AsyncIteratorPrototype%': needsEval,
  	'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
  	'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
  	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
  	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
  	'%Boolean%': Boolean,
  	'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
  	'%Date%': Date,
  	'%decodeURI%': decodeURI,
  	'%decodeURIComponent%': decodeURIComponent,
  	'%encodeURI%': encodeURI,
  	'%encodeURIComponent%': encodeURIComponent,
  	'%Error%': $Error,
  	'%eval%': eval, // eslint-disable-line no-eval
  	'%EvalError%': $EvalError,
  	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
  	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
  	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
  	'%Function%': $Function,
  	'%GeneratorFunction%': needsEval,
  	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
  	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
  	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
  	'%isFinite%': isFinite,
  	'%isNaN%': isNaN,
  	'%IteratorPrototype%': hasSymbols$1 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  	'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
  	'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
  	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$1 || !getProto ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
  	'%Math%': Math,
  	'%Number%': Number,
  	'%Object%': Object,
  	'%parseFloat%': parseFloat,
  	'%parseInt%': parseInt,
  	'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
  	'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
  	'%RangeError%': $RangeError,
  	'%ReferenceError%': $ReferenceError,
  	'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
  	'%RegExp%': RegExp,
  	'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
  	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$1 || !getProto ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
  	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
  	'%String%': String,
  	'%StringIteratorPrototype%': hasSymbols$1 && getProto ? getProto(''[Symbol.iterator]()) : undefined$1,
  	'%Symbol%': hasSymbols$1 ? Symbol : undefined$1,
  	'%SyntaxError%': $SyntaxError$1,
  	'%ThrowTypeError%': ThrowTypeError,
  	'%TypedArray%': TypedArray,
  	'%TypeError%': $TypeError$1,
  	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
  	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
  	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
  	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
  	'%URIError%': $URIError,
  	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
  	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
  	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
  };

  if (getProto) {
  	try {
  		null.error; // eslint-disable-line no-unused-expressions
  	} catch (e) {
  		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
  		var errorProto = getProto(getProto(e));
  		INTRINSICS['%Error.prototype%'] = errorProto;
  	}
  }

  var doEval = function doEval(name) {
  	var value;
  	if (name === '%AsyncFunction%') {
  		value = getEvalledConstructor('async function () {}');
  	} else if (name === '%GeneratorFunction%') {
  		value = getEvalledConstructor('function* () {}');
  	} else if (name === '%AsyncGeneratorFunction%') {
  		value = getEvalledConstructor('async function* () {}');
  	} else if (name === '%AsyncGenerator%') {
  		var fn = doEval('%AsyncGeneratorFunction%');
  		if (fn) {
  			value = fn.prototype;
  		}
  	} else if (name === '%AsyncIteratorPrototype%') {
  		var gen = doEval('%AsyncGenerator%');
  		if (gen && getProto) {
  			value = getProto(gen.prototype);
  		}
  	}

  	INTRINSICS[name] = value;

  	return value;
  };

  var LEGACY_ALIASES = {
  	__proto__: null,
  	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  	'%ArrayPrototype%': ['Array', 'prototype'],
  	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
  	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  	'%BooleanPrototype%': ['Boolean', 'prototype'],
  	'%DataViewPrototype%': ['DataView', 'prototype'],
  	'%DatePrototype%': ['Date', 'prototype'],
  	'%ErrorPrototype%': ['Error', 'prototype'],
  	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
  	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  	'%FunctionPrototype%': ['Function', 'prototype'],
  	'%Generator%': ['GeneratorFunction', 'prototype'],
  	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  	'%JSONParse%': ['JSON', 'parse'],
  	'%JSONStringify%': ['JSON', 'stringify'],
  	'%MapPrototype%': ['Map', 'prototype'],
  	'%NumberPrototype%': ['Number', 'prototype'],
  	'%ObjectPrototype%': ['Object', 'prototype'],
  	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  	'%PromisePrototype%': ['Promise', 'prototype'],
  	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  	'%Promise_all%': ['Promise', 'all'],
  	'%Promise_reject%': ['Promise', 'reject'],
  	'%Promise_resolve%': ['Promise', 'resolve'],
  	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
  	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  	'%RegExpPrototype%': ['RegExp', 'prototype'],
  	'%SetPrototype%': ['Set', 'prototype'],
  	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  	'%StringPrototype%': ['String', 'prototype'],
  	'%SymbolPrototype%': ['Symbol', 'prototype'],
  	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
  	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  	'%URIErrorPrototype%': ['URIError', 'prototype'],
  	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
  	'%WeakSetPrototype%': ['WeakSet', 'prototype']
  };

  var bind = functionBind;
  var hasOwn = hasown;
  var $concat = bind.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
  var $replace = bind.call(Function.call, String.prototype.replace);
  var $strSlice = bind.call(Function.call, String.prototype.slice);
  var $exec = bind.call(Function.call, RegExp.prototype.exec);

  /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
  var stringToPath = function stringToPath(string) {
  	var first = $strSlice(string, 0, 1);
  	var last = $strSlice(string, -1);
  	if (first === '%' && last !== '%') {
  		throw new $SyntaxError$1('invalid intrinsic syntax, expected closing `%`');
  	} else if (last === '%' && first !== '%') {
  		throw new $SyntaxError$1('invalid intrinsic syntax, expected opening `%`');
  	}
  	var result = [];
  	$replace(string, rePropName, function (match, number, quote, subString) {
  		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  	});
  	return result;
  };
  /* end adaptation */

  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  	var intrinsicName = name;
  	var alias;
  	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
  		alias = LEGACY_ALIASES[intrinsicName];
  		intrinsicName = '%' + alias[0] + '%';
  	}

  	if (hasOwn(INTRINSICS, intrinsicName)) {
  		var value = INTRINSICS[intrinsicName];
  		if (value === needsEval) {
  			value = doEval(intrinsicName);
  		}
  		if (typeof value === 'undefined' && !allowMissing) {
  			throw new $TypeError$1('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
  		}

  		return {
  			alias: alias,
  			name: intrinsicName,
  			value: value
  		};
  	}

  	throw new $SyntaxError$1('intrinsic ' + name + ' does not exist!');
  };

  var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  	if (typeof name !== 'string' || name.length === 0) {
  		throw new $TypeError$1('intrinsic name must be a non-empty string');
  	}
  	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
  		throw new $TypeError$1('"allowMissing" argument must be a boolean');
  	}

  	if ($exec(/^%?[^%]*%?$/, name) === null) {
  		throw new $SyntaxError$1('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
  	}
  	var parts = stringToPath(name);
  	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

  	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  	var intrinsicRealName = intrinsic.name;
  	var value = intrinsic.value;
  	var skipFurtherCaching = false;

  	var alias = intrinsic.alias;
  	if (alias) {
  		intrinsicBaseName = alias[0];
  		$spliceApply(parts, $concat([0, 1], alias));
  	}

  	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
  		var part = parts[i];
  		var first = $strSlice(part, 0, 1);
  		var last = $strSlice(part, -1);
  		if (
  			(
  				(first === '"' || first === "'" || first === '`')
  				|| (last === '"' || last === "'" || last === '`')
  			)
  			&& first !== last
  		) {
  			throw new $SyntaxError$1('property names with quotes must have matching quotes');
  		}
  		if (part === 'constructor' || !isOwn) {
  			skipFurtherCaching = true;
  		}

  		intrinsicBaseName += '.' + part;
  		intrinsicRealName = '%' + intrinsicBaseName + '%';

  		if (hasOwn(INTRINSICS, intrinsicRealName)) {
  			value = INTRINSICS[intrinsicRealName];
  		} else if (value != null) {
  			if (!(part in value)) {
  				if (!allowMissing) {
  					throw new $TypeError$1('base intrinsic for ' + name + ' exists, but the property is not available.');
  				}
  				return void undefined$1;
  			}
  			if ($gOPD$1 && (i + 1) >= parts.length) {
  				var desc = $gOPD$1(value, part);
  				isOwn = !!desc;

  				// By convention, when a data property is converted to an accessor
  				// property to emulate a data property that does not suffer from
  				// the override mistake, that accessor's getter is marked with
  				// an `originalValue` property. Here, when we detect this, we
  				// uphold the illusion by pretending to see that original data
  				// property, i.e., returning the value rather than the getter
  				// itself.
  				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
  					value = desc.get;
  				} else {
  					value = value[part];
  				}
  			} else {
  				isOwn = hasOwn(value, part);
  				value = value[part];
  			}

  			if (isOwn && !skipFurtherCaching) {
  				INTRINSICS[intrinsicRealName] = value;
  			}
  		}
  	}
  	return value;
  };

  var GetIntrinsic$1 = getIntrinsic;

  /** @type {import('.')} */
  var $defineProperty$2 = GetIntrinsic$1('%Object.defineProperty%', true) || false;
  if ($defineProperty$2) {
  	try {
  		$defineProperty$2({}, 'a', { value: 1 });
  	} catch (e) {
  		// IE 8 has a broken defineProperty
  		$defineProperty$2 = false;
  	}
  }

  var esDefineProperty = $defineProperty$2;

  var GetIntrinsic = getIntrinsic;

  var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

  if ($gOPD) {
  	try {
  		$gOPD([], 'length');
  	} catch (e) {
  		// IE 8 has a broken gOPD
  		$gOPD = null;
  	}
  }

  var gopd$1 = $gOPD;

  var $defineProperty$1 = esDefineProperty;

  var $SyntaxError = syntax;
  var $TypeError = type;

  var gopd = gopd$1;

  /** @type {import('.')} */
  var defineDataProperty$1 = function defineDataProperty(
  	obj,
  	property,
  	value
  ) {
  	if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
  		throw new $TypeError('`obj` must be an object or a function`');
  	}
  	if (typeof property !== 'string' && typeof property !== 'symbol') {
  		throw new $TypeError('`property` must be a string or a symbol`');
  	}
  	if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
  		throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
  	}
  	if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
  		throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
  	}
  	if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
  		throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
  	}
  	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
  		throw new $TypeError('`loose`, if provided, must be a boolean');
  	}

  	var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  	var nonWritable = arguments.length > 4 ? arguments[4] : null;
  	var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  	var loose = arguments.length > 6 ? arguments[6] : false;

  	/* @type {false | TypedPropertyDescriptor<unknown>} */
  	var desc = !!gopd && gopd(obj, property);

  	if ($defineProperty$1) {
  		$defineProperty$1(obj, property, {
  			configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
  			enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
  			value: value,
  			writable: nonWritable === null && desc ? desc.writable : !nonWritable
  		});
  	} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
  		// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
  		obj[property] = value; // eslint-disable-line no-param-reassign
  	} else {
  		throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
  	}
  };

  var $defineProperty = esDefineProperty;

  var hasPropertyDescriptors = function hasPropertyDescriptors() {
  	return !!$defineProperty;
  };

  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  	// node v0.6 has a bug where array lengths can be Set but not Defined
  	if (!$defineProperty) {
  		return null;
  	}
  	try {
  		return $defineProperty([], 'length', { value: 1 }).length !== 1;
  	} catch (e) {
  		// In Firefox 4-22, defining length on an array throws an exception.
  		return true;
  	}
  };

  var hasPropertyDescriptors_1 = hasPropertyDescriptors;

  var keys = objectKeys;
  var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

  var toStr = Object.prototype.toString;
  var concat = Array.prototype.concat;
  var defineDataProperty = defineDataProperty$1;

  var isFunction = function (fn) {
  	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
  };

  var supportsDescriptors = hasPropertyDescriptors_1();

  var defineProperty = function (object, name, value, predicate) {
  	if (name in object) {
  		if (predicate === true) {
  			if (object[name] === value) {
  				return;
  			}
  		} else if (!isFunction(predicate) || !predicate()) {
  			return;
  		}
  	}

  	if (supportsDescriptors) {
  		defineDataProperty(object, name, value, true);
  	} else {
  		defineDataProperty(object, name, value);
  	}
  };

  var defineProperties$1 = function (object, map) {
  	var predicates = arguments.length > 2 ? arguments[2] : {};
  	var props = keys(map);
  	if (hasSymbols) {
  		props = concat.call(props, Object.getOwnPropertySymbols(map));
  	}
  	for (var i = 0; i < props.length; i += 1) {
  		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
  	}
  };

  defineProperties$1.supportsDescriptors = !!supportsDescriptors;

  var defineProperties_1 = defineProperties$1;

  var implementation$2 = commonjsGlobal;

  var implementation$1 = implementation$2;

  var polyfill$1 = function getPolyfill() {
  	if (typeof commonjsGlobal !== 'object' || !commonjsGlobal || commonjsGlobal.Math !== Math || commonjsGlobal.Array !== Array) {
  		return implementation$1;
  	}
  	return commonjsGlobal;
  };

  var define$1 = defineProperties_1;
  var getPolyfill$1 = polyfill$1;

  var shim$1 = function shimGlobal() {
  	var polyfill = getPolyfill$1();
  	if (define$1.supportsDescriptors) {
  		var descriptor = Object.getOwnPropertyDescriptor(polyfill, 'globalThis');
  		if (!descriptor || (descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill))) { // eslint-disable-line max-len
  			Object.defineProperty(polyfill, 'globalThis', {
  				configurable: true,
  				enumerable: false,
  				value: polyfill,
  				writable: true
  			});
  		}
  	} else if (typeof globalThis !== 'object' || globalThis !== polyfill) {
  		polyfill.globalThis = polyfill;
  	}
  	return polyfill;
  };

  var defineProperties = defineProperties_1;

  var implementation = implementation$2;
  var getPolyfill = polyfill$1;
  var shim = shim$1;

  var polyfill = getPolyfill();

  var getGlobal = function () { return polyfill; };

  defineProperties(getGlobal, {
  	getPolyfill: getPolyfill,
  	implementation: implementation,
  	shim: shim
  });

  var globalthis = getGlobal;

  var globalThisShim = /*@__PURE__*/getDefaultExportFromCjs(globalthis);

  const vtkGlobal = globalThisShim(); // returns native globalThis if compliant

  const factoryMapping = {
    vtkObject: () => null
  };
  function vtk(obj) {
    if (obj === null || obj === undefined) {
      return obj;
    }
    if (obj.isA) {
      return obj;
    }
    if (!obj.vtkClass) {
      if (vtkGlobal.console && vtkGlobal.console.error) {
        vtkGlobal.console.error('Invalid VTK object');
      }
      return null;
    }
    const constructor = factoryMapping[obj.vtkClass];
    if (!constructor) {
      if (vtkGlobal.console && vtkGlobal.console.error) {
        vtkGlobal.console.error(`No vtk class found for Object of type ${obj.vtkClass}`);
      }
      return null;
    }

    // Shallow copy object
    const model = {
      ...obj
    };

    // Convert into vtkObject any nested key
    Object.keys(model).forEach(keyName => {
      if (model[keyName] && typeof model[keyName] === 'object' && model[keyName].vtkClass) {
        model[keyName] = vtk(model[keyName]);
      }
    });

    // Return the root
    const newInst = constructor(model);
    if (newInst && newInst.modified) {
      newInst.modified();
    }
    return newInst;
  }
  function register(vtkClassName, constructor) {
    factoryMapping[vtkClassName] = constructor;
  }

  // Nest register method under the vtk function
  vtk.register = register;

  /* eslint-disable prefer-rest-params */
  class ClassHierarchy extends Array {
    push() {
      for (let i = 0; i < arguments.length; i++) {
        if (!this.includes(arguments[i])) {
          super.push(arguments[i]);
        }
      }
      return this.length;
    }
  }

  /**
   * macros.js is the old macro.js.
   * The name change is so we do not get eaten by babel-plugin-macros.
   */
  let globalMTime = 0;
  const VOID$1 = Symbol('void');
  function getCurrentGlobalMTime() {
    return globalMTime;
  }

  // ----------------------------------------------------------------------------
  // Logging function calls
  // ----------------------------------------------------------------------------
  /* eslint-disable no-prototype-builtins                                      */

  const fakeConsole = {};
  function noOp() {}
  const consoleMethods = ['log', 'debug', 'info', 'warn', 'error', 'time', 'timeEnd', 'group', 'groupEnd'];
  consoleMethods.forEach(methodName => {
    fakeConsole[methodName] = noOp;
  });
  vtkGlobal.console = console.hasOwnProperty('log') ? console : fakeConsole;
  const loggerFunctions = {
    debug: noOp,
    // Don't print debug by default
    error: vtkGlobal.console.error || noOp,
    info: vtkGlobal.console.info || noOp,
    log: vtkGlobal.console.log || noOp,
    warn: vtkGlobal.console.warn || noOp
  };
  function setLoggerFunction(name, fn) {
    if (loggerFunctions[name]) {
      loggerFunctions[name] = fn || noOp;
    }
  }
  function vtkLogMacro() {
    loggerFunctions.log(...arguments);
  }
  function vtkInfoMacro() {
    loggerFunctions.info(...arguments);
  }
  function vtkDebugMacro$9() {
    loggerFunctions.debug(...arguments);
  }
  function vtkErrorMacro$v() {
    loggerFunctions.error(...arguments);
  }
  function vtkWarningMacro$7() {
    loggerFunctions.warn(...arguments);
  }
  const ERROR_ONCE_MAP = {};
  function vtkOnceErrorMacro$1(str) {
    if (!ERROR_ONCE_MAP[str]) {
      loggerFunctions.error(str);
      ERROR_ONCE_MAP[str] = true;
    }
  }

  // ----------------------------------------------------------------------------
  // TypedArray
  // ----------------------------------------------------------------------------

  const TYPED_ARRAYS = Object.create(null);
  TYPED_ARRAYS.Float32Array = Float32Array;
  TYPED_ARRAYS.Float64Array = Float64Array;
  TYPED_ARRAYS.Uint8Array = Uint8Array;
  TYPED_ARRAYS.Int8Array = Int8Array;
  TYPED_ARRAYS.Uint16Array = Uint16Array;
  TYPED_ARRAYS.Int16Array = Int16Array;
  TYPED_ARRAYS.Uint32Array = Uint32Array;
  TYPED_ARRAYS.Int32Array = Int32Array;
  TYPED_ARRAYS.Uint8ClampedArray = Uint8ClampedArray;
  try {
    TYPED_ARRAYS.BigInt64Array = BigInt64Array;
    TYPED_ARRAYS.BigUint64Array = BigUint64Array;
  } catch {
    // ignore
  }
  function newTypedArray(type) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return new (TYPED_ARRAYS[type] || Float64Array)(...args);
  }
  function newTypedArrayFrom(type) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return (TYPED_ARRAYS[type] || Float64Array).from(...args);
  }

  // ----------------------------------------------------------------------------
  // capitilize provided string
  // ----------------------------------------------------------------------------

  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  function _capitalize(str) {
    return capitalize(str[0] === '_' ? str.slice(1) : str);
  }
  function uncapitalize(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
  }

  // ----------------------------------------------------------------------------
  // Convert byte size into a well formatted string
  // ----------------------------------------------------------------------------

  function formatBytesToProperUnit(size) {
    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    let chunkSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
    const units = ['TB', 'GB', 'MB', 'KB'];
    let value = Number(size);
    let currentUnit = 'B';
    while (value > chunkSize) {
      value /= chunkSize;
      currentUnit = units.pop();
    }
    return `${value.toFixed(precision)} ${currentUnit}`;
  }

  // ----------------------------------------------------------------------------
  // Convert thousand number with proper separator
  // ----------------------------------------------------------------------------

  function formatNumbersWithThousandSeparator(n) {
    let separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';
    const sections = [];
    let size = n;
    while (size > 1000) {
      sections.push(`000${size % 1000}`.slice(-3));
      size = Math.floor(size / 1000);
    }
    if (size > 0) {
      sections.push(size);
    }
    sections.reverse();
    return sections.join(separator);
  }

  // ----------------------------------------------------------------------------
  // Array helper
  // ----------------------------------------------------------------------------

  function safeArrays(model) {
    Object.keys(model).forEach(key => {
      if (Array.isArray(model[key])) {
        model[key] = [].concat(model[key]);
      }
    });
  }
  function isTypedArray(value) {
    return Object.values(TYPED_ARRAYS).some(ctor => value instanceof ctor);
  }

  // ----------------------------------------------------------------------------
  // shallow equals
  // ----------------------------------------------------------------------------

  function shallowEquals(a, b) {
    if (a === b) {
      return true;
    }
    if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // ----------------------------------------------------------------------------

  function enumToString(e, value) {
    return Object.keys(e).find(key => e[key] === value);
  }
  function getStateArrayMapFunc(item) {
    if (item && item.isA) {
      return item.getState();
    }
    return item;
  }

  // ----------------------------------------------------------------------------
  // setImmediate
  // ----------------------------------------------------------------------------

  function setImmediateVTK(fn) {
    setTimeout(fn, 0);
  }

  // ----------------------------------------------------------------------------
  // measurePromiseExecution
  //
  // Measures the time it takes for a promise to finish from
  //   the time this function is invoked.
  // The callback receives the time it took for the promise to resolve or reject.
  // ----------------------------------------------------------------------------

  function measurePromiseExecution(promise, callback) {
    const start = performance.now();
    promise.finally(() => {
      const delta = performance.now() - start;
      callback(delta);
    });
  }

  // ----------------------------------------------------------------------------
  // vtkObject: modified(), onModified(callback), delete()
  // ----------------------------------------------------------------------------

  function obj() {
    let publicAPI = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // Ensure each instance as a unique ref of array
    safeArrays(model);
    const callbacks = [];
    if (!Number.isInteger(model.mtime)) {
      model.mtime = ++globalMTime;
    }
    if (!('classHierarchy' in model)) {
      model.classHierarchy = new ClassHierarchy('vtkObject');
    } else if (!(model.classHierarchy instanceof ClassHierarchy)) {
      const hierarchy = new ClassHierarchy();
      for (let i = 0; i < model.classHierarchy.length; i++) {
        hierarchy.push(model.classHierarchy[i]);
      }
      model.classHierarchy = hierarchy;
    }
    function off(index) {
      callbacks[index] = null;
    }
    function on(index) {
      function unsubscribe() {
        off(index);
      }
      return Object.freeze({
        unsubscribe
      });
    }
    publicAPI.isDeleted = () => !!model.deleted;
    publicAPI.modified = otherMTime => {
      if (model.deleted) {
        vtkErrorMacro$v('instance deleted - cannot call any method');
        return;
      }
      if (otherMTime && otherMTime < publicAPI.getMTime()) {
        return;
      }
      model.mtime = ++globalMTime;
      callbacks.forEach(callback => callback && callback(publicAPI));
    };
    publicAPI.onModified = callback => {
      if (model.deleted) {
        vtkErrorMacro$v('instance deleted - cannot call any method');
        return null;
      }
      const index = callbacks.length;
      callbacks.push(callback);
      return on(index);
    };
    publicAPI.getMTime = () => model.mtime;
    publicAPI.isA = className => {
      let count = model.classHierarchy.length;
      // we go backwards as that is more likely for
      // early termination
      while (count--) {
        if (model.classHierarchy[count] === className) {
          return true;
        }
      }
      return false;
    };
    publicAPI.getClassName = function () {
      let depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return model.classHierarchy[model.classHierarchy.length - 1 - depth];
    };
    publicAPI.set = function () {
      let map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let noWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      let noFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      let ret = false;
      Object.keys(map).forEach(name => {
        const fn = noFunction ? null : publicAPI[`set${capitalize(name)}`];
        if (fn && Array.isArray(map[name]) && fn.length > 1) {
          ret = fn(...map[name]) || ret;
        } else if (fn) {
          ret = fn(map[name]) || ret;
        } else {
          // Set data on model directly
          if (['mtime'].indexOf(name) === -1 && !noWarning) {
            vtkWarningMacro$7(`Warning: Set value to model directly ${name}, ${map[name]}`);
          }
          ret = model[name] !== map[name] || ret;
          model[name] = map[name];
        }
      });
      return ret;
    };
    publicAPI.get = function () {
      for (var _len3 = arguments.length, list = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        list[_key3] = arguments[_key3];
      }
      if (!list.length) {
        return model;
      }
      const subset = {};
      list.forEach(name => {
        subset[name] = model[name];
      });
      return subset;
    };
    publicAPI.getReferenceByName = val => model[val];
    publicAPI.delete = () => {
      Object.keys(model).forEach(field => delete model[field]);
      callbacks.forEach((el, index) => off(index));

      // Flag the instance being deleted
      model.deleted = true;
    };

    // Add serialization support
    publicAPI.getState = () => {
      if (model.deleted) {
        return null;
      }
      const jsonArchive = {
        ...model,
        vtkClass: publicAPI.getClassName()
      };

      // Convert every vtkObject to its serializable form
      Object.keys(jsonArchive).forEach(keyName => {
        if (jsonArchive[keyName] === null || jsonArchive[keyName] === undefined || keyName[0] === '_' // protected members start with _
        ) {
          delete jsonArchive[keyName];
        } else if (jsonArchive[keyName].isA) {
          jsonArchive[keyName] = jsonArchive[keyName].getState();
        } else if (Array.isArray(jsonArchive[keyName])) {
          jsonArchive[keyName] = jsonArchive[keyName].map(getStateArrayMapFunc);
        } else if (isTypedArray(jsonArchive[keyName])) {
          jsonArchive[keyName] = Array.from(jsonArchive[keyName]);
        }
      });

      // Sort resulting object by key name
      const sortedObj = {};
      Object.keys(jsonArchive).sort().forEach(name => {
        sortedObj[name] = jsonArchive[name];
      });

      // Remove mtime
      if (sortedObj.mtime) {
        delete sortedObj.mtime;
      }
      return sortedObj;
    };

    // Add shallowCopy(otherInstance) support
    publicAPI.shallowCopy = function (other) {
      let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (other.getClassName() !== publicAPI.getClassName()) {
        throw new Error(`Cannot ShallowCopy ${other.getClassName()} into ${publicAPI.getClassName()}`);
      }
      const otherModel = other.get();
      const keyList = Object.keys(model).sort();
      const otherKeyList = Object.keys(otherModel).sort();
      otherKeyList.forEach(key => {
        const keyIdx = keyList.indexOf(key);
        if (keyIdx === -1) {
          if (debug) {
            vtkDebugMacro$9(`add ${key} in shallowCopy`);
          }
        } else {
          keyList.splice(keyIdx, 1);
        }
        model[key] = otherModel[key];
      });
      if (keyList.length && debug) {
        vtkDebugMacro$9(`Untouched keys: ${keyList.join(', ')}`);
      }
      publicAPI.modified();
    };

    // This function will get called when one invoke JSON.stringify(vtkObject)
    // JSON.stringify will only stringify the return value of this function
    publicAPI.toJSON = function vtkObjToJSON() {
      return publicAPI.getState();
    };

    // Allow usage as decorator
    return publicAPI;
  }

  // ----------------------------------------------------------------------------
  // getXXX: add getters
  // ----------------------------------------------------------------------------

  const objectGetterMap = {
    object(publicAPI, model, field) {
      return function getter() {
        return {
          ...model[field.name]
        };
      };
    }
  };
  function get$1(publicAPI, model, fieldNames) {
    fieldNames.forEach(field => {
      if (typeof field === 'object') {
        const getter = objectGetterMap[field.type];
        if (getter) {
          publicAPI[`get${_capitalize(field.name)}`] = getter(publicAPI, model, field);
        } else {
          publicAPI[`get${_capitalize(field.name)}`] = () => model[field.name];
        }
      } else {
        publicAPI[`get${_capitalize(field)}`] = () => model[field];
      }
    });
  }

  // ----------------------------------------------------------------------------
  // setXXX: add setters
  // ----------------------------------------------------------------------------

  const objectSetterMap = {
    enum(publicAPI, model, field) {
      const onChanged = `_on${_capitalize(field.name)}Changed`;
      return value => {
        if (typeof value === 'string') {
          if (field.enum[value] !== undefined) {
            if (model[field.name] !== field.enum[value]) {
              model[field.name] = field.enum[value];
              publicAPI.modified();
              return true;
            }
            return false;
          }
          vtkErrorMacro$v(`Set Enum with invalid argument ${field}, ${value}`);
          throw new RangeError('Set Enum with invalid string argument');
        }
        if (typeof value === 'number') {
          if (model[field.name] !== value) {
            if (Object.keys(field.enum).map(key => field.enum[key]).indexOf(value) !== -1) {
              const previousValue = model[field.name];
              model[field.name] = value;
              model[onChanged]?.(publicAPI, model, value, previousValue);
              publicAPI.modified();
              return true;
            }
            vtkErrorMacro$v(`Set Enum outside numeric range ${field}, ${value}`);
            throw new RangeError('Set Enum outside numeric range');
          }
          return false;
        }
        vtkErrorMacro$v(`Set Enum with invalid argument (String/Number) ${field}, ${value}`);
        throw new TypeError('Set Enum with invalid argument (String/Number)');
      };
    },
    object(publicAPI, model, field) {
      const onChanged = `_on${_capitalize(field.name)}Changed`;
      return value => {
        if (!DeepEqual(model[field.name], value)) {
          const previousValue = model[field.name];
          model[field.name] = value;
          model[onChanged]?.(publicAPI, model, value, previousValue);
          publicAPI.modified();
          return true;
        }
        return false;
      };
    }
  };
  function findSetter(field) {
    if (typeof field === 'object') {
      const fn = objectSetterMap[field.type];
      if (fn) {
        return (publicAPI, model) => fn(publicAPI, model, field);
      }
      vtkErrorMacro$v(`No setter for field ${field}`);
      throw new TypeError('No setter for field');
    }
    return function getSetter(publicAPI, model) {
      const onChanged = `_on${_capitalize(field)}Changed`;
      return function setter(value) {
        if (model.deleted) {
          vtkErrorMacro$v('instance deleted - cannot call any method');
          return false;
        }
        if (model[field] !== value) {
          const previousValue = model[field.name];
          model[field] = value;
          model[onChanged]?.(publicAPI, model, value, previousValue);
          publicAPI.modified();
          return true;
        }
        return false;
      };
    };
  }
  function set(publicAPI, model, fields) {
    fields.forEach(field => {
      if (typeof field === 'object') {
        publicAPI[`set${_capitalize(field.name)}`] = findSetter(field)(publicAPI, model);
      } else {
        publicAPI[`set${_capitalize(field)}`] = findSetter(field)(publicAPI, model);
      }
    });
  }

  // ----------------------------------------------------------------------------
  // set/get XXX: add both setters and getters
  // ----------------------------------------------------------------------------

  function setGet(publicAPI, model, fieldNames) {
    get$1(publicAPI, model, fieldNames);
    set(publicAPI, model, fieldNames);
  }

  // ----------------------------------------------------------------------------
  // getXXX: add getters for object of type array with copy to be safe
  // getXXXByReference: add getters for object of type array without copy
  // ----------------------------------------------------------------------------

  function getArray(publicAPI, model, fieldNames) {
    fieldNames.forEach(field => {
      publicAPI[`get${_capitalize(field)}`] = () => model[field] ? Array.from(model[field]) : model[field];
      publicAPI[`get${_capitalize(field)}ByReference`] = () => model[field];
    });
  }

  // ----------------------------------------------------------------------------
  // setXXX: add setter for object of type array
  // if 'defaultVal' is supplied, shorter arrays will be padded to 'size' with 'defaultVal'
  // set...From: fast path to copy the content of an array to the current one without call to modified.
  // ----------------------------------------------------------------------------

  function setArray(publicAPI, model, fieldNames, size) {
    let defaultVal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
    fieldNames.forEach(field => {
      if (model[field] && size && model[field].length !== size) {
        throw new RangeError(`Invalid initial number of values for array (${field})`);
      }
      const onChanged = `_on${_capitalize(field)}Changed`;
      publicAPI[`set${_capitalize(field)}`] = function () {
        if (model.deleted) {
          vtkErrorMacro$v('instance deleted - cannot call any method');
          return false;
        }
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        let array = args;
        let changeDetected;
        let needCopy = false;
        // allow null or an array to be passed as a single arg.
        if (array.length === 1 && (array[0] == null || array[0].length >= 0)) {
          /* eslint-disable prefer-destructuring */
          array = array[0];
          /* eslint-enable prefer-destructuring */
          needCopy = true;
        }
        if (array == null) {
          changeDetected = model[field] !== array;
        } else {
          if (size && array.length !== size) {
            if (array.length < size && defaultVal !== undefined) {
              array = Array.from(array);
              needCopy = false;
              while (array.length < size) array.push(defaultVal);
            } else {
              throw new RangeError(`Invalid number of values for array setter (${field})`);
            }
          }
          changeDetected = model[field] == null || model[field].length !== array.length;
          for (let i = 0; !changeDetected && i < array.length; ++i) {
            changeDetected = model[field][i] !== array[i];
          }
          if (changeDetected && needCopy) {
            array = Array.from(array);
          }
        }
        if (changeDetected) {
          const previousValue = model[field.name];
          model[field] = array;
          model[onChanged]?.(publicAPI, model, array, previousValue);
          publicAPI.modified();
        }
        return changeDetected;
      };
      publicAPI[`set${_capitalize(field)}From`] = otherArray => {
        const target = model[field];
        otherArray.forEach((v, i) => {
          target[i] = v;
        });
      };
    });
  }

  // ----------------------------------------------------------------------------
  // set/get XXX: add setter and getter for object of type array
  // ----------------------------------------------------------------------------

  function setGetArray(publicAPI, model, fieldNames, size) {
    let defaultVal = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
    getArray(publicAPI, model, fieldNames);
    setArray(publicAPI, model, fieldNames, size, defaultVal);
  }
  function moveToProtected(publicAPI, model, fieldNames) {
    for (let i = 0; i < fieldNames.length; i++) {
      const fieldName = fieldNames[i];
      if (model[fieldName] !== undefined) {
        model[`_${fieldName}`] = model[fieldName];
        delete model[fieldName];
      }
    }
  }
  // ----------------------------------------------------------------------------
  // vtkAlgorithm: setInputData(), setInputConnection(), getOutputData(), getOutputPort()
  // ----------------------------------------------------------------------------

  function algo(publicAPI, model, numberOfInputs, numberOfOutputs) {
    if (model.inputData) {
      model.inputData = model.inputData.map(vtk);
    } else {
      model.inputData = [];
    }
    if (model.inputConnection) {
      model.inputConnection = model.inputConnection.map(vtk);
    } else {
      model.inputConnection = [];
    }
    if (model.output) {
      model.output = model.output.map(vtk);
    } else {
      model.output = [];
    }
    if (model.inputArrayToProcess) {
      model.inputArrayToProcess = model.inputArrayToProcess.map(vtk);
    } else {
      model.inputArrayToProcess = [];
    }

    // Cache the argument for later manipulation
    model.numberOfInputs = numberOfInputs;

    // Methods
    function setInputData(dataset) {
      let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (model.deleted) {
        vtkErrorMacro$v('instance deleted - cannot call any method');
        return;
      }
      if (port >= model.numberOfInputs) {
        vtkErrorMacro$v(`algorithm ${publicAPI.getClassName()} only has ${model.numberOfInputs} input ports. To add more input ports, use addInputData()`);
        return;
      }
      if (model.inputData[port] !== dataset || model.inputConnection[port]) {
        model.inputData[port] = dataset;
        model.inputConnection[port] = null;
        if (publicAPI.modified) {
          publicAPI.modified();
        }
      }
    }
    function getInputData() {
      let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (model.inputConnection[port]) {
        model.inputData[port] = model.inputConnection[port]();
      }
      return model.inputData[port];
    }
    function setInputConnection(outputPort) {
      let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (model.deleted) {
        vtkErrorMacro$v('instance deleted - cannot call any method');
        return;
      }
      if (port >= model.numberOfInputs) {
        let msg = `algorithm ${publicAPI.getClassName()} only has `;
        msg += `${model.numberOfInputs}`;
        msg += ' input ports. To add more input ports, use addInputConnection()';
        vtkErrorMacro$v(msg);
        return;
      }
      model.inputData[port] = null;
      model.inputConnection[port] = outputPort;
    }
    function getInputConnection() {
      let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return model.inputConnection[port];
    }
    function getPortToFill() {
      let portToFill = model.numberOfInputs;
      while (portToFill && !model.inputData[portToFill - 1] && !model.inputConnection[portToFill - 1]) {
        portToFill--;
      }
      if (portToFill === model.numberOfInputs) {
        model.numberOfInputs++;
      }
      return portToFill;
    }
    function addInputConnection(outputPort) {
      if (model.deleted) {
        vtkErrorMacro$v('instance deleted - cannot call any method');
        return;
      }
      setInputConnection(outputPort, getPortToFill());
    }
    function addInputData(dataset) {
      if (model.deleted) {
        vtkErrorMacro$v('instance deleted - cannot call any method');
        return;
      }
      setInputData(dataset, getPortToFill());
    }
    function getOutputData() {
      let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (model.deleted) {
        vtkErrorMacro$v('instance deleted - cannot call any method');
        return null;
      }
      if (publicAPI.shouldUpdate()) {
        publicAPI.update();
      }
      return model.output[port];
    }
    publicAPI.shouldUpdate = () => {
      const localMTime = publicAPI.getMTime();
      let minOutputMTime = Infinity;
      let count = numberOfOutputs;
      while (count--) {
        if (!model.output[count] || model.output[count].isDeleted()) {
          return true;
        }
        const mt = model.output[count].getMTime();
        if (mt < localMTime) {
          return true;
        }
        if (mt < minOutputMTime) {
          minOutputMTime = mt;
        }
      }
      count = model.numberOfInputs;
      while (count--) {
        if (model.inputConnection[count]?.filter.shouldUpdate() || publicAPI.getInputData(count)?.getMTime() > minOutputMTime) {
          return true;
        }
      }
      return false;
    };
    function getOutputPort() {
      let port = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      const outputPortAccess = () => getOutputData(port);
      // Add reference to filter
      outputPortAccess.filter = publicAPI;
      return outputPortAccess;
    }

    // Handle input if needed
    if (model.numberOfInputs) {
      // Reserve inputs
      let count = model.numberOfInputs;
      while (count--) {
        model.inputData.push(null);
        model.inputConnection.push(null);
      }

      // Expose public methods
      publicAPI.setInputData = setInputData;
      publicAPI.setInputConnection = setInputConnection;
      publicAPI.addInputData = addInputData;
      publicAPI.addInputConnection = addInputConnection;
      publicAPI.getInputData = getInputData;
      publicAPI.getInputConnection = getInputConnection;
    }
    if (numberOfOutputs) {
      publicAPI.getOutputData = getOutputData;
      publicAPI.getOutputPort = getOutputPort;
    }
    publicAPI.update = () => {
      const ins = [];
      if (model.numberOfInputs) {
        let count = 0;
        while (count < model.numberOfInputs) {
          ins[count] = publicAPI.getInputData(count);
          count++;
        }
      }
      if (publicAPI.shouldUpdate() && publicAPI.requestData) {
        publicAPI.requestData(ins, model.output);
      }
    };
    publicAPI.getNumberOfInputPorts = () => model.numberOfInputs;
    publicAPI.getNumberOfOutputPorts = () => numberOfOutputs || model.output.length;
    publicAPI.getInputArrayToProcess = inputPort => {
      const arrayDesc = model.inputArrayToProcess[inputPort];
      const ds = model.inputData[inputPort];
      if (arrayDesc && ds) {
        return ds[`get${arrayDesc.fieldAssociation}`]().getArray(arrayDesc.arrayName);
      }
      return null;
    };
    publicAPI.setInputArrayToProcess = function (inputPort, arrayName, fieldAssociation) {
      let attributeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Scalars';
      while (model.inputArrayToProcess.length < inputPort) {
        model.inputArrayToProcess.push(null);
      }
      model.inputArrayToProcess[inputPort] = {
        arrayName,
        fieldAssociation,
        attributeType
      };
    };
  }

  // ----------------------------------------------------------------------------
  // Event handling: onXXX(callback), invokeXXX(args...)
  // ----------------------------------------------------------------------------

  const EVENT_ABORT = Symbol('Event abort');
  function event(publicAPI, model, eventName) {
    const callbacks = [];
    const previousDelete = publicAPI.delete;
    let curCallbackID = 1;
    function off(callbackID) {
      for (let i = 0; i < callbacks.length; ++i) {
        const [cbID] = callbacks[i];
        if (cbID === callbackID) {
          callbacks.splice(i, 1);
          return;
        }
      }
    }
    function on(callbackID) {
      function unsubscribe() {
        off(callbackID);
      }
      return Object.freeze({
        unsubscribe
      });
    }
    function invoke() {
      if (model.deleted) {
        vtkErrorMacro$v('instance deleted - cannot call any method');
        return;
      }
      /* eslint-disable prefer-rest-params */
      // Go through a copy of the callbacks array in case new callbacks
      // get prepended within previous callbacks
      const currentCallbacks = callbacks.slice();
      for (let index = 0; index < currentCallbacks.length; ++index) {
        const [, cb, priority] = currentCallbacks[index];
        if (!cb) {
          continue; // eslint-disable-line
        }

        if (priority < 0) {
          setTimeout(() => cb.apply(publicAPI, arguments), 1 - priority);
        } else {
          // Abort only if the callback explicitly returns false
          const continueNext = cb.apply(publicAPI, arguments);
          if (continueNext === EVENT_ABORT) {
            break;
          }
        }
      }
      /* eslint-enable prefer-rest-params */
    }

    publicAPI[`invoke${_capitalize(eventName)}`] = invoke;
    publicAPI[`on${_capitalize(eventName)}`] = function (callback) {
      let priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;
      if (!callback.apply) {
        console.error(`Invalid callback for event ${eventName}`);
        return null;
      }
      if (model.deleted) {
        vtkErrorMacro$v('instance deleted - cannot call any method');
        return null;
      }
      const callbackID = curCallbackID++;
      callbacks.push([callbackID, callback, priority]);
      callbacks.sort((cb1, cb2) => cb2[2] - cb1[2]);
      return on(callbackID);
    };
    publicAPI.delete = () => {
      previousDelete();
      callbacks.forEach(_ref => {
        let [cbID] = _ref;
        return off(cbID);
      });
    };
  }

  // ----------------------------------------------------------------------------
  // newInstance
  // ----------------------------------------------------------------------------

  function newInstance$1I(extend, className) {
    const constructor = function () {
      let initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const model = {};
      const publicAPI = {};
      extend(publicAPI, model, initialValues);
      return Object.freeze(publicAPI);
    };

    // Register constructor to factory
    if (className) {
      vtk.register(className, constructor);
    }
    return constructor;
  }

  // ----------------------------------------------------------------------------
  // Chain function calls
  // ----------------------------------------------------------------------------

  function chain() {
    for (var _len5 = arguments.length, fn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      fn[_key5] = arguments[_key5];
    }
    return function () {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return fn.filter(i => !!i).map(i => i(...args));
    };
  }

  // ----------------------------------------------------------------------------
  // Some utility methods for vtk objects
  // ----------------------------------------------------------------------------

  function isVtkObject(instance) {
    return instance && instance.isA && instance.isA('vtkObject');
  }
  function traverseInstanceTree(instance, extractFunction) {
    let accumulator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    let visitedInstances = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    if (isVtkObject(instance)) {
      if (visitedInstances.indexOf(instance) >= 0) {
        // avoid cycles
        return accumulator;
      }
      visitedInstances.push(instance);
      const result = extractFunction(instance);
      if (result !== undefined) {
        accumulator.push(result);
      }

      // Now go through this instance's model
      const model = instance.get();
      Object.keys(model).forEach(key => {
        const modelObj = model[key];
        if (Array.isArray(modelObj)) {
          modelObj.forEach(subObj => {
            traverseInstanceTree(subObj, extractFunction, accumulator, visitedInstances);
          });
        } else {
          traverseInstanceTree(modelObj, extractFunction, accumulator, visitedInstances);
        }
      });
    }
    return accumulator;
  }

  // ----------------------------------------------------------------------------
  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.

  function debounce(func, wait, immediate) {
    var _this = this;
    let timeout;
    const debounced = function () {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      const context = _this;
      const later = () => {
        timeout = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      const callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
    debounced.cancel = () => clearTimeout(timeout);
    return debounced;
  }

  // ----------------------------------------------------------------------------
  // Creates a throttled function that only invokes `func` at most once per
  // every `wait` milliseconds.

  function throttle(callback, delay) {
    let isThrottled = false;
    let argsToUse = null;
    function next() {
      isThrottled = false;
      if (argsToUse !== null) {
        wrapper(...argsToUse); // eslint-disable-line
        argsToUse = null;
      }
    }
    function wrapper() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      if (isThrottled) {
        argsToUse = args;
        return;
      }
      isThrottled = true;
      callback(...args);
      setTimeout(next, delay);
    }
    return wrapper;
  }

  // ----------------------------------------------------------------------------
  // keystore(publicAPI, model, initialKeystore)
  //
  //    - initialKeystore: Initial keystore. This can be either a Map or an
  //      object.
  //
  // Generated API
  //  setKey(key, value) : mixed (returns value)
  //  getKey(key) : mixed
  //  getAllKeys() : [mixed]
  //  deleteKey(key) : Boolean
  // ----------------------------------------------------------------------------

  function keystore(publicAPI, model) {
    let initialKeystore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    model.keystore = Object.assign(model.keystore || {}, initialKeystore);
    publicAPI.setKey = (key, value) => {
      model.keystore[key] = value;
    };
    publicAPI.getKey = key => model.keystore[key];
    publicAPI.getAllKeys = () => Object.keys(model.keystore);
    publicAPI.deleteKey = key => delete model.keystore[key];
    publicAPI.clearKeystore = () => publicAPI.getAllKeys().forEach(key => delete model.keystore[key]);
  }

  // ----------------------------------------------------------------------------
  // proxy(publicAPI, model, sectionName, propertyUI)
  //
  //    - sectionName: Name of the section for UI
  //    - propertyUI: List of props with their UI description
  //
  // Generated API
  //  getProxyId() : String
  //  listProxyProperties() : [string]
  //  updateProxyProperty(name, prop)
  //  getProxySection() => List of properties for UI generation
  // ----------------------------------------------------------------------------
  let nextProxyId = 1;
  const ROOT_GROUP_NAME = '__root__';
  function proxy(publicAPI, model) {
    // Proxies are keystores
    keystore(publicAPI, model);
    const parentDelete = publicAPI.delete;

    // getProxyId
    model.proxyId = `${nextProxyId++}`;

    // ui handling
    model.ui = JSON.parse(JSON.stringify(model.ui || [])); // deep copy
    get$1(publicAPI, model, ['proxyId', 'proxyGroup', 'proxyName']);
    setGet(publicAPI, model, ['proxyManager']);

    // group properties
    const propertyMap = {};
    const groupChildrenNames = {};
    function registerProperties(descriptionList, currentGroupName) {
      if (!groupChildrenNames[currentGroupName]) {
        groupChildrenNames[currentGroupName] = [];
      }
      const childrenNames = groupChildrenNames[currentGroupName];
      for (let i = 0; i < descriptionList.length; i++) {
        childrenNames.push(descriptionList[i].name);
        propertyMap[descriptionList[i].name] = descriptionList[i];
        if (descriptionList[i].children && descriptionList[i].children.length) {
          registerProperties(descriptionList[i].children, descriptionList[i].name);
        }
      }
    }
    registerProperties(model.ui, ROOT_GROUP_NAME);
    publicAPI.updateUI = ui => {
      model.ui = JSON.parse(JSON.stringify(ui || [])); // deep copy
      Object.keys(propertyMap).forEach(k => delete propertyMap[k]);
      Object.keys(groupChildrenNames).forEach(k => delete groupChildrenNames[k]);
      registerProperties(model.ui, ROOT_GROUP_NAME);
      publicAPI.modified();
    };
    function listProxyProperties() {
      let gName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_GROUP_NAME;
      return groupChildrenNames[gName];
    }
    publicAPI.updateProxyProperty = (propertyName, propUI) => {
      const prop = propertyMap[propertyName];
      if (prop) {
        Object.assign(prop, propUI);
      } else {
        propertyMap[propertyName] = {
          ...propUI
        };
      }
    };
    publicAPI.activate = () => {
      if (model.proxyManager) {
        const setActiveMethod = `setActive${_capitalize(publicAPI.getProxyGroup().slice(0, -1))}`;
        if (model.proxyManager[setActiveMethod]) {
          model.proxyManager[setActiveMethod](publicAPI);
        }
      }
    };

    // property link
    model.propertyLinkSubscribers = {};
    publicAPI.registerPropertyLinkForGC = (otherLink, type) => {
      if (!(type in model.propertyLinkSubscribers)) {
        model.propertyLinkSubscribers[type] = [];
      }
      model.propertyLinkSubscribers[type].push(otherLink);
    };
    publicAPI.gcPropertyLinks = type => {
      const subscribers = model.propertyLinkSubscribers[type] || [];
      while (subscribers.length) {
        subscribers.pop().unbind(publicAPI);
      }
    };
    model.propertyLinkMap = {};
    publicAPI.getPropertyLink = function (id) {
      let persistent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (model.propertyLinkMap[id]) {
        return model.propertyLinkMap[id];
      }
      let value = null;
      const links = [];
      let count = 0;
      let updateInProgress = false;
      function update(source) {
        let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (updateInProgress) {
          return null;
        }
        const needUpdate = [];
        let sourceLink = null;
        count = links.length;
        while (count--) {
          const link = links[count];
          if (link.instance === source) {
            sourceLink = link;
          } else {
            needUpdate.push(link);
          }
        }
        if (!sourceLink) {
          return null;
        }
        const newValue = sourceLink.instance[`get${_capitalize(sourceLink.propertyName)}`]();
        if (!shallowEquals(newValue, value) || force) {
          value = newValue;
          updateInProgress = true;
          while (needUpdate.length) {
            const linkToUpdate = needUpdate.pop();
            linkToUpdate.instance.set({
              [linkToUpdate.propertyName]: value
            });
          }
          updateInProgress = false;
        }
        if (model.propertyLinkMap[id].persistent) {
          model.propertyLinkMap[id].value = newValue;
        }
        return newValue;
      }
      function unbind(instance, propertyName) {
        const indexToDelete = [];
        count = links.length;
        while (count--) {
          const link = links[count];
          if (link.instance === instance && (link.propertyName === propertyName || propertyName === undefined)) {
            link.subscription.unsubscribe();
            indexToDelete.push(count);
          }
        }
        while (indexToDelete.length) {
          links.splice(indexToDelete.pop(), 1);
        }
      }
      function bind(instance, propertyName) {
        let updateMe = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        const subscription = instance.onModified(update);
        const other = links[0];
        links.push({
          instance,
          propertyName,
          subscription
        });
        if (updateMe) {
          if (model.propertyLinkMap[id].persistent && model.propertyLinkMap[id].value !== undefined) {
            instance.set({
              [propertyName]: model.propertyLinkMap[id].value
            });
          } else if (other) {
            update(other.instance, true);
          }
        }
        return {
          unsubscribe: () => unbind(instance, propertyName)
        };
      }
      function unsubscribe() {
        while (links.length) {
          links.pop().subscription.unsubscribe();
        }
      }
      const linkHandler = {
        bind,
        unbind,
        unsubscribe,
        persistent
      };
      model.propertyLinkMap[id] = linkHandler;
      return linkHandler;
    };

    // extract values
    function getProperties() {
      let groupName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_GROUP_NAME;
      const values = [];
      const id = model.proxyId;
      const propertyNames = listProxyProperties(groupName) || [];
      for (let i = 0; i < propertyNames.length; i++) {
        const name = propertyNames[i];
        const method = publicAPI[`get${_capitalize(name)}`];
        const value = method ? method() : undefined;
        const prop = {
          id,
          name,
          value
        };
        const children = getProperties(name);
        if (children.length) {
          prop.children = children;
        }
        values.push(prop);
      }
      return values;
    }
    publicAPI.listPropertyNames = () => getProperties().map(p => p.name);
    publicAPI.getPropertyByName = name => getProperties().find(p => p.name === name);
    publicAPI.getPropertyDomainByName = name => (propertyMap[name] || {}).domain;

    // ui section
    publicAPI.getProxySection = () => ({
      id: model.proxyId,
      name: model.proxyGroup,
      ui: model.ui,
      properties: getProperties()
    });

    // free resources
    publicAPI.delete = () => {
      const list = Object.keys(model.propertyLinkMap);
      let count = list.length;
      while (count--) {
        model.propertyLinkMap[list[count]].unsubscribe();
      }
      Object.keys(model.propertyLinkSubscribers).forEach(publicAPI.gcPropertyLinks);
      parentDelete();
    };

    // @todo fix infinite recursion due to active source
    publicAPI.getState = () => null;
    function registerLinks() {
      // Allow dynamic registration of links at the application level
      if (model.links) {
        for (let i = 0; i < model.links.length; i++) {
          const {
            link,
            property,
            persistent,
            updateOnBind,
            type
          } = model.links[i];
          if (type === 'application') {
            const sLink = model.proxyManager.getPropertyLink(link, persistent);
            publicAPI.registerPropertyLinkForGC(sLink, 'application');
            sLink.bind(publicAPI, property, updateOnBind);
          }
        }
      }
    }
    setImmediateVTK(registerLinks);
  }

  // ----------------------------------------------------------------------------
  // proxyPropertyMapping(publicAPI, model, map)
  //
  //   map = {
  //      opacity: { modelKey: 'property', property: 'opacity' },
  //   }
  //
  // Generated API:
  //  Elevate set/get methods from internal object stored in the model to current one
  // ----------------------------------------------------------------------------

  function proxyPropertyMapping(publicAPI, model, map) {
    const parentDelete = publicAPI.delete;
    const subscriptions = [];
    const propertyNames = Object.keys(map);
    let count = propertyNames.length;
    while (count--) {
      const propertyName = propertyNames[count];
      const {
        modelKey,
        property,
        modified = true
      } = map[propertyName];
      const methodSrc = _capitalize(property);
      const methodDst = _capitalize(propertyName);
      publicAPI[`get${methodDst}`] = model[modelKey][`get${methodSrc}`];
      publicAPI[`set${methodDst}`] = model[modelKey][`set${methodSrc}`];
      if (modified) {
        subscriptions.push(model[modelKey].onModified(publicAPI.modified));
      }
    }
    publicAPI.delete = () => {
      while (subscriptions.length) {
        subscriptions.pop().unsubscribe();
      }
      parentDelete();
    };
  }

  // ----------------------------------------------------------------------------
  // proxyPropertyState(publicAPI, model, state, defaults)
  //
  //   state = {
  //     representation: {
  //       'Surface with edges': { property: { edgeVisibility: true, representation: 2 } },
  //       Surface: { property: { edgeVisibility: false, representation: 2 } },
  //       Wireframe: { property: { edgeVisibility: false, representation: 1 } },
  //       Points: { property: { edgeVisibility: false, representation: 0 } },
  //     },
  //   }
  //
  //   defaults = {
  //      representation: 'Surface',
  //   }
  //
  // Generated API
  //   get / set Representation ( string ) => push state to various internal objects
  // ----------------------------------------------------------------------------

  function proxyPropertyState(publicAPI, model) {
    let state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    let defaults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    model.this = publicAPI;
    function applyState(map) {
      const modelKeys = Object.keys(map);
      let count = modelKeys.length;
      while (count--) {
        const modelKey = modelKeys[count];
        model[modelKey].set(map[modelKey]);
      }
    }
    const modelKeys = Object.keys(defaults);
    let count = modelKeys.length;
    while (count--) {
      // Add default
      const key = modelKeys[count];
      model[key] = defaults[key];

      // Add set method
      const mapping = state[key];
      publicAPI[`set${_capitalize(key)}`] = value => {
        if (value !== model[key]) {
          model[key] = value;
          const propValues = mapping[value];
          applyState(propValues);
          publicAPI.modified();
        }
      };
    }

    // Add getter
    if (modelKeys.length) {
      get$1(publicAPI, model, modelKeys);
    }
  }

  // ----------------------------------------------------------------------------
  // From : https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
  //
  //
  // Copyright (c) 2015, Facebook, Inc.
  // All rights reserved.
  //
  // This source code is licensed under the BSD-style license found in the
  // LICENSE file in the root directory of this source tree. An additional grant
  // of patent rights can be found in the PATENTS file in the same directory.
  //
  //
  // Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
  // complicated, thus this doc is long and (hopefully) detailed enough to answer
  // your questions.
  //
  // If you need to react to the mouse wheel in a predictable way, this code is
  // like your bestest friend.// hugs//
  //
  // As of today, there are 4 DOM event types you can listen to:
  //
  //   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
  //   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
  //   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
  //   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
  //
  // So what to do?  The is the best:
  //
  //   normalizeWheel.getEventType();
  //
  // In your event callback, use this code to get sane interpretation of the
  // deltas.  This code will return an object with properties:
  //
  //   spinX   -- normalized spin speed (use for zoom) - x plane
  //   spinY   -- " - y plane
  //   pixelX  -- normalized distance (to pixels) - x plane
  //   pixelY  -- " - y plane
  //
  // Wheel values are provided by the browser assuming you are using the wheel to
  // scroll a web page by a number of lines or pixels (or pages).  Values can vary
  // significantly on different platforms and browsers, forgetting that you can
  // scroll at different speeds.  Some devices (like trackpads) emit more events
  // at smaller increments with fine granularity, and some emit massive jumps with
  // linear speed or acceleration.
  //
  // This code does its best to normalize the deltas for you:
  //
  //   - spin is trying to normalize how far the wheel was spun (or trackpad
  //     dragged).  This is super useful for zoom support where you want to
  //     throw away the chunky scroll steps on the PC and make those equal to
  //     the slow and smooth tiny steps on the Mac. Key data: This code tries to
  //     resolve a single slow step on a wheel to 1.
  //
  //   - pixel is normalizing the desired scroll delta in pixel units.  You'll
  //     get the crazy differences between browsers, but at least it'll be in
  //     pixels!
  //
  //   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
  //     should translate to positive value zooming IN, negative zooming OUT.
  //     This matches the newer 'wheel' event.
  //
  // Why are there spinX, spinY (or pixels)?
  //
  //   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
  //     with a mouse.  It results in side-scrolling in the browser by default.
  //
  //   - spinY is what you expect -- it's the classic axis of a mouse wheel.
  //
  //   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
  //     probably is by browsers in conjunction with fancy 3D controllers .. but
  //     you know.
  //
  // Implementation info:
  //
  // Examples of 'wheel' event if you scroll slowly (down) by one step with an
  // average mouse:
  //
  //   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
  //   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
  //   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
  //   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
  //   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
  //
  // On the trackpad:
  //
  //   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
  //   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
  //
  // On other/older browsers.. it's more complicated as there can be multiple and
  // also missing delta values.
  //
  // The 'wheel' event is more standard:
  //
  // http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
  //
  // The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
  // deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
  // backward compatibility with older events.  Those other values help us
  // better normalize spin speed.  Example of what the browsers provide:
  //
  //                          | event.wheelDelta | event.detail
  //        ------------------+------------------+--------------
  //          Safari v5/OS X  |       -120       |       0
  //          Safari v5/Win7  |       -120       |       0
  //         Chrome v17/OS X  |       -120       |       0
  //         Chrome v17/Win7  |       -120       |       0
  //                IE9/Win7  |       -120       |   undefined
  //         Firefox v4/OS X  |     undefined    |       1
  //         Firefox v4/Win7  |     undefined    |       3
  //
  // ----------------------------------------------------------------------------

  // Reasonable defaults
  const PIXEL_STEP = 10;
  const LINE_HEIGHT = 40;
  const PAGE_HEIGHT = 800;
  function normalizeWheel$1(wheelEvent) {
    let sX = 0; // spinX
    let sY = 0; // spinY
    let pX = 0; // pixelX
    let pY = 0; // pixelY

    // Legacy
    if ('detail' in wheelEvent) {
      sY = wheelEvent.detail;
    }
    if ('wheelDelta' in wheelEvent) {
      sY = -wheelEvent.wheelDelta / 120;
    }
    if ('wheelDeltaY' in wheelEvent) {
      sY = -wheelEvent.wheelDeltaY / 120;
    }
    if ('wheelDeltaX' in wheelEvent) {
      sX = -wheelEvent.wheelDeltaX / 120;
    }

    // side scrolling on FF with DOMMouseScroll
    if ('axis' in wheelEvent && wheelEvent.axis === wheelEvent.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }
    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;
    if ('deltaY' in wheelEvent) {
      pY = wheelEvent.deltaY;
    }
    if ('deltaX' in wheelEvent) {
      pX = wheelEvent.deltaX;
    }
    if ((pX || pY) && wheelEvent.deltaMode) {
      if (wheelEvent.deltaMode === 1) {
        // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }

    // Fall-back if spin cannot be determined
    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }
    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }
    return {
      spinX: sX,
      spinY: sY || sX,
      pixelX: pX,
      pixelY: pY || pX
    };
  }

  // ----------------------------------------------------------------------------
  // Default export
  // ----------------------------------------------------------------------------

  var macro = {
    algo,
    capitalize,
    chain,
    debounce,
    enumToString,
    event,
    EVENT_ABORT,
    formatBytesToProperUnit,
    formatNumbersWithThousandSeparator,
    get: get$1,
    getArray,
    getCurrentGlobalMTime,
    getStateArrayMapFunc,
    isVtkObject,
    keystore,
    measurePromiseExecution,
    moveToProtected,
    newInstance: newInstance$1I,
    newTypedArray,
    newTypedArrayFrom,
    normalizeWheel: normalizeWheel$1,
    obj,
    proxy,
    proxyPropertyMapping,
    proxyPropertyState,
    safeArrays,
    set,
    setArray,
    setGet,
    setGetArray,
    setImmediate: setImmediateVTK,
    setLoggerFunction,
    throttle,
    traverseInstanceTree,
    TYPED_ARRAYS,
    // deprecated todo remove on breaking API revision
    uncapitalize,
    VOID: VOID$1,
    vtkDebugMacro: vtkDebugMacro$9,
    vtkErrorMacro: vtkErrorMacro$v,
    vtkInfoMacro,
    vtkLogMacro,
    vtkOnceErrorMacro: vtkOnceErrorMacro$1,
    vtkWarningMacro: vtkWarningMacro$7
  };

  var macro$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    VOID: VOID$1,
    setLoggerFunction: setLoggerFunction,
    vtkLogMacro: vtkLogMacro,
    vtkInfoMacro: vtkInfoMacro,
    vtkDebugMacro: vtkDebugMacro$9,
    vtkErrorMacro: vtkErrorMacro$v,
    vtkWarningMacro: vtkWarningMacro$7,
    vtkOnceErrorMacro: vtkOnceErrorMacro$1,
    TYPED_ARRAYS: TYPED_ARRAYS,
    newTypedArray: newTypedArray,
    newTypedArrayFrom: newTypedArrayFrom,
    capitalize: capitalize,
    _capitalize: _capitalize,
    uncapitalize: uncapitalize,
    formatBytesToProperUnit: formatBytesToProperUnit,
    formatNumbersWithThousandSeparator: formatNumbersWithThousandSeparator,
    setImmediateVTK: setImmediateVTK,
    measurePromiseExecution: measurePromiseExecution,
    obj: obj,
    get: get$1,
    set: set,
    setGet: setGet,
    getArray: getArray,
    setArray: setArray,
    setGetArray: setGetArray,
    moveToProtected: moveToProtected,
    algo: algo,
    EVENT_ABORT: EVENT_ABORT,
    event: event,
    newInstance: newInstance$1I,
    chain: chain,
    isVtkObject: isVtkObject,
    traverseInstanceTree: traverseInstanceTree,
    debounce: debounce,
    throttle: throttle,
    keystore: keystore,
    proxy: proxy,
    proxyPropertyMapping: proxyPropertyMapping,
    proxyPropertyState: proxyPropertyState,
    normalizeWheel: normalizeWheel$1,
    'default': macro
  });

  const {
    vtkErrorMacro: vtkErrorMacro$u
  } = macro;
  const PASS_TYPES = ['Build', 'Render'];

  // ----------------------------------------------------------------------------
  // vtkViewNode methods
  // ----------------------------------------------------------------------------

  function vtkViewNode(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkViewNode');

    // Builds myself.
    publicAPI.build = prepass => {};

    // Renders myself
    publicAPI.render = prepass => {};
    publicAPI.traverse = renderPass => {
      // we can choose to do special
      // traversal here based on pass
      const passTraversal = renderPass.getTraverseOperation();
      const fn = publicAPI[passTraversal];
      if (fn) {
        fn(renderPass);
        return;
      }

      // default traversal
      publicAPI.apply(renderPass, true);
      for (let index = 0; index < model.children.length; index++) {
        model.children[index].traverse(renderPass);
      }
      publicAPI.apply(renderPass, false);
    };
    publicAPI.apply = (renderPass, prepass) => {
      const customRenderPass = publicAPI[renderPass.getOperation()];
      if (customRenderPass) {
        customRenderPass(prepass, renderPass);
      }
    };
    publicAPI.getViewNodeFor = dataObject => {
      if (model.renderable === dataObject) {
        return publicAPI;
      }
      for (let index = 0; index < model.children.length; ++index) {
        const child = model.children[index];
        const vn = child.getViewNodeFor(dataObject);
        if (vn) {
          return vn;
        }
      }
      return undefined;
    };
    publicAPI.getFirstAncestorOfType = type => {
      if (!model._parent) {
        return null;
      }
      if (model._parent.isA(type)) {
        return model._parent;
      }
      return model._parent.getFirstAncestorOfType(type);
    };

    // add a missing node/child for the passed in renderables. This should
    // be called only in between prepareNodes and removeUnusedNodes
    publicAPI.addMissingNode = dobj => {
      if (!dobj) {
        return;
      }
      const result = model._renderableChildMap.get(dobj);
      // if found just mark as visited
      if (result !== undefined) {
        result.setVisited(true);
      } else {
        // otherwise create a node
        const newNode = publicAPI.createViewNode(dobj);
        if (newNode) {
          newNode.setParent(publicAPI);
          newNode.setVisited(true);
          model._renderableChildMap.set(dobj, newNode);
          model.children.push(newNode);
        }
      }
    };

    // add missing nodes/children for the passed in renderables. This should
    // be called only in between prepareNodes and removeUnusedNodes
    publicAPI.addMissingNodes = dataObjs => {
      if (!dataObjs || !dataObjs.length) {
        return;
      }
      for (let index = 0; index < dataObjs.length; ++index) {
        const dobj = dataObjs[index];
        const result = model._renderableChildMap.get(dobj);
        // if found just mark as visited
        if (result !== undefined) {
          result.setVisited(true);
        } else {
          // otherwise create a node
          const newNode = publicAPI.createViewNode(dobj);
          if (newNode) {
            newNode.setParent(publicAPI);
            newNode.setVisited(true);
            model._renderableChildMap.set(dobj, newNode);
            model.children.push(newNode);
          }
        }
      }
    };

    // ability to add children that have no renderable use in the same manner
    // as addMissingNodes This case is when a normal viewnode wants to
    // delegate passes to a helper or child that doeasn't map to a clear
    // renderable or any renderable
    publicAPI.addMissingChildren = children => {
      if (!children || !children.length) {
        return;
      }
      for (let index = 0; index < children.length; ++index) {
        const child = children[index];
        const cindex = model.children.indexOf(child);
        if (cindex === -1) {
          child.setParent(publicAPI);
          model.children.push(child);
        }
        child.setVisited(true);
      }
    };
    publicAPI.prepareNodes = () => {
      for (let index = 0; index < model.children.length; ++index) {
        model.children[index].setVisited(false);
      }
    };
    publicAPI.setVisited = val => {
      model.visited = val;
    };
    publicAPI.removeUnusedNodes = () => {
      let visitedCount = 0;
      for (let index = 0; index < model.children.length; ++index) {
        const child = model.children[index];
        const visited = child.getVisited();
        if (visited) {
          model.children[visitedCount++] = child;
          child.setVisited(false);
        } else {
          const renderable = child.getRenderable();
          if (renderable) {
            model._renderableChildMap.delete(renderable);
          }
          child.delete();
        }
      }
      model.children.length = visitedCount;
    };
    publicAPI.createViewNode = dataObj => {
      if (!model.myFactory) {
        vtkErrorMacro$u('Cannot create view nodes without my own factory');
        return null;
      }
      const ret = model.myFactory.createNode(dataObj);
      if (ret) {
        ret.setRenderable(dataObj);
      }
      return ret;
    };
    const parentDelete = publicAPI.delete;
    publicAPI.delete = () => {
      for (let i = 0; i < model.children.length; i++) {
        model.children[i].delete();
      }
      parentDelete();
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1D = {
    // _parent: null,
    renderable: null,
    myFactory: null,
    children: [],
    visited: false
  };

  // ----------------------------------------------------------------------------

  function extend$1J(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1D, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.event(publicAPI, model, 'event');
    model._renderableChildMap = new Map();
    macro.get(publicAPI, model, ['visited']);
    macro.setGet(publicAPI, model, ['_parent', 'renderable', 'myFactory']);
    macro.getArray(publicAPI, model, ['children']);
    macro.moveToProtected(publicAPI, model, ['parent']);

    // Object methods
    vtkViewNode(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1H = macro.newInstance(extend$1J, 'vtkViewNode');

  // ----------------------------------------------------------------------------

  var vtkViewNode$1 = {
    newInstance: newInstance$1H,
    extend: extend$1J,
    PASS_TYPES
  };

  // ----------------------------------------------------------------------------
  // vtkViewNodeFactory methods
  // ----------------------------------------------------------------------------

  function vtkViewNodeFactory$1(publicAPI, model) {
    // Make sure our overrides is just for our instance not shared with everyone...
    if (!model.overrides) {
      model.overrides = {};
    }

    // Set our className
    model.classHierarchy.push('vtkViewNodeFactory');
    publicAPI.createNode = dataObject => {
      if (dataObject.isDeleted()) {
        return null;
      }
      let cpt = 0;
      let className = dataObject.getClassName(cpt++);
      let isObject = false;
      const keys = Object.keys(model.overrides);
      while (className && !isObject) {
        if (keys.indexOf(className) !== -1) {
          isObject = true;
        } else {
          className = dataObject.getClassName(cpt++);
        }
      }
      if (!isObject) {
        return null;
      }
      const vn = model.overrides[className]();
      vn.setMyFactory(publicAPI);
      return vn;
    };
    publicAPI.registerOverride = (className, func) => {
      model.overrides[className] = func;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1C = {
    // overrides: {},
  };

  // ----------------------------------------------------------------------------

  function extend$1I(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1C, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);

    // Object methods
    vtkViewNodeFactory$1(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1G = macro.newInstance(extend$1I, 'vtkViewNodeFactory');

  // ----------------------------------------------------------------------------

  var vtkViewNodeFactory$1$1 = {
    newInstance: newInstance$1G,
    extend: extend$1I
  };

  const CLASS_MAPPING$1 = Object.create(null);
  function registerOverride$1(className, fn) {
    CLASS_MAPPING$1[className] = fn;
  }

  // ----------------------------------------------------------------------------
  // vtkOpenGLViewNodeFactory methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLViewNodeFactory(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLViewNodeFactory');
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1B = {};

  // ----------------------------------------------------------------------------

  function extend$1H(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1B, initialValues);

    // Static class mapping shared across instances
    model.overrides = CLASS_MAPPING$1;

    // Inheritance
    vtkViewNodeFactory$1$1.extend(publicAPI, model, initialValues);

    // Object methods
    vtkOpenGLViewNodeFactory(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1F = macro.newInstance(extend$1H, 'vtkOpenGLViewNodeFactory');

  // ----------------------------------------------------------------------------

  var vtkViewNodeFactory = {
    newInstance: newInstance$1F,
    extend: extend$1H
  };

  // ----------------------------------------------------------------------------
  // vtkOpenGLCamera methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLCamera(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLCamera');
    publicAPI.buildPass = prepass => {
      if (prepass) {
        model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
        model._openGLRenderWindow = model._openGLRenderer.getParent();
        model.context = model._openGLRenderWindow.getContext();
      }
    };

    // Renders myself
    publicAPI.opaquePass = prepass => {
      if (prepass) {
        const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
        model.context.viewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
        model.context.scissor(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
      }
    };
    publicAPI.translucentPass = publicAPI.opaquePass;
    publicAPI.zBufferPass = publicAPI.opaquePass;
    publicAPI.opaqueZBufferPass = publicAPI.opaquePass;
    publicAPI.volumePass = publicAPI.opaquePass;
    publicAPI.getKeyMatrices = ren => {
      // has the camera changed?
      if (ren !== model.lastRenderer || model._openGLRenderWindow.getMTime() > model.keyMatrixTime.getMTime() || publicAPI.getMTime() > model.keyMatrixTime.getMTime() || ren.getMTime() > model.keyMatrixTime.getMTime() || model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
        copy$1(model.keyMatrices.wcvc, model.renderable.getViewMatrix());
        fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.wcvc);
        invert$1(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        transpose(model.keyMatrices.wcvc, model.keyMatrices.wcvc);
        const aspectRatio = model._openGLRenderer.getAspectRatio();
        copy$1(model.keyMatrices.vcpc, model.renderable.getProjectionMatrix(aspectRatio, -1, 1));
        transpose(model.keyMatrices.vcpc, model.keyMatrices.vcpc);
        multiply$1(model.keyMatrices.wcpc, model.keyMatrices.vcpc, model.keyMatrices.wcvc);
        model.keyMatrixTime.modified();
        model.lastRenderer = ren;
      }
      return model.keyMatrices;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1A = {
    context: null,
    lastRenderer: null,
    keyMatrixTime: null,
    keyMatrices: null
  };

  // ----------------------------------------------------------------------------

  function extend$1G(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1A, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.keyMatrixTime = {};
    obj(model.keyMatrixTime);

    // values always get set by the get method
    model.keyMatrices = {
      normalMatrix: new Float64Array(9),
      vcpc: new Float64Array(16),
      wcvc: new Float64Array(16),
      wcpc: new Float64Array(16)
    };

    // Build VTK API
    setGet(publicAPI, model, ['context', 'keyMatrixTime']);

    // Object methods
    vtkOpenGLCamera(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1E = newInstance$1I(extend$1G);

  // Register ourself to OpenGL backend if imported
  registerOverride$1('vtkCamera', newInstance$1E);

  const {
    vtkDebugMacro: vtkDebugMacro$8
  } = macro$1;

  // ----------------------------------------------------------------------------
  // vtkOpenGLRenderer methods
  // ----------------------------------------------------------------------------
  /* eslint-disable no-bitwise */

  function vtkOpenGLRenderer(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLRenderer');

    // Builds myself.
    publicAPI.buildPass = prepass => {
      if (prepass) {
        if (!model.renderable) {
          return;
        }
        publicAPI.updateLights();
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.renderable.getActiveCamera());
        publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
        publicAPI.removeUnusedNodes();
      }
    };
    publicAPI.updateLights = () => {
      let count = 0;
      const lights = model.renderable.getLightsByReference();
      for (let index = 0; index < lights.length; ++index) {
        if (lights[index].getSwitch() > 0.0) {
          count++;
        }
      }
      if (!count) {
        vtkDebugMacro$8('No lights are on, creating one.');
        model.renderable.createLight();
      }
      return count;
    };
    publicAPI.zBufferPass = prepass => {
      if (prepass) {
        let clearMask = 0;
        const gl = model.context;
        if (!model.renderable.getTransparent()) {
          model.context.clearColor(1.0, 0.0, 0.0, 1.0);
          clearMask |= gl.COLOR_BUFFER_BIT;
        }
        if (!model.renderable.getPreserveDepthBuffer()) {
          gl.clearDepth(1.0);
          clearMask |= gl.DEPTH_BUFFER_BIT;
          model.context.depthMask(true);
        }
        const ts = publicAPI.getTiledSizeAndOrigin();
        gl.enable(gl.SCISSOR_TEST);
        gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
        gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
        gl.colorMask(true, true, true, true);
        if (clearMask) {
          gl.clear(clearMask);
        }
        gl.enable(gl.DEPTH_TEST);
      }
    };
    publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);

    // Renders myself
    publicAPI.cameraPass = prepass => {
      if (prepass) {
        publicAPI.clear();
      }
    };
    publicAPI.getAspectRatio = () => {
      const size = model._parent.getSizeByReference();
      const viewport = model.renderable.getViewportByReference();
      return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
    };
    publicAPI.getTiledSizeAndOrigin = () => {
      const vport = model.renderable.getViewportByReference();

      // if there is no window assume 0 1
      const tileViewPort = [0.0, 0.0, 1.0, 1.0];

      // find the lower left corner of the viewport, taking into account the
      // lower left boundary of this tile
      const vpu = vport[0] - tileViewPort[0];
      const vpv = vport[1] - tileViewPort[1];

      // store the result as a pixel value
      const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
      const lowerLeftU = Math.round(ndvp[0]);
      const lowerLeftV = Math.round(ndvp[1]);

      // find the upper right corner of the viewport, taking into account the
      // lower left boundary of this tile
      const vpu2 = vport[2] - tileViewPort[0];
      const vpv2 = vport[3] - tileViewPort[1];
      const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);

      // now compute the size of the intersection of the viewport with the
      // current tile
      let usize = Math.round(ndvp2[0]) - lowerLeftU;
      let vsize = Math.round(ndvp2[1]) - lowerLeftV;
      if (usize < 0) {
        usize = 0;
      }
      if (vsize < 0) {
        vsize = 0;
      }
      return {
        usize,
        vsize,
        lowerLeftU,
        lowerLeftV
      };
    };
    publicAPI.clear = () => {
      let clearMask = 0;
      const gl = model.context;
      if (!model.renderable.getTransparent()) {
        const background = model.renderable.getBackgroundByReference();
        // renderable ensures that background has 4 entries.
        model.context.clearColor(background[0], background[1], background[2], background[3]);
        clearMask |= gl.COLOR_BUFFER_BIT;
      }
      if (!model.renderable.getPreserveDepthBuffer()) {
        gl.clearDepth(1.0);
        clearMask |= gl.DEPTH_BUFFER_BIT;
        model.context.depthMask(true);
      }
      gl.colorMask(true, true, true, true);
      const ts = publicAPI.getTiledSizeAndOrigin();
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      if (clearMask) {
        gl.clear(clearMask);
      }
      gl.enable(gl.DEPTH_TEST);
      /* eslint-enable no-bitwise */
    };

    publicAPI.releaseGraphicsResources = () => {
      if (model.selector !== null) {
        model.selector.releaseGraphicsResources();
      }
      // Releasing resources means that the next render should re-create resources
      if (model.renderable) {
        model.renderable.getViewProps().forEach(prop => {
          prop.modified();
        });
      }
    };
    publicAPI.setOpenGLRenderWindow = rw => {
      if (model._openGLRenderWindow === rw) {
        return;
      }
      publicAPI.releaseGraphicsResources();
      model._openGLRenderWindow = rw;
      model.context = null;
      if (rw) {
        model.context = model._openGLRenderWindow.getContext();
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1z = {
    context: null,
    _openGLRenderWindow: null,
    selector: null
  };

  // ----------------------------------------------------------------------------

  function extend$1F(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1z, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);

    // Build VTK API
    get$1(publicAPI, model, ['shaderCache']);
    setGet(publicAPI, model, ['selector']);
    moveToProtected(publicAPI, model, ['openGLRenderWindow']);

    // Object methods
    vtkOpenGLRenderer(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1D = newInstance$1I(extend$1F, 'vtkOpenGLRenderer');

  // Register ourself to OpenGL backend if imported
  registerOverride$1('vtkRenderer', newInstance$1D);

  // ----------------------------------------------------------------------------
  // vtkOpenGLActor methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLActor(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLActor');

    // Builds myself.
    publicAPI.buildPass = prepass => {
      if (prepass) {
        model._openGLRenderWindow = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderWindow');
        model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
        model.context = model._openGLRenderWindow.getContext();
        publicAPI.prepareNodes();
        publicAPI.addMissingNodes(model.renderable.getTextures());
        publicAPI.addMissingNode(model.renderable.getMapper());
        publicAPI.removeUnusedNodes();

        // we store textures and mapper
        model.ogltextures = null;
        model.activeTextures = null;
        for (let index = 0; index < model.children.length; index++) {
          const child = model.children[index];
          if (child.isA('vtkOpenGLTexture')) {
            if (!model.ogltextures) {
              model.ogltextures = [];
            }
            model.ogltextures.push(child);
          } else {
            model.oglmapper = child;
          }
        }
      }
    };

    // render both opaque and translucent actors
    publicAPI.traverseZBufferPass = renderPass => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      model.oglmapper.traverse(renderPass);
      publicAPI.apply(renderPass, false);
    };

    // only render opaque actors
    publicAPI.traverseOpaqueZBufferPass = renderPass => publicAPI.traverseOpaquePass(renderPass);

    // we draw textures, then mapper, then post pass textures
    publicAPI.traverseOpaquePass = renderPass => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      model.oglmapper.traverse(renderPass);
      publicAPI.apply(renderPass, false);
    };

    // we draw textures, then mapper, then post pass textures
    publicAPI.traverseTranslucentPass = renderPass => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      model.oglmapper.traverse(renderPass);
      publicAPI.apply(renderPass, false);
    };
    publicAPI.activateTextures = () => {
      // always traverse textures first, then mapper
      if (!model.ogltextures) {
        return;
      }
      model.activeTextures = [];
      for (let index = 0; index < model.ogltextures.length; index++) {
        const child = model.ogltextures[index];
        child.render();
        if (child.getHandle()) {
          model.activeTextures.push(child);
        }
      }
    };
    publicAPI.queryPass = (prepass, renderPass) => {
      if (prepass) {
        if (!model.renderable || !model.renderable.getVisibility()) {
          return;
        }
        if (model.renderable.getIsOpaque()) {
          renderPass.incrementOpaqueActorCount();
        } else {
          renderPass.incrementTranslucentActorCount();
        }
      }
    };
    publicAPI.zBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
    publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass) {
        model.context.depthMask(true);
        publicAPI.activateTextures();
      } else if (model.activeTextures) {
        for (let index = 0; index < model.activeTextures.length; index++) {
          model.activeTextures[index].deactivate();
        }
      }
    };

    // Renders myself
    publicAPI.translucentPass = (prepass, renderPass) => {
      if (prepass) {
        model.context.depthMask(false);
        publicAPI.activateTextures();
      } else if (model.activeTextures) {
        for (let index = 0; index < model.activeTextures.length; index++) {
          model.activeTextures[index].deactivate();
        }
      }
    };
    publicAPI.getKeyMatrices = () => {
      // has the actor changed?
      if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
        model.renderable.computeMatrix();
        copy$1(model.keyMatrices.mcwc, model.renderable.getMatrix());
        transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
        if (model.renderable.getIsIdentity()) {
          identity$4(model.keyMatrices.normalMatrix);
        } else {
          fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.mcwc);
          invert$1(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
          transpose$1(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        }
        model.keyMatrixTime.modified();
      }
      return model.keyMatrices;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1y = {
    context: null,
    keyMatrixTime: null,
    keyMatrices: null,
    activeTextures: null
  };

  // ----------------------------------------------------------------------------

  function extend$1E(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1y, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.keyMatrixTime = {};
    obj(model.keyMatrixTime, {
      mtime: 0
    });
    model.keyMatrices = {
      normalMatrix: identity$4(new Float64Array(9)),
      mcwc: identity$3(new Float64Array(16))
    };

    // Build VTK API
    setGet(publicAPI, model, ['context']);
    get$1(publicAPI, model, ['activeTextures']);

    // Object methods
    vtkOpenGLActor(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1C = newInstance$1I(extend$1E);

  // Register ourself to OpenGL backend if imported
  registerOverride$1('vtkActor', newInstance$1C);

  // ----------------------------------------------------------------------------
  // vtkOpenGLActor methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLActor2D(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLActor2D');

    // Builds myself.
    publicAPI.buildPass = prepass => {
      if (prepass) {
        if (!model.renderable) {
          return;
        }
        model._openGLRenderWindow = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderWindow');
        model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
        model.context = model._openGLRenderWindow.getContext();
        publicAPI.prepareNodes();
        publicAPI.addMissingNodes(model.renderable.getTextures());
        publicAPI.addMissingNode(model.renderable.getMapper());
        publicAPI.removeUnusedNodes();

        // we store textures and mapper
        model.ogltextures = null;
        model.activeTextures = null;
        for (let index = 0; index < model.children.length; index++) {
          const child = model.children[index];
          if (child.isA('vtkOpenGLTexture')) {
            if (!model.ogltextures) {
              model.ogltextures = [];
            }
            model.ogltextures.push(child);
          } else {
            model.oglmapper = child;
          }
        }
      }
    };
    publicAPI.queryPass = (prepass, renderPass) => {
      if (prepass) {
        if (!model.renderable || !model.renderable.getVisibility()) {
          return;
        }
        renderPass.incrementOverlayActorCount();
      }
    };

    // we draw textures, then mapper, then post pass textures
    publicAPI.traverseOpaquePass = renderPass => {
      if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      model.oglmapper.traverse(renderPass);
      publicAPI.apply(renderPass, false);
    };

    // we draw textures, then mapper, then post pass textures
    publicAPI.traverseTranslucentPass = renderPass => {
      if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      model.oglmapper.traverse(renderPass);
      publicAPI.apply(renderPass, false);
    };
    publicAPI.traverseOverlayPass = renderPass => {
      if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable) {
        return;
      }
      publicAPI.apply(renderPass, true);
      model.oglmapper.traverse(renderPass);
      publicAPI.apply(renderPass, false);
    };
    publicAPI.activateTextures = () => {
      // always traverse textures first, then mapper
      if (!model.ogltextures) {
        return;
      }
      model.activeTextures = [];
      for (let index = 0; index < model.ogltextures.length; index++) {
        const child = model.ogltextures[index];
        child.render();
        if (child.getHandle()) {
          model.activeTextures.push(child);
        }
      }
    };

    // Renders myself
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass) {
        model.context.depthMask(true);
        publicAPI.activateTextures();
      } else if (model.activeTextures) {
        // deactivate textures
        for (let index = 0; index < model.activeTextures.length; index++) {
          model.activeTextures[index].deactivate();
        }
      }
    };

    // Renders myself
    publicAPI.translucentPass = (prepass, renderPass) => {
      if (prepass) {
        model.context.depthMask(false);
        publicAPI.activateTextures();
      } else if (model.activeTextures) {
        for (let index = 0; index < model.activeTextures.length; index++) {
          model.activeTextures[index].deactivate();
        }
      }
    };

    // Renders myself
    publicAPI.overlayPass = (prepass, renderPass) => {
      if (prepass) {
        model.context.depthMask(true);
        publicAPI.activateTextures();
      } else if (model.activeTextures) {
        // deactivate textures
        for (let index = 0; index < model.activeTextures.length; index++) {
          model.activeTextures[index].deactivate();
        }
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1x = {
    context: null,
    activeTextures: null
  };

  // ----------------------------------------------------------------------------

  function extend$1D(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1x, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);

    // Build VTK API
    setGet(publicAPI, model, ['context']);
    get$1(publicAPI, model, ['activeTextures']);

    // Object methods
    vtkOpenGLActor2D(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1B = newInstance$1I(extend$1D);

  // Register ourself to OpenGL backend if imported
  registerOverride$1('vtkActor2D', newInstance$1B);

  function ascending(a, b) {
    return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function descending(a, b) {
    return a == null || b == null ? NaN
      : b < a ? -1
      : b > a ? 1
      : b >= a ? 0
      : NaN;
  }

  function bisector(f) {
    let compare1, compare2, delta;

    // If an accessor is specified, promote it to a comparator. In this case we
    // can test whether the search value is (self-) comparable. We cant do this
    // for a comparator (except for specific, known comparators) because we cant
    // tell if the comparator is symmetric, and an asymmetric comparator cant be
    // used to test whether a single value is comparable.
    if (f.length !== 2) {
      compare1 = ascending;
      compare2 = (d, x) => ascending(f(d), x);
      delta = (d, x) => f(d) - x;
    } else {
      compare1 = f === ascending || f === descending ? f : zero$1;
      compare2 = f;
      delta = f;
    }

    function left(a, x, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x, x) !== 0) return hi;
        do {
          const mid = (lo + hi) >>> 1;
          if (compare2(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        } while (lo < hi);
      }
      return lo;
    }

    function right(a, x, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x, x) !== 0) return hi;
        do {
          const mid = (lo + hi) >>> 1;
          if (compare2(a[mid], x) <= 0) lo = mid + 1;
          else hi = mid;
        } while (lo < hi);
      }
      return lo;
    }

    function center(a, x, lo = 0, hi = a.length) {
      const i = left(a, x, lo, hi - 1);
      return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
    }

    return {left, center, right};
  }

  function zero$1() {
    return 0;
  }

  function number$1(x) {
    return x === null ? NaN : +x;
  }

  const ascendingBisect = bisector(ascending);
  const bisectRight = ascendingBisect.right;
  bisector(number$1).center;

  const e10 = Math.sqrt(50),
      e5 = Math.sqrt(10),
      e2 = Math.sqrt(2);

  function tickSpec(start, stop, count) {
    const step = (stop - start) / Math.max(0, count),
        power = Math.floor(Math.log10(step)),
        error = step / Math.pow(10, power),
        factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
      inc = Math.pow(10, -power) / factor;
      i1 = Math.round(start * inc);
      i2 = Math.round(stop * inc);
      if (i1 / inc < start) ++i1;
      if (i2 / inc > stop) --i2;
      inc = -inc;
    } else {
      inc = Math.pow(10, power) * factor;
      i1 = Math.round(start / inc);
      i2 = Math.round(stop / inc);
      if (i1 * inc < start) ++i1;
      if (i2 * inc > stop) --i2;
    }
    if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start, stop, count * 2);
    return [i1, i2, inc];
  }

  function ticks(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    if (!(count > 0)) return [];
    if (start === stop) return [start];
    const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
    if (!(i2 >= i1)) return [];
    const n = i2 - i1 + 1, ticks = new Array(n);
    if (reverse) {
      if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) / -inc;
      else for (let i = 0; i < n; ++i) ticks[i] = (i2 - i) * inc;
    } else {
      if (inc < 0) for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) / -inc;
      else for (let i = 0; i < n; ++i) ticks[i] = (i1 + i) * inc;
    }
    return ticks;
  }

  function tickIncrement(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    return tickSpec(start, stop, count)[2];
  }

  function tickStep(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
    return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
  }

  function initRange(domain, range) {
    switch (arguments.length) {
      case 0: break;
      case 1: this.range(domain); break;
      default: this.range(range).domain(domain); break;
    }
    return this;
  }

  function define(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }

  function extend$1C(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  function Color() {}

  var darker = 0.7;
  var brighter = 1 / darker;

  var reI = "\\s*([+-]?\\d+)\\s*",
      reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
      reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
      reHex = /^#([0-9a-f]{3,8})$/,
      reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
      reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
      reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
      reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
      reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
      reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

  var named = {
    aliceblue: 0xf0f8ff,
    antiquewhite: 0xfaebd7,
    aqua: 0x00ffff,
    aquamarine: 0x7fffd4,
    azure: 0xf0ffff,
    beige: 0xf5f5dc,
    bisque: 0xffe4c4,
    black: 0x000000,
    blanchedalmond: 0xffebcd,
    blue: 0x0000ff,
    blueviolet: 0x8a2be2,
    brown: 0xa52a2a,
    burlywood: 0xdeb887,
    cadetblue: 0x5f9ea0,
    chartreuse: 0x7fff00,
    chocolate: 0xd2691e,
    coral: 0xff7f50,
    cornflowerblue: 0x6495ed,
    cornsilk: 0xfff8dc,
    crimson: 0xdc143c,
    cyan: 0x00ffff,
    darkblue: 0x00008b,
    darkcyan: 0x008b8b,
    darkgoldenrod: 0xb8860b,
    darkgray: 0xa9a9a9,
    darkgreen: 0x006400,
    darkgrey: 0xa9a9a9,
    darkkhaki: 0xbdb76b,
    darkmagenta: 0x8b008b,
    darkolivegreen: 0x556b2f,
    darkorange: 0xff8c00,
    darkorchid: 0x9932cc,
    darkred: 0x8b0000,
    darksalmon: 0xe9967a,
    darkseagreen: 0x8fbc8f,
    darkslateblue: 0x483d8b,
    darkslategray: 0x2f4f4f,
    darkslategrey: 0x2f4f4f,
    darkturquoise: 0x00ced1,
    darkviolet: 0x9400d3,
    deeppink: 0xff1493,
    deepskyblue: 0x00bfff,
    dimgray: 0x696969,
    dimgrey: 0x696969,
    dodgerblue: 0x1e90ff,
    firebrick: 0xb22222,
    floralwhite: 0xfffaf0,
    forestgreen: 0x228b22,
    fuchsia: 0xff00ff,
    gainsboro: 0xdcdcdc,
    ghostwhite: 0xf8f8ff,
    gold: 0xffd700,
    goldenrod: 0xdaa520,
    gray: 0x808080,
    green: 0x008000,
    greenyellow: 0xadff2f,
    grey: 0x808080,
    honeydew: 0xf0fff0,
    hotpink: 0xff69b4,
    indianred: 0xcd5c5c,
    indigo: 0x4b0082,
    ivory: 0xfffff0,
    khaki: 0xf0e68c,
    lavender: 0xe6e6fa,
    lavenderblush: 0xfff0f5,
    lawngreen: 0x7cfc00,
    lemonchiffon: 0xfffacd,
    lightblue: 0xadd8e6,
    lightcoral: 0xf08080,
    lightcyan: 0xe0ffff,
    lightgoldenrodyellow: 0xfafad2,
    lightgray: 0xd3d3d3,
    lightgreen: 0x90ee90,
    lightgrey: 0xd3d3d3,
    lightpink: 0xffb6c1,
    lightsalmon: 0xffa07a,
    lightseagreen: 0x20b2aa,
    lightskyblue: 0x87cefa,
    lightslategray: 0x778899,
    lightslategrey: 0x778899,
    lightsteelblue: 0xb0c4de,
    lightyellow: 0xffffe0,
    lime: 0x00ff00,
    limegreen: 0x32cd32,
    linen: 0xfaf0e6,
    magenta: 0xff00ff,
    maroon: 0x800000,
    mediumaquamarine: 0x66cdaa,
    mediumblue: 0x0000cd,
    mediumorchid: 0xba55d3,
    mediumpurple: 0x9370db,
    mediumseagreen: 0x3cb371,
    mediumslateblue: 0x7b68ee,
    mediumspringgreen: 0x00fa9a,
    mediumturquoise: 0x48d1cc,
    mediumvioletred: 0xc71585,
    midnightblue: 0x191970,
    mintcream: 0xf5fffa,
    mistyrose: 0xffe4e1,
    moccasin: 0xffe4b5,
    navajowhite: 0xffdead,
    navy: 0x000080,
    oldlace: 0xfdf5e6,
    olive: 0x808000,
    olivedrab: 0x6b8e23,
    orange: 0xffa500,
    orangered: 0xff4500,
    orchid: 0xda70d6,
    palegoldenrod: 0xeee8aa,
    palegreen: 0x98fb98,
    paleturquoise: 0xafeeee,
    palevioletred: 0xdb7093,
    papayawhip: 0xffefd5,
    peachpuff: 0xffdab9,
    peru: 0xcd853f,
    pink: 0xffc0cb,
    plum: 0xdda0dd,
    powderblue: 0xb0e0e6,
    purple: 0x800080,
    rebeccapurple: 0x663399,
    red: 0xff0000,
    rosybrown: 0xbc8f8f,
    royalblue: 0x4169e1,
    saddlebrown: 0x8b4513,
    salmon: 0xfa8072,
    sandybrown: 0xf4a460,
    seagreen: 0x2e8b57,
    seashell: 0xfff5ee,
    sienna: 0xa0522d,
    silver: 0xc0c0c0,
    skyblue: 0x87ceeb,
    slateblue: 0x6a5acd,
    slategray: 0x708090,
    slategrey: 0x708090,
    snow: 0xfffafa,
    springgreen: 0x00ff7f,
    steelblue: 0x4682b4,
    tan: 0xd2b48c,
    teal: 0x008080,
    thistle: 0xd8bfd8,
    tomato: 0xff6347,
    turquoise: 0x40e0d0,
    violet: 0xee82ee,
    wheat: 0xf5deb3,
    white: 0xffffff,
    whitesmoke: 0xf5f5f5,
    yellow: 0xffff00,
    yellowgreen: 0x9acd32
  };

  define(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor, this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex, // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });

  function color_formatHex() {
    return this.rgb().formatHex();
  }

  function color_formatHex8() {
    return this.rgb().formatHex8();
  }

  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }

  function color_formatRgb() {
    return this.rgb().formatRgb();
  }

  function color(format) {
    var m, l;
    format = (format + "").trim().toLowerCase();
    return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
        : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
        : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
        : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
        : null) // invalid hex
        : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
        : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
        : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
        : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
        : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
        : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
        : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
        : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
        : null;
  }

  function rgbn(n) {
    return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
  }

  function rgba(r, g, b, a) {
    if (a <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }

  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb;
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }

  function rgb$1(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }

  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }

  define(Rgb, rgb$1, extend$1C(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return (-0.5 <= this.r && this.r < 255.5)
          && (-0.5 <= this.g && this.g < 255.5)
          && (-0.5 <= this.b && this.b < 255.5)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex, // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));

  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }

  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }

  function rgb_formatRgb() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
  }

  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }

  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }

  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }

  function hsla(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a);
  }

  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl;
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255,
        g = o.g / 255,
        b = o.b / 255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        h = NaN,
        s = max - min,
        l = (max + min) / 2;
    if (s) {
      if (r === max) h = (g - b) / s + (g < b) * 6;
      else if (g === max) h = (b - r) / s + 2;
      else h = (r - g) / s + 4;
      s /= l < 0.5 ? max + min : 2 - max - min;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }

  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }

  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }

  define(Hsl, hsl, extend$1C(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360,
          s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
          l = this.l,
          m2 = l + (l < 0.5 ? l : 1 - l) * s,
          m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s))
          && (0 <= this.l && this.l <= 1)
          && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
  }));

  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }

  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }

  /* From FvD 13.37, CSS Color Module Level 3 */
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60
        : h < 180 ? m2
        : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
        : m1) * 255;
  }

  var constant = x => () => x;

  function linear$1(a, d) {
    return function(t) {
      return a + t * d;
    };
  }

  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }

  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
    };
  }

  function nogamma(a, b) {
    var d = b - a;
    return d ? linear$1(a, d) : constant(isNaN(a) ? b : a);
  }

  var rgb = (function rgbGamma(y) {
    var color = gamma(y);

    function rgb(start, end) {
      var r = color((start = rgb$1(start)).r, (end = rgb$1(end)).r),
          g = color(start.g, end.g),
          b = color(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    rgb.gamma = rgbGamma;

    return rgb;
  })(1);

  function numberArray(a, b) {
    if (!b) b = [];
    var n = a ? Math.min(b.length, a.length) : 0,
        c = b.slice(),
        i;
    return function(t) {
      for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
      return c;
    };
  }

  function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }

  function genericArray(a, b) {
    var nb = b ? b.length : 0,
        na = a ? Math.min(nb, a.length) : 0,
        x = new Array(na),
        c = new Array(nb),
        i;

    for (i = 0; i < na; ++i) x[i] = interpolate(a[i], b[i]);
    for (; i < nb; ++i) c[i] = b[i];

    return function(t) {
      for (i = 0; i < na; ++i) c[i] = x[i](t);
      return c;
    };
  }

  function date(a, b) {
    var d = new Date;
    return a = +a, b = +b, function(t) {
      return d.setTime(a * (1 - t) + b * t), d;
    };
  }

  function interpolateNumber(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }

  function object(a, b) {
    var i = {},
        c = {},
        k;

    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};

    for (k in b) {
      if (k in a) {
        i[k] = interpolate(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }

    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }

  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
      reB = new RegExp(reA.source, "g");

  function zero(b) {
    return function() {
      return b;
    };
  }

  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }

  function string(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
        am, // current match in a
        bm, // current match in b
        bs, // string preceding current number in b, if any
        i = -1, // index in s
        s = [], // string constants and placeholders
        q = []; // number interpolators

    // Coerce inputs to strings.
    a = a + "", b = b + "";

    // Interpolate pairs of numbers in a & b.
    while ((am = reA.exec(a))
        && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) { // a string precedes the next number in b
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
        if (s[i]) s[i] += bm; // coalesce with previous string
        else s[++i] = bm;
      } else { // interpolate non-matching numbers
        s[++i] = null;
        q.push({i: i, x: interpolateNumber(am, bm)});
      }
      bi = reB.lastIndex;
    }

    // Add remains of b.
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    // Special optimization for only a single match.
    // Otherwise, interpolate each of the numbers and rejoin the string.
    return s.length < 2 ? (q[0]
        ? one(q[0].x)
        : zero(b))
        : (b = q.length, function(t) {
            for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
            return s.join("");
          });
  }

  function interpolate(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant(b)
        : (t === "number" ? interpolateNumber
        : t === "string" ? ((c = color(b)) ? (b = c, rgb) : string)
        : b instanceof color ? rgb
        : b instanceof Date ? date
        : isNumberArray(b) ? numberArray
        : Array.isArray(b) ? genericArray
        : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
        : interpolateNumber)(a, b);
  }

  function interpolateRound(a, b) {
    return a = +a, b = +b, function(t) {
      return Math.round(a * (1 - t) + b * t);
    };
  }

  function constants(x) {
    return function() {
      return x;
    };
  }

  function number(x) {
    return +x;
  }

  var unit = [0, 1];

  function identity$2(x) {
    return x;
  }

  function normalize$1(a, b) {
    return (b -= (a = +a))
        ? function(x) { return (x - a) / b; }
        : constants(isNaN(b) ? NaN : 0.5);
  }

  function clamper(a, b) {
    var t;
    if (a > b) t = a, a = b, b = t;
    return function(x) { return Math.max(a, Math.min(b, x)); };
  }

  // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
  // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
  function bimap(domain, range, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
    if (d1 < d0) d0 = normalize$1(d1, d0), r0 = interpolate(r1, r0);
    else d0 = normalize$1(d0, d1), r0 = interpolate(r0, r1);
    return function(x) { return r0(d0(x)); };
  }

  function polymap(domain, range, interpolate) {
    var j = Math.min(domain.length, range.length) - 1,
        d = new Array(j),
        r = new Array(j),
        i = -1;

    // Reverse descending domains.
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }

    while (++i < j) {
      d[i] = normalize$1(domain[i], domain[i + 1]);
      r[i] = interpolate(range[i], range[i + 1]);
    }

    return function(x) {
      var i = bisectRight(domain, x, 1, j) - 1;
      return r[i](d[i](x));
    };
  }

  function copy(source, target) {
    return target
        .domain(source.domain())
        .range(source.range())
        .interpolate(source.interpolate())
        .clamp(source.clamp())
        .unknown(source.unknown());
  }

  function transformer() {
    var domain = unit,
        range = unit,
        interpolate$1 = interpolate,
        transform,
        untransform,
        unknown,
        clamp = identity$2,
        piecewise,
        output,
        input;

    function rescale() {
      var n = Math.min(domain.length, range.length);
      if (clamp !== identity$2) clamp = clamper(domain[0], domain[n - 1]);
      piecewise = n > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }

    function scale(x) {
      return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp(x)));
    }

    scale.invert = function(y) {
      return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
    };

    scale.domain = function(_) {
      return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
    };

    scale.range = function(_) {
      return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
    };

    scale.rangeRound = function(_) {
      return range = Array.from(_), interpolate$1 = interpolateRound, rescale();
    };

    scale.clamp = function(_) {
      return arguments.length ? (clamp = _ ? true : identity$2, rescale()) : clamp !== identity$2;
    };

    scale.interpolate = function(_) {
      return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
    };

    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };

    return function(t, u) {
      transform = t, untransform = u;
      return rescale();
    };
  }

  function continuous() {
    return transformer()(identity$2, identity$2);
  }

  function formatDecimal(x) {
    return Math.abs(x = Math.round(x)) >= 1e21
        ? x.toLocaleString("en").replace(/,/g, "")
        : x.toString(10);
  }

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimalParts(1.23) returns ["123", 0].
  function formatDecimalParts(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  function exponent(x) {
    return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
  }

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  }

  function formatNumerals(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }

  formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
    this.align = specifier.align === undefined ? ">" : specifier.align + "";
    this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === undefined ? undefined : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === undefined ? "" : specifier.type + "";
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width === undefined ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
        + (this.trim ? "~" : "")
        + this.type;
  };

  // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
  function formatTrim(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  }

  function formatRounded(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  var formatTypes = {
    "%": (x, p) => (x * 100).toFixed(p),
    "b": (x) => Math.round(x).toString(2),
    "c": (x) => x + "",
    "d": formatDecimal,
    "e": (x, p) => x.toExponential(p),
    "f": (x, p) => x.toFixed(p),
    "g": (x, p) => x.toPrecision(p),
    "o": (x) => Math.round(x).toString(8),
    "p": (x, p) => formatRounded(x * 100, p),
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": (x) => Math.round(x).toString(16).toUpperCase(),
    "x": (x) => Math.round(x).toString(16)
  };

  function identity$1(x) {
    return x;
  }

  var map = Array.prototype.map,
      prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

  function formatLocale(locale) {
    var group = locale.grouping === undefined || locale.thousands === undefined ? identity$1 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
        currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
        currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
        decimal = locale.decimal === undefined ? "." : locale.decimal + "",
        numerals = locale.numerals === undefined ? identity$1 : formatNumerals(map.call(locale.numerals, String)),
        percent = locale.percent === undefined ? "%" : locale.percent + "",
        minus = locale.minus === undefined ? "" : locale.minus + "",
        nan = locale.nan === undefined ? "NaN" : locale.nan + "";

    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          trim = specifier.trim,
          type = specifier.type;

      // The "n" type is an alias for ",g".
      if (type === "n") comma = true, type = "g";

      // The "" type, and any invalid type, is an alias for ".12~g".
      else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

      // If zero fill is specified, padding goes after sign and before digits.
      if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision === undefined ? 6
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      function format(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix,
            i, n, c;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Determine the sign. -0 is not less than 0, but 1 / -0 is!
          var valueNegative = value < 0 || 1 / value < 0;

          // Perform the initial formatting.
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

          // Trim insignificant zeros.
          if (trim) value = formatTrim(value);

          // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
          if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer value part that can be
          // grouped, and fractional or exponential suffix part that is not.
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": value = valuePrefix + value + valueSuffix + padding; break;
          case "=": value = valuePrefix + padding + value + valueSuffix; break;
          case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
          default: value = padding + valuePrefix + value + valueSuffix; break;
        }

        return numerals(value);
      }

      format.toString = function() {
        return specifier + "";
      };

      return format;
    }

    function formatPrefix(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: newFormat,
      formatPrefix: formatPrefix
    };
  }

  var locale;
  var format;
  var formatPrefix;

  defaultLocale({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });

  function defaultLocale(definition) {
    locale = formatLocale(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
  }

  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
  }

  function precisionRound(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent(max) - exponent(step)) + 1;
  }

  function tickFormat(start, stop, count, specifier) {
    var step = tickStep(start, stop, count),
        precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  function linearish(scale) {
    var domain = scale.domain;

    scale.ticks = function(count) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };

    scale.tickFormat = function(count, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };

    scale.nice = function(count) {
      if (count == null) count = 10;

      var d = domain();
      var i0 = 0;
      var i1 = d.length - 1;
      var start = d[i0];
      var stop = d[i1];
      var prestep;
      var step;
      var maxIter = 10;

      if (stop < start) {
        step = start, start = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }
      
      while (maxIter-- > 0) {
        step = tickIncrement(start, stop, count);
        if (step === prestep) {
          d[i0] = start;
          d[i1] = stop;
          return domain(d);
        } else if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
        } else {
          break;
        }
        prestep = step;
      }

      return scale;
    };

    return scale;
  }

  function linear() {
    var scale = continuous();

    scale.copy = function() {
      return copy(scale, linear());
    };

    initRange.apply(scale, arguments);

    return linearish(scale);
  }

  var alea$1 = {exports: {}};

  alea$1.exports;

  (function (module) {
  	// A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
  	// http://baagoe.com/en/RandomMusings/javascript/
  	// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
  	// Original work is under MIT license -

  	// Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
  	//
  	// Permission is hereby granted, free of charge, to any person obtaining a copy
  	// of this software and associated documentation files (the "Software"), to deal
  	// in the Software without restriction, including without limitation the rights
  	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  	// copies of the Software, and to permit persons to whom the Software is
  	// furnished to do so, subject to the following conditions:
  	//
  	// The above copyright notice and this permission notice shall be included in
  	// all copies or substantial portions of the Software.
  	//
  	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  	// THE SOFTWARE.



  	(function(global, module, define) {

  	function Alea(seed) {
  	  var me = this, mash = Mash();

  	  me.next = function() {
  	    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
  	    me.s0 = me.s1;
  	    me.s1 = me.s2;
  	    return me.s2 = t - (me.c = t | 0);
  	  };

  	  // Apply the seeding algorithm from Baagoe.
  	  me.c = 1;
  	  me.s0 = mash(' ');
  	  me.s1 = mash(' ');
  	  me.s2 = mash(' ');
  	  me.s0 -= mash(seed);
  	  if (me.s0 < 0) { me.s0 += 1; }
  	  me.s1 -= mash(seed);
  	  if (me.s1 < 0) { me.s1 += 1; }
  	  me.s2 -= mash(seed);
  	  if (me.s2 < 0) { me.s2 += 1; }
  	  mash = null;
  	}

  	function copy(f, t) {
  	  t.c = f.c;
  	  t.s0 = f.s0;
  	  t.s1 = f.s1;
  	  t.s2 = f.s2;
  	  return t;
  	}

  	function impl(seed, opts) {
  	  var xg = new Alea(seed),
  	      state = opts && opts.state,
  	      prng = xg.next;
  	  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; };
  	  prng.double = function() {
  	    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  	  };
  	  prng.quick = prng;
  	  if (state) {
  	    if (typeof(state) == 'object') copy(state, xg);
  	    prng.state = function() { return copy(xg, {}); };
  	  }
  	  return prng;
  	}

  	function Mash() {
  	  var n = 0xefc8249d;

  	  var mash = function(data) {
  	    data = String(data);
  	    for (var i = 0; i < data.length; i++) {
  	      n += data.charCodeAt(i);
  	      var h = 0.02519603282416938 * n;
  	      n = h >>> 0;
  	      h -= n;
  	      h *= n;
  	      n = h >>> 0;
  	      h -= n;
  	      n += h * 0x100000000; // 2^32
  	    }
  	    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  	  };

  	  return mash;
  	}


  	if (module && module.exports) {
  	  module.exports = impl;
  	} else if (define && define.amd) {
  	  define(function() { return impl; });
  	} else {
  	  this.alea = impl;
  	}

  	})(
  	  commonjsGlobal,
  	  module,    // present in node.js
  	  (typeof undefined) == 'function'    // present with an AMD loader
  	); 
  } (alea$1));

  var aleaExports = alea$1.exports;

  var xor128$1 = {exports: {}};

  xor128$1.exports;

  (function (module) {
  	// A Javascript implementaion of the "xor128" prng algorithm by
  	// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

  	(function(global, module, define) {

  	function XorGen(seed) {
  	  var me = this, strseed = '';

  	  me.x = 0;
  	  me.y = 0;
  	  me.z = 0;
  	  me.w = 0;

  	  // Set up generator function.
  	  me.next = function() {
  	    var t = me.x ^ (me.x << 11);
  	    me.x = me.y;
  	    me.y = me.z;
  	    me.z = me.w;
  	    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  	  };

  	  if (seed === (seed | 0)) {
  	    // Integer seed.
  	    me.x = seed;
  	  } else {
  	    // String seed.
  	    strseed += seed;
  	  }

  	  // Mix in string seed, then discard an initial batch of 64 values.
  	  for (var k = 0; k < strseed.length + 64; k++) {
  	    me.x ^= strseed.charCodeAt(k) | 0;
  	    me.next();
  	  }
  	}

  	function copy(f, t) {
  	  t.x = f.x;
  	  t.y = f.y;
  	  t.z = f.z;
  	  t.w = f.w;
  	  return t;
  	}

  	function impl(seed, opts) {
  	  var xg = new XorGen(seed),
  	      state = opts && opts.state,
  	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  	  prng.double = function() {
  	    do {
  	      var top = xg.next() >>> 11,
  	          bot = (xg.next() >>> 0) / 0x100000000,
  	          result = (top + bot) / (1 << 21);
  	    } while (result === 0);
  	    return result;
  	  };
  	  prng.int32 = xg.next;
  	  prng.quick = prng;
  	  if (state) {
  	    if (typeof(state) == 'object') copy(state, xg);
  	    prng.state = function() { return copy(xg, {}); };
  	  }
  	  return prng;
  	}

  	if (module && module.exports) {
  	  module.exports = impl;
  	} else if (define && define.amd) {
  	  define(function() { return impl; });
  	} else {
  	  this.xor128 = impl;
  	}

  	})(
  	  commonjsGlobal,
  	  module,    // present in node.js
  	  (typeof undefined) == 'function'    // present with an AMD loader
  	); 
  } (xor128$1));

  var xor128Exports = xor128$1.exports;

  var xorwow$1 = {exports: {}};

  xorwow$1.exports;

  (function (module) {
  	// A Javascript implementaion of the "xorwow" prng algorithm by
  	// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

  	(function(global, module, define) {

  	function XorGen(seed) {
  	  var me = this, strseed = '';

  	  // Set up generator function.
  	  me.next = function() {
  	    var t = (me.x ^ (me.x >>> 2));
  	    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
  	    return (me.d = (me.d + 362437 | 0)) +
  	       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  	  };

  	  me.x = 0;
  	  me.y = 0;
  	  me.z = 0;
  	  me.w = 0;
  	  me.v = 0;

  	  if (seed === (seed | 0)) {
  	    // Integer seed.
  	    me.x = seed;
  	  } else {
  	    // String seed.
  	    strseed += seed;
  	  }

  	  // Mix in string seed, then discard an initial batch of 64 values.
  	  for (var k = 0; k < strseed.length + 64; k++) {
  	    me.x ^= strseed.charCodeAt(k) | 0;
  	    if (k == strseed.length) {
  	      me.d = me.x << 10 ^ me.x >>> 4;
  	    }
  	    me.next();
  	  }
  	}

  	function copy(f, t) {
  	  t.x = f.x;
  	  t.y = f.y;
  	  t.z = f.z;
  	  t.w = f.w;
  	  t.v = f.v;
  	  t.d = f.d;
  	  return t;
  	}

  	function impl(seed, opts) {
  	  var xg = new XorGen(seed),
  	      state = opts && opts.state,
  	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  	  prng.double = function() {
  	    do {
  	      var top = xg.next() >>> 11,
  	          bot = (xg.next() >>> 0) / 0x100000000,
  	          result = (top + bot) / (1 << 21);
  	    } while (result === 0);
  	    return result;
  	  };
  	  prng.int32 = xg.next;
  	  prng.quick = prng;
  	  if (state) {
  	    if (typeof(state) == 'object') copy(state, xg);
  	    prng.state = function() { return copy(xg, {}); };
  	  }
  	  return prng;
  	}

  	if (module && module.exports) {
  	  module.exports = impl;
  	} else if (define && define.amd) {
  	  define(function() { return impl; });
  	} else {
  	  this.xorwow = impl;
  	}

  	})(
  	  commonjsGlobal,
  	  module,    // present in node.js
  	  (typeof undefined) == 'function'    // present with an AMD loader
  	); 
  } (xorwow$1));

  var xorwowExports = xorwow$1.exports;

  var xorshift7$1 = {exports: {}};

  xorshift7$1.exports;

  (function (module) {
  	// A Javascript implementaion of the "xorshift7" algorithm by
  	// Franois Panneton and Pierre L'ecuyer:
  	// "On the Xorgshift Random Number Generators"
  	// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

  	(function(global, module, define) {

  	function XorGen(seed) {
  	  var me = this;

  	  // Set up generator function.
  	  me.next = function() {
  	    // Update xor generator.
  	    var X = me.x, i = me.i, t, v;
  	    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
  	    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
  	    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
  	    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
  	    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
  	    X[i] = v;
  	    me.i = (i + 1) & 7;
  	    return v;
  	  };

  	  function init(me, seed) {
  	    var j, X = [];

  	    if (seed === (seed | 0)) {
  	      // Seed state array using a 32-bit integer.
  	      X[0] = seed;
  	    } else {
  	      // Seed state using a string.
  	      seed = '' + seed;
  	      for (j = 0; j < seed.length; ++j) {
  	        X[j & 7] = (X[j & 7] << 15) ^
  	            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
  	      }
  	    }
  	    // Enforce an array length of 8, not all zeroes.
  	    while (X.length < 8) X.push(0);
  	    for (j = 0; j < 8 && X[j] === 0; ++j);
  	    if (j == 8) X[7] = -1; else X[j];

  	    me.x = X;
  	    me.i = 0;

  	    // Discard an initial 256 values.
  	    for (j = 256; j > 0; --j) {
  	      me.next();
  	    }
  	  }

  	  init(me, seed);
  	}

  	function copy(f, t) {
  	  t.x = f.x.slice();
  	  t.i = f.i;
  	  return t;
  	}

  	function impl(seed, opts) {
  	  if (seed == null) seed = +(new Date);
  	  var xg = new XorGen(seed),
  	      state = opts && opts.state,
  	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  	  prng.double = function() {
  	    do {
  	      var top = xg.next() >>> 11,
  	          bot = (xg.next() >>> 0) / 0x100000000,
  	          result = (top + bot) / (1 << 21);
  	    } while (result === 0);
  	    return result;
  	  };
  	  prng.int32 = xg.next;
  	  prng.quick = prng;
  	  if (state) {
  	    if (state.x) copy(state, xg);
  	    prng.state = function() { return copy(xg, {}); };
  	  }
  	  return prng;
  	}

  	if (module && module.exports) {
  	  module.exports = impl;
  	} else if (define && define.amd) {
  	  define(function() { return impl; });
  	} else {
  	  this.xorshift7 = impl;
  	}

  	})(
  	  commonjsGlobal,
  	  module,    // present in node.js
  	  (typeof undefined) == 'function'    // present with an AMD loader
  	); 
  } (xorshift7$1));

  var xorshift7Exports = xorshift7$1.exports;

  var xor4096$1 = {exports: {}};

  xor4096$1.exports;

  (function (module) {
  	// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
  	//
  	// This fast non-cryptographic random number generator is designed for
  	// use in Monte-Carlo algorithms. It combines a long-period xorshift
  	// generator with a Weyl generator, and it passes all common batteries
  	// of stasticial tests for randomness while consuming only a few nanoseconds
  	// for each prng generated.  For background on the generator, see Brent's
  	// paper: "Some long-period random number generators using shifts and xors."
  	// http://arxiv.org/pdf/1004.3115v1.pdf
  	//
  	// Usage:
  	//
  	// var xor4096 = require('xor4096');
  	// random = xor4096(1);                        // Seed with int32 or string.
  	// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
  	// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
  	//
  	// For nonzero numeric keys, this impelementation provides a sequence
  	// identical to that by Brent's xorgens 3 implementaion in C.  This
  	// implementation also provides for initalizing the generator with
  	// string seeds, or for saving and restoring the state of the generator.
  	//
  	// On Chrome, this prng benchmarks about 2.1 times slower than
  	// Javascript's built-in Math.random().

  	(function(global, module, define) {

  	function XorGen(seed) {
  	  var me = this;

  	  // Set up generator function.
  	  me.next = function() {
  	    var w = me.w,
  	        X = me.X, i = me.i, t, v;
  	    // Update Weyl generator.
  	    me.w = w = (w + 0x61c88647) | 0;
  	    // Update xor generator.
  	    v = X[(i + 34) & 127];
  	    t = X[i = ((i + 1) & 127)];
  	    v ^= v << 13;
  	    t ^= t << 17;
  	    v ^= v >>> 15;
  	    t ^= t >>> 12;
  	    // Update Xor generator array state.
  	    v = X[i] = v ^ t;
  	    me.i = i;
  	    // Result is the combination.
  	    return (v + (w ^ (w >>> 16))) | 0;
  	  };

  	  function init(me, seed) {
  	    var t, v, i, j, w, X = [], limit = 128;
  	    if (seed === (seed | 0)) {
  	      // Numeric seeds initialize v, which is used to generates X.
  	      v = seed;
  	      seed = null;
  	    } else {
  	      // String seeds are mixed into v and X one character at a time.
  	      seed = seed + '\0';
  	      v = 0;
  	      limit = Math.max(limit, seed.length);
  	    }
  	    // Initialize circular array and weyl value.
  	    for (i = 0, j = -32; j < limit; ++j) {
  	      // Put the unicode characters into the array, and shuffle them.
  	      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
  	      // After 32 shuffles, take v as the starting w value.
  	      if (j === 0) w = v;
  	      v ^= v << 10;
  	      v ^= v >>> 15;
  	      v ^= v << 4;
  	      v ^= v >>> 13;
  	      if (j >= 0) {
  	        w = (w + 0x61c88647) | 0;     // Weyl.
  	        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
  	        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
  	      }
  	    }
  	    // We have detected all zeroes; make the key nonzero.
  	    if (i >= 128) {
  	      X[(seed && seed.length || 0) & 127] = -1;
  	    }
  	    // Run the generator 512 times to further mix the state before using it.
  	    // Factoring this as a function slows the main generator, so it is just
  	    // unrolled here.  The weyl generator is not advanced while warming up.
  	    i = 127;
  	    for (j = 4 * 128; j > 0; --j) {
  	      v = X[(i + 34) & 127];
  	      t = X[i = ((i + 1) & 127)];
  	      v ^= v << 13;
  	      t ^= t << 17;
  	      v ^= v >>> 15;
  	      t ^= t >>> 12;
  	      X[i] = v ^ t;
  	    }
  	    // Storing state as object members is faster than using closure variables.
  	    me.w = w;
  	    me.X = X;
  	    me.i = i;
  	  }

  	  init(me, seed);
  	}

  	function copy(f, t) {
  	  t.i = f.i;
  	  t.w = f.w;
  	  t.X = f.X.slice();
  	  return t;
  	}
  	function impl(seed, opts) {
  	  if (seed == null) seed = +(new Date);
  	  var xg = new XorGen(seed),
  	      state = opts && opts.state,
  	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  	  prng.double = function() {
  	    do {
  	      var top = xg.next() >>> 11,
  	          bot = (xg.next() >>> 0) / 0x100000000,
  	          result = (top + bot) / (1 << 21);
  	    } while (result === 0);
  	    return result;
  	  };
  	  prng.int32 = xg.next;
  	  prng.quick = prng;
  	  if (state) {
  	    if (state.X) copy(state, xg);
  	    prng.state = function() { return copy(xg, {}); };
  	  }
  	  return prng;
  	}

  	if (module && module.exports) {
  	  module.exports = impl;
  	} else if (define && define.amd) {
  	  define(function() { return impl; });
  	} else {
  	  this.xor4096 = impl;
  	}

  	})(
  	  commonjsGlobal,                                     // window object or global
  	  module,    // present in node.js
  	  (typeof undefined) == 'function'    // present with an AMD loader
  	); 
  } (xor4096$1));

  var xor4096Exports = xor4096$1.exports;

  var tychei$1 = {exports: {}};

  tychei$1.exports;

  (function (module) {
  	// A Javascript implementaion of the "Tyche-i" prng algorithm by
  	// Samuel Neves and Filipe Araujo.
  	// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

  	(function(global, module, define) {

  	function XorGen(seed) {
  	  var me = this, strseed = '';

  	  // Set up generator function.
  	  me.next = function() {
  	    var b = me.b, c = me.c, d = me.d, a = me.a;
  	    b = (b << 25) ^ (b >>> 7) ^ c;
  	    c = (c - d) | 0;
  	    d = (d << 24) ^ (d >>> 8) ^ a;
  	    a = (a - b) | 0;
  	    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
  	    me.c = c = (c - d) | 0;
  	    me.d = (d << 16) ^ (c >>> 16) ^ a;
  	    return me.a = (a - b) | 0;
  	  };

  	  /* The following is non-inverted tyche, which has better internal
  	   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  	  me.next = function() {
  	    var a = me.a, b = me.b, c = me.c, d = me.d;
  	    a = (me.a + me.b | 0) >>> 0;
  	    d = me.d ^ a; d = d << 16 ^ d >>> 16;
  	    c = me.c + d | 0;
  	    b = me.b ^ c; b = b << 12 ^ d >>> 20;
  	    me.a = a = a + b | 0;
  	    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
  	    me.c = c = c + d | 0;
  	    b = b ^ c;
  	    return me.b = (b << 7 ^ b >>> 25);
  	  }
  	  */

  	  me.a = 0;
  	  me.b = 0;
  	  me.c = 2654435769 | 0;
  	  me.d = 1367130551;

  	  if (seed === Math.floor(seed)) {
  	    // Integer seed.
  	    me.a = (seed / 0x100000000) | 0;
  	    me.b = seed | 0;
  	  } else {
  	    // String seed.
  	    strseed += seed;
  	  }

  	  // Mix in string seed, then discard an initial batch of 64 values.
  	  for (var k = 0; k < strseed.length + 20; k++) {
  	    me.b ^= strseed.charCodeAt(k) | 0;
  	    me.next();
  	  }
  	}

  	function copy(f, t) {
  	  t.a = f.a;
  	  t.b = f.b;
  	  t.c = f.c;
  	  t.d = f.d;
  	  return t;
  	}
  	function impl(seed, opts) {
  	  var xg = new XorGen(seed),
  	      state = opts && opts.state,
  	      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  	  prng.double = function() {
  	    do {
  	      var top = xg.next() >>> 11,
  	          bot = (xg.next() >>> 0) / 0x100000000,
  	          result = (top + bot) / (1 << 21);
  	    } while (result === 0);
  	    return result;
  	  };
  	  prng.int32 = xg.next;
  	  prng.quick = prng;
  	  if (state) {
  	    if (typeof(state) == 'object') copy(state, xg);
  	    prng.state = function() { return copy(xg, {}); };
  	  }
  	  return prng;
  	}

  	if (module && module.exports) {
  	  module.exports = impl;
  	} else if (define && define.amd) {
  	  define(function() { return impl; });
  	} else {
  	  this.tychei = impl;
  	}

  	})(
  	  commonjsGlobal,
  	  module,    // present in node.js
  	  (typeof undefined) == 'function'    // present with an AMD loader
  	); 
  } (tychei$1));

  var tycheiExports = tychei$1.exports;

  var seedrandom = {exports: {}};

  /*
  Copyright 2019 David Bau.

  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

  */

  (function (module) {
  	(function (global, pool, math) {
  	//
  	// The following constants are related to IEEE 754 limits.
  	//

  	var width = 256,        // each RC4 output is 0 <= x < 256
  	    chunks = 6,         // at least six RC4 outputs for each double
  	    digits = 52,        // there are 52 significant digits in a double
  	    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
  	    startdenom = math.pow(width, chunks),
  	    significance = math.pow(2, digits),
  	    overflow = significance * 2,
  	    mask = width - 1,
  	    nodecrypto;         // node.js crypto module, initialized at the bottom.

  	//
  	// seedrandom()
  	// This is the seedrandom function described above.
  	//
  	function seedrandom(seed, options, callback) {
  	  var key = [];
  	  options = (options == true) ? { entropy: true } : (options || {});

  	  // Flatten the seed string or build one from local entropy if needed.
  	  var shortseed = mixkey(flatten(
  	    options.entropy ? [seed, tostring(pool)] :
  	    (seed == null) ? autoseed() : seed, 3), key);

  	  // Use the seed to initialize an ARC4 generator.
  	  var arc4 = new ARC4(key);

  	  // This function returns a random double in [0, 1) that contains
  	  // randomness in every bit of the mantissa of the IEEE 754 value.
  	  var prng = function() {
  	    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
  	        d = startdenom,                 //   and denominator d = 2 ^ 48.
  	        x = 0;                          //   and no 'extra last byte'.
  	    while (n < significance) {          // Fill up all significant digits by
  	      n = (n + x) * width;              //   shifting numerator and
  	      d *= width;                       //   denominator and generating a
  	      x = arc4.g(1);                    //   new least-significant-byte.
  	    }
  	    while (n >= overflow) {             // To avoid rounding up, before adding
  	      n /= 2;                           //   last byte, shift everything
  	      d /= 2;                           //   right using integer math until
  	      x >>>= 1;                         //   we have exactly the desired bits.
  	    }
  	    return (n + x) / d;                 // Form the number within [0, 1).
  	  };

  	  prng.int32 = function() { return arc4.g(4) | 0; };
  	  prng.quick = function() { return arc4.g(4) / 0x100000000; };
  	  prng.double = prng;

  	  // Mix the randomness into accumulated entropy.
  	  mixkey(tostring(arc4.S), pool);

  	  // Calling convention: what to return as a function of prng, seed, is_math.
  	  return (options.pass || callback ||
  	      function(prng, seed, is_math_call, state) {
  	        if (state) {
  	          // Load the arc4 state from the given state if it has an S array.
  	          if (state.S) { copy(state, arc4); }
  	          // Only provide the .state method if requested via options.state.
  	          prng.state = function() { return copy(arc4, {}); };
  	        }

  	        // If called as a method of Math (Math.seedrandom()), mutate
  	        // Math.random because that is how seedrandom.js has worked since v1.0.
  	        if (is_math_call) { math[rngname] = prng; return seed; }

  	        // Otherwise, it is a newer calling convention, so return the
  	        // prng directly.
  	        else return prng;
  	      })(
  	  prng,
  	  shortseed,
  	  'global' in options ? options.global : (this == math),
  	  options.state);
  	}

  	//
  	// ARC4
  	//
  	// An ARC4 implementation.  The constructor takes a key in the form of
  	// an array of at most (width) integers that should be 0 <= x < (width).
  	//
  	// The g(count) method returns a pseudorandom integer that concatenates
  	// the next (count) outputs from ARC4.  Its return value is a number x
  	// that is in the range 0 <= x < (width ^ count).
  	//
  	function ARC4(key) {
  	  var t, keylen = key.length,
  	      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  	  // The empty key [] is treated as [0].
  	  if (!keylen) { key = [keylen++]; }

  	  // Set up S using the standard key scheduling algorithm.
  	  while (i < width) {
  	    s[i] = i++;
  	  }
  	  for (i = 0; i < width; i++) {
  	    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
  	    s[j] = t;
  	  }

  	  // The "g" method returns the next (count) outputs as one number.
  	  (me.g = function(count) {
  	    // Using instance members instead of closure state nearly doubles speed.
  	    var t, r = 0,
  	        i = me.i, j = me.j, s = me.S;
  	    while (count--) {
  	      t = s[i = mask & (i + 1)];
  	      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
  	    }
  	    me.i = i; me.j = j;
  	    return r;
  	    // For robust unpredictability, the function call below automatically
  	    // discards an initial batch of values.  This is called RC4-drop[256].
  	    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  	  })(width);
  	}

  	//
  	// copy()
  	// Copies internal state of ARC4 to or from a plain object.
  	//
  	function copy(f, t) {
  	  t.i = f.i;
  	  t.j = f.j;
  	  t.S = f.S.slice();
  	  return t;
  	}
  	//
  	// flatten()
  	// Converts an object tree to nested arrays of strings.
  	//
  	function flatten(obj, depth) {
  	  var result = [], typ = (typeof obj), prop;
  	  if (depth && typ == 'object') {
  	    for (prop in obj) {
  	      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
  	    }
  	  }
  	  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
  	}

  	//
  	// mixkey()
  	// Mixes a string seed into a key that is an array of integers, and
  	// returns a shortened string seed that is equivalent to the result key.
  	//
  	function mixkey(seed, key) {
  	  var stringseed = seed + '', smear, j = 0;
  	  while (j < stringseed.length) {
  	    key[mask & j] =
  	      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  	  }
  	  return tostring(key);
  	}

  	//
  	// autoseed()
  	// Returns an object for autoseeding, using window.crypto and Node crypto
  	// module if available.
  	//
  	function autoseed() {
  	  try {
  	    var out;
  	    if (nodecrypto && (out = nodecrypto.randomBytes)) {
  	      // The use of 'out' to remember randomBytes makes tight minified code.
  	      out = out(width);
  	    } else {
  	      out = new Uint8Array(width);
  	      (global.crypto || global.msCrypto).getRandomValues(out);
  	    }
  	    return tostring(out);
  	  } catch (e) {
  	    var browser = global.navigator,
  	        plugins = browser && browser.plugins;
  	    return [+new Date, global, plugins, global.screen, tostring(pool)];
  	  }
  	}

  	//
  	// tostring()
  	// Converts an array of charcodes to a string
  	//
  	function tostring(a) {
  	  return String.fromCharCode.apply(0, a);
  	}

  	//
  	// When seedrandom.js is loaded, we immediately mix a few bits
  	// from the built-in RNG into the entropy pool.  Because we do
  	// not want to interfere with deterministic PRNG state later,
  	// seedrandom will not call math.random on its own again after
  	// initialization.
  	//
  	mixkey(math.random(), pool);

  	//
  	// Nodejs and AMD support: export the implementation as a module using
  	// either convention.
  	//
  	if (module.exports) {
  	  module.exports = seedrandom;
  	  // When in node.js, try using crypto package for autoseeding.
  	  try {
  	    nodecrypto = require('crypto');
  	  } catch (ex) {}
  	} else {
  	  // When included as a plain script, set up Math.seedrandom global.
  	  math['seed' + rngname] = seedrandom;
  	}


  	// End anonymous scope, and pass initial values.
  	})(
  	  // global: `self` in browsers (including strict mode and web workers),
  	  // otherwise `this` in Node and other environments
  	  (typeof self !== 'undefined') ? self : commonjsGlobal,
  	  [],     // pool: entropy pool starts empty
  	  Math    // math: package containing random, pow, and seedrandom
  	); 
  } (seedrandom));

  var seedrandomExports = seedrandom.exports;

  // A library of seedable RNGs implemented in Javascript.
  //
  // Usage:
  //
  // var seedrandom = require('seedrandom');
  // var random = seedrandom(1); // or any seed.
  // var x = random();       // 0 <= x < 1.  Every bit is random.
  // var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

  // alea, a 53-bit multiply-with-carry generator by Johannes Baage.
  // Period: ~2^116
  // Reported to pass all BigCrush tests.
  var alea = aleaExports;

  // xor128, a pure xor-shift generator by George Marsaglia.
  // Period: 2^128-1.
  // Reported to fail: MatrixRank and LinearComp.
  var xor128 = xor128Exports;

  // xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
  // Period: 2^192-2^32
  // Reported to fail: CollisionOver, SimpPoker, and LinearComp.
  var xorwow = xorwowExports;

  // xorshift7, by Franois Panneton and Pierre L'ecuyer, takes
  // a different approach: it adds robustness by allowing more shifts
  // than Marsaglia's original three.  It is a 7-shift generator
  // with 256 bits, that passes BigCrush with no systmatic failures.
  // Period 2^256-1.
  // No systematic BigCrush failures reported.
  var xorshift7 = xorshift7Exports;

  // xor4096, by Richard Brent, is a 4096-bit xor-shift with a
  // very long period that also adds a Weyl generator. It also passes
  // BigCrush with no systematic failures.  Its long period may
  // be useful if you have many generators and need to avoid
  // collisions.
  // Period: 2^4128-2^32.
  // No systematic BigCrush failures reported.
  var xor4096 = xor4096Exports;

  // Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
  // number generator derived from ChaCha, a modern stream cipher.
  // https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
  // Period: ~2^127
  // No systematic BigCrush failures reported.
  var tychei = tycheiExports;

  // The original ARC4-based prng included in this library.
  // Period: ~2^1600
  var sr = seedrandomExports;

  sr.alea = alea;
  sr.xor128 = xor128;
  sr.xorwow = xorwow;
  sr.xorshift7 = xorshift7;
  sr.xor4096 = xor4096;
  sr.tychei = tychei;

  const IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  const EPSILON$2 = 1e-6;
  const VTK_SMALL_NUMBER = 1.0e-12;

  const {
    vtkErrorMacro: vtkErrorMacro$t,
    vtkWarningMacro: vtkWarningMacro$6
  } = macro;

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  function createArray() {
    let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
    // faster than Array.from and/or while loop
    const res = Array(size);
    for (let i = 0; i < size; ++i) {
      res[i] = 0;
    }
    return res;
  }
  function radiansFromDegrees(deg) {
    return deg / 180 * Math.PI;
  }
  function degreesFromRadians(rad) {
    return rad * 180 / Math.PI;
  }
  const {
    round,
    floor,
    ceil,
    min,
    max
  } = Math;
  function nearestPowerOfTwo(xi) {
    let v = 1;
    while (v < xi) {
      v *= 2;
    }
    return v;
  }
  function isPowerOfTwo(x) {
    return x === nearestPowerOfTwo(x);
  }

  // Vect3 operations
  function add(a, b, out) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  function subtract(a, b, out) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  function multiplyAccumulate(a, b, scalar, out) {
    out[0] = a[0] + b[0] * scalar;
    out[1] = a[1] + b[1] * scalar;
    out[2] = a[2] + b[2] * scalar;
    return out;
  }
  function dot(x, y) {
    return x[0] * y[0] + x[1] * y[1] + x[2] * y[2];
  }
  function cross(x, y, out) {
    const Zx = x[1] * y[2] - x[2] * y[1];
    const Zy = x[2] * y[0] - x[0] * y[2];
    const Zz = x[0] * y[1] - x[1] * y[0];
    out[0] = Zx;
    out[1] = Zy;
    out[2] = Zz;
    return out;
  }
  function norm(x) {
    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    switch (n) {
      case 1:
        return Math.abs(x);
      case 2:
        return Math.sqrt(x[0] * x[0] + x[1] * x[1]);
      case 3:
        return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
      default:
        {
          let sum = 0;
          for (let i = 0; i < n; i++) {
            sum += x[i] * x[i];
          }
          return Math.sqrt(sum);
        }
    }
  }
  function normalize(x) {
    const den = norm(x);
    if (den !== 0.0) {
      x[0] /= den;
      x[1] /= den;
      x[2] /= den;
    }
    return den;
  }
  function distance2BetweenPoints(x, y) {
    return (x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1]) + (x[2] - y[2]) * (x[2] - y[2]);
  }
  function norm2D(x2D) {
    return Math.sqrt(x2D[0] * x2D[0] + x2D[1] * x2D[1]);
  }
  function normalize2D(x) {
    const den = norm2D(x);
    if (den !== 0.0) {
      x[0] /= den;
      x[1] /= den;
    }
    return den;
  }
  function determinant2x2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 2) {
      return args[0][0] * args[1][1] - args[1][0] * args[0][1];
    }
    if (args.length === 4) {
      return args[0] * args[3] - args[1] * args[2];
    }
    return Number.NaN;
  }

  /**
   * Returns true if elements of both arrays are equals.
   * @param {Array} a an array of numbers (vector, point, matrix...)
   * @param {Array} b an array of numbers (vector, point, matrix...)
   * @param {Number} eps tolerance
   */
  function areEquals(a, b) {
    let eps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSILON$2;
    if (a.length !== b.length) {
      return false;
    }
    function isEqual(element, index) {
      return Math.abs(element - b[index]) <= eps;
    }
    return a.every(isEqual);
  }
  const areMatricesEqual = areEquals;
  function roundNumber(num) {
    let digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (!`${num}`.includes('e')) {
      return +`${Math.round(`${num}e+${digits}`)}e-${digits}`;
    }
    const arr = `${num}`.split('e');
    let sig = '';
    if (+arr[1] + digits > 0) {
      sig = '+';
    }
    return +`${Math.round(`${+arr[0]}e${sig}${+arr[1] + digits}`)}e-${digits}`;
  }
  function roundVector(vector) {
    let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
    let digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    out[0] = roundNumber(vector[0], digits);
    out[1] = roundNumber(vector[1], digits);
    out[2] = roundNumber(vector[2], digits);
    return out;
  }

  /**
   * Factor linear equations Ax = b using LU decomposition A = LU. Output factorization LU is in matrix A.
   * @param {Matrix} A square matrix
   * @param {Number} index integer array of pivot indices index[0->n-1]
   * @param {Number} size matrix size
   */
  function luFactorLinearSystem(A, index, size) {
    let i;
    let j;
    let k;
    let largest;
    let maxI = 0;
    let sum;
    let temp1;
    let temp2;
    const scale = createArray(size);

    //
    // Loop over rows to get implicit scaling information
    //
    for (i = 0; i < size; i++) {
      for (largest = 0.0, j = 0; j < size; j++) {
        if ((temp2 = Math.abs(A[i * size + j])) > largest) {
          largest = temp2;
        }
      }
      if (largest === 0.0) {
        vtkWarningMacro$6('Unable to factor linear system');
        return 0;
      }
      scale[i] = 1.0 / largest;
    }
    //
    // Loop over all columns using Crout's method
    //
    for (j = 0; j < size; j++) {
      for (i = 0; i < j; i++) {
        sum = A[i * size + j];
        for (k = 0; k < i; k++) {
          sum -= A[i * size + k] * A[k * size + j];
        }
        A[i * size + j] = sum;
      }
      //
      // Begin search for largest pivot element
      //
      for (largest = 0.0, i = j; i < size; i++) {
        sum = A[i * size + j];
        for (k = 0; k < j; k++) {
          sum -= A[i * size + k] * A[k * size + j];
        }
        A[i * size + j] = sum;
        if ((temp1 = scale[i] * Math.abs(sum)) >= largest) {
          largest = temp1;
          maxI = i;
        }
      }
      //
      // Check for row interchange
      //
      if (j !== maxI) {
        for (k = 0; k < size; k++) {
          temp1 = A[maxI * size + k];
          A[maxI * size + k] = A[j * size + k];
          A[j * size + k] = temp1;
        }
        scale[maxI] = scale[j];
      }
      //
      // Divide by pivot element and perform elimination
      //
      index[j] = maxI;
      if (Math.abs(A[j * size + j]) <= VTK_SMALL_NUMBER) {
        vtkWarningMacro$6('Unable to factor linear system');
        return 0;
      }
      if (j !== size - 1) {
        temp1 = 1.0 / A[j * size + j];
        for (i = j + 1; i < size; i++) {
          A[i * size + j] *= temp1;
        }
      }
    }
    return 1;
  }
  function luSolveLinearSystem(A, index, x, size) {
    let i;
    let j;
    let ii;
    let idx;
    let sum;
    //
    // Proceed with forward and backsubstitution for L and U
    // matrices.  First, forward substitution.
    //
    for (ii = -1, i = 0; i < size; i++) {
      idx = index[i];
      sum = x[idx];
      x[idx] = x[i];
      if (ii >= 0) {
        for (j = ii; j <= i - 1; j++) {
          sum -= A[i * size + j] * x[j];
        }
      } else if (sum !== 0.0) {
        ii = i;
      }
      x[i] = sum;
    }
    //
    // Now, back substitution
    //
    for (i = size - 1; i >= 0; i--) {
      sum = x[i];
      for (j = i + 1; j < size; j++) {
        sum -= A[i * size + j] * x[j];
      }
      x[i] = sum / A[i * size + i];
    }
  }
  function solveLinearSystem(A, x, size) {
    // if we solving something simple, just solve it
    if (size === 2) {
      const y = createArray(2);
      const det = determinant2x2(A[0], A[1], A[2], A[3]);
      if (det === 0.0) {
        // Unable to solve linear system
        return 0;
      }
      y[0] = (A[3] * x[0] - A[1] * x[1]) / det;
      y[1] = (-(A[2] * x[0]) + A[0] * x[1]) / det;
      x[0] = y[0];
      x[1] = y[1];
      return 1;
    }
    if (size === 1) {
      if (A[0] === 0.0) {
        // Unable to solve linear system
        return 0;
      }
      x[0] /= A[0];
      return 1;
    }

    //
    // System of equations is not trivial, use Crout's method
    //

    // Check on allocation of working vectors
    const index = createArray(size);

    // Factor and solve matrix
    if (luFactorLinearSystem(A, index, size) === 0) {
      return 0;
    }
    luSolveLinearSystem(A, index, x, size);
    return 1;
  }
  function hsv2rgb(hsv, rgb) {
    const [h, s, v] = hsv;
    const onethird = 1.0 / 3.0;
    const onesixth = 1.0 / 6.0;
    const twothird = 2.0 / 3.0;
    const fivesixth = 5.0 / 6.0;
    let r;
    let g;
    let b;

    // compute RGB from HSV
    if (h > onesixth && h <= onethird) {
      // green/red
      g = 1.0;
      r = (onethird - h) / onesixth;
      b = 0.0;
    } else if (h > onethird && h <= 0.5) {
      // green/blue
      g = 1.0;
      b = (h - onethird) / onesixth;
      r = 0.0;
    } else if (h > 0.5 && h <= twothird) {
      // blue/green
      b = 1.0;
      g = (twothird - h) / onesixth;
      r = 0.0;
    } else if (h > twothird && h <= fivesixth) {
      // blue/red
      b = 1.0;
      r = (h - twothird) / onesixth;
      g = 0.0;
    } else if (h > fivesixth && h <= 1.0) {
      // red/blue
      r = 1.0;
      b = (1.0 - h) / onesixth;
      g = 0.0;
    } else {
      // red/green
      r = 1.0;
      g = h / onesixth;
      b = 0.0;
    }

    // add Saturation to the equation.
    r = s * r + (1.0 - s);
    g = s * g + (1.0 - s);
    b = s * b + (1.0 - s);
    r *= v;
    g *= v;
    b *= v;

    // Assign back to the array
    rgb[0] = r;
    rgb[1] = g;
    rgb[2] = b;
  }
  function uninitializeBounds(bounds) {
    bounds[0] = 1.0;
    bounds[1] = -1.0;
    bounds[2] = 1.0;
    bounds[3] = -1.0;
    bounds[4] = 1.0;
    bounds[5] = -1.0;
    return bounds;
  }
  function areBoundsInitialized(bounds) {
    return !(bounds[1] - bounds[0] < 0.0);
  }
  function clampValue(value, minValue, maxValue) {
    if (value < minValue) {
      return minValue;
    }
    if (value > maxValue) {
      return maxValue;
    }
    return value;
  }
  function clampVector(vector, minVector, maxVector) {
    let out = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0, 0, 0];
    out[0] = clampValue(vector[0], minVector[0], maxVector[0]);
    out[1] = clampValue(vector[1], minVector[1], maxVector[1]);
    out[2] = clampValue(vector[2], minVector[2], maxVector[2]);
    return out;
  }
  const {
    isFinite: isFinite$1,
    isNaN: isNaN$1
  } = Number;
  const isNan = isNaN$1;

  // JavaScript - add-on ----------------------

  function createUninitializedBounds() {
    return [].concat([Number.MAX_VALUE, -Number.MAX_VALUE,
    // X
    Number.MAX_VALUE, -Number.MAX_VALUE,
    // Y
    Number.MAX_VALUE, -Number.MAX_VALUE // Z
    ]);
  }

  const PLANE_TOLERANCE = 1.0e-6;
  const COINCIDE = 'coincide';
  const DISJOINT = 'disjoint';

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  function evaluate(normal, origin, x) {
    return normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);
  }
  function distanceToPlane(x, origin, normal) {
    const distance = normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);
    return Math.abs(distance);
  }
  function projectPoint(x, origin, normal, xproj) {
    const xo = [];
    subtract(x, origin, xo);
    const t = dot(normal, xo);
    xproj[0] = x[0] - t * normal[0];
    xproj[1] = x[1] - t * normal[1];
    xproj[2] = x[2] - t * normal[2];
  }
  function projectVector(v, normal, vproj) {
    const t = dot(v, normal);
    let n2 = dot(normal, normal);
    if (n2 === 0) {
      n2 = 1.0;
    }
    vproj[0] = v[0] - t * normal[0] / n2;
    vproj[1] = v[1] - t * normal[1] / n2;
    vproj[2] = v[2] - t * normal[2] / n2;
    return vproj;
  }
  function generalizedProjectPoint(x, origin, normal, xproj) {
    const xo = [];
    subtract(x, origin, xo);
    const t = dot(normal, xo);
    const n2 = dot(normal, normal);
    if (n2 !== 0) {
      xproj[0] = x[0] - t * normal[0] / n2;
      xproj[1] = x[1] - t * normal[1] / n2;
      xproj[2] = x[2] - t * normal[2] / n2;
    } else {
      xproj[0] = x[0];
      xproj[1] = x[1];
      xproj[2] = x[2];
    }
  }
  function intersectWithLine(p1, p2, origin, normal) {
    const outObj = {
      intersection: false,
      betweenPoints: false,
      t: Number.MAX_VALUE,
      x: []
    };
    const p21 = [];
    const p1Origin = [];
    // Compute line vector
    subtract(p2, p1, p21);
    subtract(origin, p1, p1Origin);

    // Compute denominator.  If ~0, line and plane are parallel.
    // const num = vtkMath.dot(normal, origin) - vtkMath.dot(normal, p1);
    const num = dot(normal, p1Origin);
    const den = dot(normal, p21);

    // If denominator with respect to numerator is "zero", then the line and
    // plane are considered parallel.
    let fabsden;
    let fabstolerance;

    // Trying to avoid an expensive call to fabs()
    if (den < 0.0) {
      fabsden = -den;
    } else {
      fabsden = den;
    }
    if (num < 0.0) {
      fabstolerance = -num * PLANE_TOLERANCE;
    } else {
      fabstolerance = num * PLANE_TOLERANCE;
    }
    if (fabsden <= fabstolerance) {
      return outObj;
    }

    // Where on the line between p1 and p2 is the intersection
    // If between 0 and 1, it is between the two points. If < 0 it's before p1, if > 1 it's after p2
    outObj.t = num / den;
    outObj.x[0] = p1[0] + outObj.t * p21[0];
    outObj.x[1] = p1[1] + outObj.t * p21[1];
    outObj.x[2] = p1[2] + outObj.t * p21[2];
    outObj.intersection = true;
    outObj.betweenPoints = outObj.t >= 0.0 && outObj.t <= 1.0;
    return outObj;
  }
  function intersectWithPlane(plane1Origin, plane1Normal, plane2Origin, plane2Normal) {
    const outObj = {
      intersection: false,
      l0: [],
      l1: [],
      error: null
    };
    const cross$1 = [];
    cross(plane1Normal, plane2Normal, cross$1);
    const absCross = cross$1.map(n => Math.abs(n));

    // test if the two planes are parallel
    if (absCross[0] + absCross[1] + absCross[2] < PLANE_TOLERANCE) {
      // test if disjoint or coincide
      const v = [];
      subtract(plane1Origin, plane2Origin, v);
      if (dot(plane1Normal, v) === 0) {
        outObj.error = COINCIDE;
      } else {
        outObj.error = DISJOINT;
      }
      return outObj;
    }

    // Plane1 and Plane2 intersect in a line
    // first determine max abs coordinate of the cross product
    let maxc;
    if (absCross[0] > absCross[1] && absCross[0] > absCross[2]) {
      maxc = 'x';
    } else if (absCross[1] > absCross[2]) {
      maxc = 'y';
    } else {
      maxc = 'z';
    }

    // To get a point on the intersect line, zero the max coord, and solve for the other two
    const iP = []; // intersectionPoint
    // the constants in the 2 plane equations
    const d1 = -dot(plane1Normal, plane1Origin);
    const d2 = -dot(plane2Normal, plane2Origin);

    // eslint-disable-next-line default-case
    switch (maxc) {
      case 'x':
        // intersect with x=0
        iP[0] = 0;
        iP[1] = (d2 * plane1Normal[2] - d1 * plane2Normal[2]) / cross$1[0];
        iP[2] = (d1 * plane2Normal[1] - d2 * plane1Normal[1]) / cross$1[0];
        break;
      case 'y':
        // intersect with y=0
        iP[0] = (d1 * plane2Normal[2] - d2 * plane1Normal[2]) / cross$1[1];
        iP[1] = 0;
        iP[2] = (d2 * plane1Normal[0] - d1 * plane2Normal[0]) / cross$1[1];
        break;
      case 'z':
        // intersect with z=0
        iP[0] = (d2 * plane1Normal[1] - d1 * plane2Normal[1]) / cross$1[2];
        iP[1] = (d1 * plane2Normal[0] - d2 * plane1Normal[0]) / cross$1[2];
        iP[2] = 0;
        break;
    }
    outObj.l0 = iP;
    add(iP, cross$1, outObj.l1);
    outObj.intersection = true;
    return outObj;
  }

  // ----------------------------------------------------------------------------
  // Static API
  // ----------------------------------------------------------------------------

  const STATIC$a = {
    evaluate,
    distanceToPlane,
    projectPoint,
    projectVector,
    generalizedProjectPoint,
    intersectWithLine,
    intersectWithPlane,
    DISJOINT,
    COINCIDE
  };

  // ----------------------------------------------------------------------------
  // vtkPlane methods
  // ----------------------------------------------------------------------------

  function vtkPlane(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkPlane');
    publicAPI.distanceToPlane = x => distanceToPlane(x, model.origin, model.normal);
    publicAPI.projectPoint = (x, xproj) => {
      projectPoint(x, model.origin, model.normal, xproj);
    };
    publicAPI.projectVector = (v, vproj) => projectVector(v, model.normal, vproj);
    publicAPI.push = distance => {
      if (distance === 0.0) {
        return;
      }
      for (let i = 0; i < 3; i++) {
        model.origin[i] += distance * model.normal[i];
      }
    };
    publicAPI.generalizedProjectPoint = (x, xproj) => {
      generalizedProjectPoint(x, model.origin, model.normal, xproj);
    };
    publicAPI.evaluateFunction = (x, y, z) => {
      if (!Array.isArray(x)) {
        return model.normal[0] * (x - model.origin[0]) + model.normal[1] * (y - model.origin[1]) + model.normal[2] * (z - model.origin[2]);
      }
      return model.normal[0] * (x[0] - model.origin[0]) + model.normal[1] * (x[1] - model.origin[1]) + model.normal[2] * (x[2] - model.origin[2]);
    };
    publicAPI.evaluateGradient = xyz => {
      const retVal = [model.normal[0], model.normal[1], model.normal[2]];
      return retVal;
    };
    publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(p1, p2, model.origin, model.normal);
    publicAPI.intersectWithPlane = (planeOrigin, planeNormal) => intersectWithPlane(planeOrigin, planeNormal, model.origin, model.normal);
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1w = {
    normal: [0.0, 0.0, 1.0],
    origin: [0.0, 0.0, 0.0]
  };

  // ----------------------------------------------------------------------------

  function extend$1B(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1w, initialValues);

    // Object methods
    macro.obj(publicAPI, model);
    macro.setGetArray(publicAPI, model, ['normal', 'origin'], 3);
    vtkPlane(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1A = macro.newInstance(extend$1B, 'vtkPlane');

  // ----------------------------------------------------------------------------

  var vtkPlane$1 = {
    newInstance: newInstance$1A,
    extend: extend$1B,
    ...STATIC$a
  };

  const INIT_BOUNDS = [Number.MAX_VALUE, -Number.MAX_VALUE,
  // X
  Number.MAX_VALUE, -Number.MAX_VALUE,
  // Y
  Number.MAX_VALUE, -Number.MAX_VALUE // Z
  ];

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  function equals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
  }
  function isValid(bounds) {
    return bounds?.length >= 6 && bounds[0] <= bounds[1] && bounds[2] <= bounds[3] && bounds[4] <= bounds[5];
  }
  function setBounds(bounds, otherBounds) {
    bounds[0] = otherBounds[0];
    bounds[1] = otherBounds[1];
    bounds[2] = otherBounds[2];
    bounds[3] = otherBounds[3];
    bounds[4] = otherBounds[4];
    bounds[5] = otherBounds[5];
    return bounds;
  }
  function reset(bounds) {
    return setBounds(bounds, INIT_BOUNDS);
  }
  function addPoint(bounds, x, y, z) {
    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
    bounds[0] = xMin < x ? xMin : x;
    bounds[1] = xMax > x ? xMax : x;
    bounds[2] = yMin < y ? yMin : y;
    bounds[3] = yMax > y ? yMax : y;
    bounds[4] = zMin < z ? zMin : z;
    bounds[5] = zMax > z ? zMax : z;
    return bounds;
  }
  function addPoints(bounds, points) {
    if (points.length === 0) {
      return bounds;
    }
    if (Array.isArray(points[0])) {
      for (let i = 0; i < points.length; ++i) {
        addPoint(bounds, ...points[i]);
      }
    } else {
      for (let i = 0; i < points.length; i += 3) {
        addPoint(bounds, ...points.slice(i, i + 3));
      }
    }
    return bounds;
  }
  function addBounds(bounds, xMin, xMax, yMin, yMax, zMin, zMax) {
    const [_xMin, _xMax, _yMin, _yMax, _zMin, _zMax] = bounds;
    if (zMax === undefined) {
      bounds[0] = Math.min(xMin[0], _xMin);
      bounds[1] = Math.max(xMin[1], _xMax);
      bounds[2] = Math.min(xMin[2], _yMin);
      bounds[3] = Math.max(xMin[3], _yMax);
      bounds[4] = Math.min(xMin[4], _zMin);
      bounds[5] = Math.max(xMin[5], _zMax);
    } else {
      bounds[0] = Math.min(xMin, _xMin);
      bounds[1] = Math.max(xMax, _xMax);
      bounds[2] = Math.min(yMin, _yMin);
      bounds[3] = Math.max(yMax, _yMax);
      bounds[4] = Math.min(zMin, _zMin);
      bounds[5] = Math.max(zMax, _zMax);
    }
    return bounds;
  }
  function setMinPoint(bounds, x, y, z) {
    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
    bounds[0] = x;
    bounds[1] = x > xMax ? x : xMax;
    bounds[2] = y;
    bounds[3] = y > yMax ? y : yMax;
    bounds[4] = z;
    bounds[5] = z > zMax ? z : zMax;
    return xMin !== x || yMin !== y || zMin !== z;
  }
  function setMaxPoint(bounds, x, y, z) {
    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
    bounds[0] = x < xMin ? x : xMin;
    bounds[1] = x;
    bounds[2] = y < yMin ? y : yMin;
    bounds[3] = y;
    bounds[4] = z < zMin ? z : zMin;
    bounds[5] = z;
    return xMax !== x || yMax !== y || zMax !== z;
  }
  function inflate(bounds, delta) {
    bounds[0] -= delta;
    bounds[1] += delta;
    bounds[2] -= delta;
    bounds[3] += delta;
    bounds[4] -= delta;
    bounds[5] += delta;
    return bounds;
  }
  function scale(bounds, sx, sy, sz) {
    if (!isValid(bounds)) {
      return false;
    }
    if (sx >= 0.0) {
      bounds[0] *= sx;
      bounds[1] *= sx;
    } else {
      bounds[0] = sx * bounds[1];
      bounds[1] = sx * bounds[0];
    }
    if (sy >= 0.0) {
      bounds[2] *= sy;
      bounds[3] *= sy;
    } else {
      bounds[2] = sy * bounds[3];
      bounds[3] = sy * bounds[2];
    }
    if (sz >= 0.0) {
      bounds[4] *= sz;
      bounds[5] *= sz;
    } else {
      bounds[4] = sz * bounds[5];
      bounds[5] = sz * bounds[4];
    }
    return true;
  }
  function getCenter(bounds) {
    return [0.5 * (bounds[0] + bounds[1]), 0.5 * (bounds[2] + bounds[3]), 0.5 * (bounds[4] + bounds[5])];
  }
  function scaleAboutCenter(bounds, sx, sy, sz) {
    if (!isValid(bounds)) {
      return false;
    }
    const center = getCenter(bounds);
    bounds[0] -= center[0];
    bounds[1] -= center[0];
    bounds[2] -= center[1];
    bounds[3] -= center[1];
    bounds[4] -= center[2];
    bounds[5] -= center[2];
    scale(bounds, sx, sy, sz);
    bounds[0] += center[0];
    bounds[1] += center[0];
    bounds[2] += center[1];
    bounds[3] += center[1];
    bounds[4] += center[2];
    bounds[5] += center[2];
    return true;
  }
  function getLength(bounds, index) {
    return bounds[index * 2 + 1] - bounds[index * 2];
  }
  function getLengths(bounds) {
    return [getLength(bounds, 0), getLength(bounds, 1), getLength(bounds, 2)];
  }
  function getXRange(bounds) {
    return bounds.slice(0, 2);
  }
  function getYRange(bounds) {
    return bounds.slice(2, 4);
  }
  function getZRange(bounds) {
    return bounds.slice(4, 6);
  }
  function getMaxLength(bounds) {
    const l = getLengths(bounds);
    if (l[0] > l[1]) {
      if (l[0] > l[2]) {
        return l[0];
      }
      return l[2];
    }
    if (l[1] > l[2]) {
      return l[1];
    }
    return l[2];
  }
  function getDiagonalLength(bounds) {
    if (isValid(bounds)) {
      const l = getLengths(bounds);
      return Math.sqrt(l[0] * l[0] + l[1] * l[1] + l[2] * l[2]);
    }
    return null;
  }
  function getMinPoint(bounds) {
    return [bounds[0], bounds[2], bounds[4]];
  }
  function getMaxPoint(bounds) {
    return [bounds[1], bounds[3], bounds[5]];
  }
  function oppositeSign(a, b) {
    return a <= 0 && b >= 0 || a >= 0 && b <= 0;
  }
  function getCorners(bounds, corners) {
    let count = 0;
    for (let ix = 0; ix < 2; ix++) {
      for (let iy = 2; iy < 4; iy++) {
        for (let iz = 4; iz < 6; iz++) {
          corners[count++] = [bounds[ix], bounds[iy], bounds[iz]];
        }
      }
    }
    return corners;
  }

  // Computes the two corners with minimal and maximal coordinates
  function computeCornerPoints(bounds, point1, point2) {
    point1[0] = bounds[0];
    point1[1] = bounds[2];
    point1[2] = bounds[4];
    point2[0] = bounds[1];
    point2[1] = bounds[3];
    point2[2] = bounds[5];
    return point1;
  }
  function transformBounds(bounds, transform) {
    let out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    const corners = getCorners(bounds, []);
    for (let i = 0; i < corners.length; ++i) {
      transformMat4$1(corners[i], corners[i], transform);
    }
    reset(out);
    return addPoints(out, corners);
  }
  function computeScale3(bounds) {
    let scale3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    scale3[0] = 0.5 * (bounds[1] - bounds[0]);
    scale3[1] = 0.5 * (bounds[3] - bounds[2]);
    scale3[2] = 0.5 * (bounds[5] - bounds[4]);
    return scale3;
  }

  /**
   * Compute local bounds.
   * Not as fast as vtkPoints.getBounds() if u, v, w form a natural basis.
   * @param {vtkPoints} points
   * @param {array} u first vector
   * @param {array} v second vector
   * @param {array} w third vector
   */
  function computeLocalBounds(points, u, v, w) {
    const bounds = [].concat(INIT_BOUNDS);
    const pointsData = points.getData();
    for (let i = 0; i < pointsData.length; i += 3) {
      const point = [pointsData[i], pointsData[i + 1], pointsData[i + 2]];
      const du = dot(point, u);
      bounds[0] = Math.min(du, bounds[0]);
      bounds[1] = Math.max(du, bounds[1]);
      const dv = dot(point, v);
      bounds[2] = Math.min(dv, bounds[2]);
      bounds[3] = Math.max(dv, bounds[3]);
      const dw = dot(point, w);
      bounds[4] = Math.min(dw, bounds[4]);
      bounds[5] = Math.max(dw, bounds[5]);
    }
    return bounds;
  }

  // The method returns a non-zero value if the bounding box is hit.
  // Origin[3] starts the ray, dir[3] is the vector components of the ray in the x-y-z
  // directions, coord[3] is the location of hit, and t is the parametric
  // coordinate along line. (Notes: the intersection ray dir[3] is NOT
  // normalized.  Valid intersections will only occur between 0<=t<=1.)
  function intersectBox(bounds, origin, dir, coord, tolerance) {
    let inside = true;
    const quadrant = [];
    let whichPlane = 0;
    const maxT = [];
    const candidatePlane = [0.0, 0.0, 0.0];
    const RIGHT = 0;
    const LEFT = 1;
    const MIDDLE = 2;

    // First find closest planes
    for (let i = 0; i < 3; i++) {
      if (origin[i] < bounds[2 * i]) {
        quadrant[i] = LEFT;
        candidatePlane[i] = bounds[2 * i];
        inside = false;
      } else if (origin[i] > bounds[2 * i + 1]) {
        quadrant[i] = RIGHT;
        candidatePlane[i] = bounds[2 * i + 1];
        inside = false;
      } else {
        quadrant[i] = MIDDLE;
      }
    }

    // Check whether origin of ray is inside bbox
    if (inside) {
      coord[0] = origin[0];
      coord[1] = origin[1];
      coord[2] = origin[2];
      tolerance[0] = 0;
      return 1;
    }

    // Calculate parametric distance to plane
    for (let i = 0; i < 3; i++) {
      if (quadrant[i] !== MIDDLE && dir[i] !== 0.0) {
        maxT[i] = (candidatePlane[i] - origin[i]) / dir[i];
      } else {
        maxT[i] = -1.0;
      }
    }

    // Find the largest parametric value of intersection
    for (let i = 0; i < 3; i++) {
      if (maxT[whichPlane] < maxT[i]) {
        whichPlane = i;
      }
    }

    // Check for value intersection along line
    if (maxT[whichPlane] > 1.0 || maxT[whichPlane] < 0.0) {
      return 0;
    }
    tolerance[0] = maxT[whichPlane];

    // Intersection point along line is okay. Check bbox.
    for (let i = 0; i < 3; i++) {
      if (whichPlane !== i) {
        coord[i] = origin[i] + maxT[whichPlane] * dir[i];
        if (coord[i] < bounds[2 * i] || coord[i] > bounds[2 * i + 1]) {
          return 0;
        }
      } else {
        coord[i] = candidatePlane[i];
      }
    }
    return 1;
  }

  // Plane intersection with box
  // The plane is infinite in extent and defined by an origin and normal.The function indicates
  // whether the plane intersects, not the particulars of intersection points and such
  // The function returns non-zero if the plane and box intersect; zero otherwise.
  function intersectPlane(bounds, origin, normal) {
    const p = [];
    let d = 0;
    let sign = 1;
    let firstOne = 1;

    // Evaluate the eight points. If there is a sign change, there is an intersection
    for (let z = 4; z <= 5; ++z) {
      p[2] = bounds[z];
      for (let y = 2; y <= 3; ++y) {
        p[1] = bounds[y];
        for (let x = 0; x <= 1; ++x) {
          p[0] = bounds[x];
          d = vtkPlane$1.evaluate(normal, origin, p);
          if (firstOne) {
            sign = d >= 0 ? 1 : -1;
            firstOne = 0;
          }
          if (d === 0.0 || sign > 0 && d < 0.0 || sign < 0 && d > 0.0) {
            return 1;
          }
        }
      }
    }
    return 0; // no intersection
  }

  function intersect(bounds, bBounds) {
    if (!(isValid(bounds) && isValid(bBounds))) {
      return false;
    }
    const newBounds = [0, 0, 0, 0, 0, 0];
    let intersection;
    for (let i = 0; i < 3; i++) {
      intersection = false;
      if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {
        intersection = true;
        newBounds[i * 2] = bBounds[i * 2];
      } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {
        intersection = true;
        newBounds[i * 2] = bounds[i * 2];
      }
      if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {
        intersection = true;
        newBounds[i * 2 + 1] = bBounds[2 * i + 1];
      } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {
        intersection = true;
        newBounds[i * 2 + 1] = bounds[i * 2 + 1];
      }
      if (!intersection) {
        return false;
      }
    }

    // OK they did intersect - set the box to be the result
    bounds[0] = newBounds[0];
    bounds[1] = newBounds[1];
    bounds[2] = newBounds[2];
    bounds[3] = newBounds[3];
    bounds[4] = newBounds[4];
    bounds[5] = newBounds[5];
    return true;
  }
  function intersects(bounds, bBounds) {
    if (!(isValid(bounds) && isValid(bBounds))) {
      return false;
    }
    /* eslint-disable no-continue */
    for (let i = 0; i < 3; i++) {
      if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {
        continue;
      } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {
        continue;
      }
      if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {
        continue;
      } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {
        continue;
      }
      return false;
    }
    /* eslint-enable no-continue */

    return true;
  }
  function containsPoint(bounds, x, y, z) {
    if (x < bounds[0] || x > bounds[1]) {
      return false;
    }
    if (y < bounds[2] || y > bounds[3]) {
      return false;
    }
    if (z < bounds[4] || z > bounds[5]) {
      return false;
    }
    return true;
  }
  function contains(bounds, otherBounds) {
    // if either box is not valid or they don't intersect
    if (!intersects(bounds, otherBounds)) {
      return false;
    }
    if (!containsPoint(bounds, ...getMinPoint(otherBounds))) {
      return false;
    }
    if (!containsPoint(bounds, ...getMaxPoint(otherBounds))) {
      return false;
    }
    return true;
  }

  /**
   * Returns true if plane intersects bounding box.
   * If so, the box is cut by the plane
   * @param {array} origin
   * @param {array} normal
   */
  function cutWithPlane(bounds, origin, normal) {
    // Index[0..2] represents the order of traversing the corners of a cube
    // in (x,y,z), (y,x,z) and (z,x,y) ordering, respectively
    const index = [[0, 1, 2, 3, 4, 5, 6, 7], [0, 1, 4, 5, 2, 3, 6, 7], [0, 2, 4, 6, 1, 3, 5, 7]];

    // stores the signed distance to a plane
    const d = [0, 0, 0, 0, 0, 0, 0, 0];
    let idx = 0;
    for (let ix = 0; ix < 2; ix++) {
      for (let iy = 2; iy < 4; iy++) {
        for (let iz = 4; iz < 6; iz++) {
          const x = [bounds[ix], bounds[iy], bounds[iz]];
          d[idx++] = vtkPlane$1.evaluate(normal, origin, x);
        }
      }
    }
    let dir = 2;
    while (dir--) {
      // in each direction, we test if the vertices of two orthogonal faces
      // are on either side of the plane
      if (oppositeSign(d[index[dir][0]], d[index[dir][4]]) && oppositeSign(d[index[dir][1]], d[index[dir][5]]) && oppositeSign(d[index[dir][2]], d[index[dir][6]]) && oppositeSign(d[index[dir][3]], d[index[dir][7]])) {
        break;
      }
    }
    if (dir < 0) {
      return false;
    }
    const sign = Math.sign(normal[dir]);
    const size = Math.abs((bounds[dir * 2 + 1] - bounds[dir * 2]) * normal[dir]);
    let t = sign > 0 ? 1 : 0;
    /* eslint-disable no-continue */
    for (let i = 0; i < 4; i++) {
      if (size === 0) {
        continue; // shouldn't happen
      }

      const ti = Math.abs(d[index[dir][i]]) / size;
      if (sign > 0 && ti < t) {
        t = ti;
      }
      if (sign < 0 && ti > t) {
        t = ti;
      }
    }
    /* eslint-enable no-continue */
    const bound = (1.0 - t) * bounds[dir * 2] + t * bounds[dir * 2 + 1];
    if (sign > 0) {
      bounds[dir * 2] = bound;
    } else {
      bounds[dir * 2 + 1] = bound;
    }
    return true;
  }

  // ----------------------------------------------------------------------------
  // Light Weight class
  // ----------------------------------------------------------------------------

  class BoundingBox {
    constructor(refBounds) {
      this.bounds = refBounds;
      if (!this.bounds) {
        this.bounds = new Float64Array(INIT_BOUNDS);
      }
    }
    getBounds() {
      return this.bounds;
    }
    equals(otherBounds) {
      return equals(this.bounds, otherBounds);
    }
    isValid() {
      return isValid(this.bounds);
    }
    setBounds(otherBounds) {
      return setBounds(this.bounds, otherBounds);
    }
    reset() {
      return reset(this.bounds);
    }
    addPoint() {
      for (var _len = arguments.length, xyz = new Array(_len), _key = 0; _key < _len; _key++) {
        xyz[_key] = arguments[_key];
      }
      return addPoint(this.bounds, ...xyz);
    }
    addPoints(points) {
      return addPoints(this.bounds, points);
    }
    addBounds(xMin, xMax, yMin, yMax, zMin, zMax) {
      return addBounds(this.bounds, xMin, xMax, yMin, yMax, zMin, zMax);
    }
    setMinPoint(x, y, z) {
      return setMinPoint(this.bounds, x, y, z);
    }
    setMaxPoint(x, y, z) {
      return setMaxPoint(this.bounds, x, y, z);
    }
    inflate(delta) {
      return inflate(this.bounds, delta);
    }
    scale(sx, sy, sz) {
      return scale(this.bounds, sx, sy, sz);
    }
    getCenter() {
      return getCenter(this.bounds);
    }
    getLength(index) {
      return getLength(this.bounds, index);
    }
    getLengths() {
      return getLengths(this.bounds);
    }
    getMaxLength() {
      return getMaxLength(this.bounds);
    }
    getDiagonalLength() {
      return getDiagonalLength(this.bounds);
    }
    getMinPoint() {
      return getMinPoint(this.bounds);
    }
    getMaxPoint() {
      return getMaxPoint(this.bounds);
    }
    getXRange() {
      return getXRange(this.bounds);
    }
    getYRange() {
      return getYRange(this.bounds);
    }
    getZRange() {
      return getZRange(this.bounds);
    }
    getCorners(corners) {
      return getCorners(this.bounds, corners);
    }
    computeCornerPoints(point1, point2) {
      return computeCornerPoints(this.bounds, point1, point2);
    }
    computeLocalBounds(u, v, w) {
      return computeLocalBounds(this.bounds, u, v, w);
    }
    transformBounds(transform) {
      let out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return transformBounds(this.bounds, transform, out);
    }
    computeScale3(scale3) {
      return computeScale3(this.bounds, scale3);
    }
    cutWithPlane(origin, normal) {
      return cutWithPlane(this.bounds, origin, normal);
    }
    intersectBox(origin, dir, coord, tolerance) {
      return intersectBox(this.bounds, origin, dir, coord, tolerance);
    }
    intersectPlane(origin, normal) {
      return intersectPlane(this.bounds, origin, normal);
    }
    intersect(otherBounds) {
      return intersect(this.bounds, otherBounds);
    }
    intersects(otherBounds) {
      return intersects(this.bounds, otherBounds);
    }
    containsPoint(x, y, z) {
      return containsPoint(this.bounds, x, y, z);
    }
    contains(otherBounds) {
      return intersects(this.bounds, otherBounds);
    }
  }
  function newInstance$1z(initialValues) {
    const bounds = initialValues && initialValues.bounds;
    return new BoundingBox(bounds);
  }

  // ----------------------------------------------------------------------------
  // Static API
  // ----------------------------------------------------------------------------

  const STATIC$9 = {
    equals,
    isValid,
    setBounds,
    reset,
    addPoint,
    addPoints,
    addBounds,
    setMinPoint,
    setMaxPoint,
    inflate,
    scale,
    scaleAboutCenter,
    getCenter,
    getLength,
    getLengths,
    getMaxLength,
    getDiagonalLength,
    getMinPoint,
    getMaxPoint,
    getXRange,
    getYRange,
    getZRange,
    getCorners,
    computeCornerPoints,
    computeLocalBounds,
    transformBounds,
    computeScale3,
    cutWithPlane,
    intersectBox,
    intersectPlane,
    intersect,
    intersects,
    containsPoint,
    contains,
    INIT_BOUNDS
  };
  var vtkBoundingBox = {
    newInstance: newInstance$1z,
    ...STATIC$9
  };

  const CoordinateSystem$5 = {
    DISPLAY: 0,
    WORLD: 1
  };
  var Constants$d = {
    CoordinateSystem: CoordinateSystem$5
  };

  const {
    CoordinateSystem: CoordinateSystem$4
  } = Constants$d;
  function notImplemented$4(method) {
    return () => macro.vtkErrorMacro(`vtkProp::${method} - NOT IMPLEMENTED`);
  }

  // ----------------------------------------------------------------------------
  // vtkProp methods
  // ----------------------------------------------------------------------------

  function vtkProp(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkProp');
    publicAPI.getMTime = () => {
      let m1 = model.mtime;
      for (let index = 0; index < model.textures.length; ++index) {
        const m2 = model.textures[index].getMTime();
        if (m2 > m1) {
          m1 = m2;
        }
      }
      return m1;
    };
    publicAPI.processSelectorPixelBuffers = (selector, pixeloffsets) => {};
    publicAPI.getNestedProps = () => null;
    publicAPI.getActors = () => [];
    publicAPI.getActors2D = () => [];
    publicAPI.getVolumes = () => [];
    publicAPI.pick = notImplemented$4('pick');
    publicAPI.hasKey = notImplemented$4('hasKey');
    publicAPI.getNestedVisibility = () => model.visibility && (!model._parentProp || model._parentProp.getNestedVisibility());
    publicAPI.getNestedPickable = () => model.pickable && (!model._parentProp || model._parentProp.getNestedPickable());
    publicAPI.getNestedDragable = () => model.dragable && (!model._parentProp || model._parentProp.getNestedDragable());
    publicAPI.getRedrawMTime = () => model.mtime;
    publicAPI.setEstimatedRenderTime = t => {
      model.estimatedRenderTime = t;
      model.savedEstimatedRenderTime = t;
    };
    publicAPI.restoreEstimatedRenderTime = () => {
      model.estimatedRenderTime = model.savedEstimatedRenderTime;
    };
    publicAPI.addEstimatedRenderTime = t => {
      model.estimatedRenderTime += t;
    };
    publicAPI.setAllocatedRenderTime = t => {
      model.allocatedRenderTime = t;
      model.savedEstimatedRenderTime = model.estimatedRenderTime;
      model.estimatedRenderTime = 0;
    };
    publicAPI.getSupportsSelection = () => false;
    publicAPI.getTextures = () => model.textures;
    publicAPI.hasTexture = texture => model.textures.indexOf(texture) !== -1;
    publicAPI.addTexture = texture => {
      if (texture && !publicAPI.hasTexture(texture)) {
        model.textures = model.textures.concat(texture);
        publicAPI.modified();
      }
    };
    publicAPI.removeTexture = texture => {
      const newTextureList = model.textures.filter(item => item !== texture);
      if (model.textures.length !== newTextureList.length) {
        model.textures = newTextureList;
        publicAPI.modified();
      }
    };
    publicAPI.removeAllTextures = () => {
      model.textures = [];
      publicAPI.modified();
    };

    // not all mappers support all coordinate systems
    publicAPI.setCoordinateSystemToWorld = () => publicAPI.setCoordinateSystem(CoordinateSystem$4.WORLD);
    publicAPI.setCoordinateSystemToDisplay = () => publicAPI.setCoordinateSystem(CoordinateSystem$4.DISPLAY);
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1v = {
    // _parentProp: null,
    allocatedRenderTime: 10,
    coordinateSystem: CoordinateSystem$4.WORLD,
    dragable: true,
    estimatedRenderTime: 0,
    paths: null,
    pickable: true,
    renderTimeMultiplier: 1,
    savedEstimatedRenderTime: 0,
    textures: [],
    useBounds: true,
    visibility: true
  };

  // ----------------------------------------------------------------------------

  function extend$1A(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1v, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ['estimatedRenderTime', 'allocatedRenderTime']);
    macro.setGet(publicAPI, model, ['_parentProp', 'coordinateSystem', 'dragable', 'pickable', 'renderTimeMultiplier', 'useBounds', 'visibility']);
    macro.moveToProtected(publicAPI, model, ['parentProp']);

    // Object methods
    vtkProp(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1y = macro.newInstance(extend$1A, 'vtkProp');

  // ----------------------------------------------------------------------------

  var vtkProp$1 = {
    newInstance: newInstance$1y,
    extend: extend$1A,
    ...Constants$d
  };

  // ----------------------------------------------------------------------------
  // vtkProp3D methods
  // ----------------------------------------------------------------------------

  function vtkProp3D(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkProp3D');
    publicAPI.addPosition = deltaXYZ => {
      model.position = model.position.map((value, index) => value + deltaXYZ[index]);
      publicAPI.modified();
    };
    publicAPI.getOrientationWXYZ = () => {
      const q = create();
      getRotation(q, model.rotation);
      const oaxis = new Float64Array(3);
      const w = getAxisAngle(oaxis, q);
      return [degreesFromRadians(w), oaxis[0], oaxis[1], oaxis[2]];
    };
    publicAPI.rotateX = val => {
      if (val === 0.0) {
        return;
      }
      rotateX(model.rotation, model.rotation, radiansFromDegrees(val));
      publicAPI.modified();
    };
    publicAPI.rotateY = val => {
      if (val === 0.0) {
        return;
      }
      rotateY(model.rotation, model.rotation, radiansFromDegrees(val));
      publicAPI.modified();
    };
    publicAPI.rotateZ = val => {
      if (val === 0.0) {
        return;
      }
      rotateZ(model.rotation, model.rotation, radiansFromDegrees(val));
      publicAPI.modified();
    };
    publicAPI.rotateWXYZ = (degrees, x, y, z) => {
      if (degrees === 0.0 || x === 0.0 && y === 0.0 && z === 0.0) {
        return;
      }

      // convert to radians
      const angle = radiansFromDegrees(degrees);
      const q = create();
      setAxisAngle(q, [x, y, z], angle);
      const quatMat = new Float64Array(16);
      fromQuat(quatMat, q);
      multiply$1(model.rotation, model.rotation, quatMat);
      publicAPI.modified();
    };
    publicAPI.setOrientation = (x, y, z) => {
      if (x === model.orientation[0] && y === model.orientation[1] && z === model.orientation[2]) {
        return false;
      }
      model.orientation = [x, y, z];
      identity$3(model.rotation);
      publicAPI.rotateZ(z);
      publicAPI.rotateX(x);
      publicAPI.rotateY(y);
      publicAPI.modified();
      return true;
    };
    publicAPI.setUserMatrix = matrix => {
      if (areMatricesEqual(model.userMatrix, matrix)) {
        return false;
      }
      copy$1(model.userMatrix, matrix);
      publicAPI.modified();
      return true;
    };
    publicAPI.getMatrix = () => {
      publicAPI.computeMatrix();
      return model.matrix;
    };
    publicAPI.computeMatrix = () => {
      // check whether or not need to rebuild the matrix
      if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
        identity$3(model.matrix);
        if (model.userMatrix) {
          multiply$1(model.matrix, model.matrix, model.userMatrix);
        }
        translate(model.matrix, model.matrix, model.origin);
        translate(model.matrix, model.matrix, model.position);
        multiply$1(model.matrix, model.matrix, model.rotation);
        scale$2(model.matrix, model.matrix, model.scale);
        translate(model.matrix, model.matrix, [-model.origin[0], -model.origin[1], -model.origin[2]]);
        transpose(model.matrix, model.matrix);

        // check for identity
        model.isIdentity = true;
        for (let i = 0; i < 4; ++i) {
          for (let j = 0; j < 4; ++j) {
            if ((i === j ? 1.0 : 0.0) !== model.matrix[i + j * 4]) {
              model.isIdentity = false;
            }
          }
        }
        model.matrixMTime.modified();
      }
    };
    publicAPI.getCenter = () => vtkBoundingBox.getCenter(model.bounds);
    publicAPI.getLength = () => vtkBoundingBox.getLength(model.bounds);
    publicAPI.getXRange = () => vtkBoundingBox.getXRange(model.bounds);
    publicAPI.getYRange = () => vtkBoundingBox.getYRange(model.bounds);
    publicAPI.getZRange = () => vtkBoundingBox.getZRange(model.bounds);
    publicAPI.getUserMatrix = () => model.userMatrix;
    function updateIdentityFlag() {
      publicAPI.computeMatrix();
    }
    publicAPI.onModified(updateIdentityFlag);
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1u = {
    origin: [0, 0, 0],
    position: [0, 0, 0],
    orientation: [0, 0, 0],
    rotation: null,
    scale: [1, 1, 1],
    bounds: [1, -1, 1, -1, 1, -1],
    userMatrix: null,
    userMatrixMTime: null,
    cachedProp3D: null,
    isIdentity: true,
    matrixMTime: null
  };

  // ----------------------------------------------------------------------------

  function extend$1z(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1u, initialValues);

    // Inheritance
    vtkProp$1.extend(publicAPI, model, initialValues);
    model.matrixMTime = {};
    macro.obj(model.matrixMTime);

    // Build VTK API
    macro.get(publicAPI, model, ['bounds', 'isIdentity']);
    macro.getArray(publicAPI, model, ['orientation']);
    macro.setGetArray(publicAPI, model, ['origin', 'position', 'scale'], 3);

    // Object internal instance
    model.matrix = identity$3(new Float64Array(16));
    model.rotation = identity$3(new Float64Array(16));
    model.userMatrix = identity$3(new Float64Array(16));
    model.transform = null; // FIXME

    // Object methods
    vtkProp3D(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1x = macro.newInstance(extend$1z, 'vtkProp3D');

  // ----------------------------------------------------------------------------

  var vtkProp3D$1 = {
    newInstance: newInstance$1x,
    extend: extend$1z
  };

  const Shading$1 = {
    FLAT: 0,
    GOURAUD: 1,
    PHONG: 2
  };
  const Representation$6 = {
    POINTS: 0,
    WIREFRAME: 1,
    SURFACE: 2
  };
  const Interpolation$1 = Shading$1;
  var PropertyConst = {
    Shading: Shading$1,
    Representation: Representation$6,
    Interpolation: Interpolation$1
  };

  const {
    Representation: Representation$5,
    Interpolation
  } = PropertyConst;
  function notImplemented$3(method) {
    return () => macro.vtkErrorMacro(`vtkProperty::${method} - NOT IMPLEMENTED`);
  }

  // ----------------------------------------------------------------------------
  // vtkProperty methods
  // ----------------------------------------------------------------------------

  function vtkProperty(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkProperty');
    publicAPI.setColor = (r, g, b) => {
      if (Array.isArray(r)) {
        if (model.color[0] !== r[0] || model.color[1] !== r[1] || model.color[2] !== r[2]) {
          model.color[0] = r[0];
          model.color[1] = r[1];
          model.color[2] = r[2];
          publicAPI.modified();
        }
      } else if (model.color[0] !== r || model.color[1] !== g || model.color[2] !== b) {
        model.color[0] = r;
        model.color[1] = g;
        model.color[2] = b;
        publicAPI.modified();
      }
      publicAPI.setDiffuseColor(model.color);
      publicAPI.setAmbientColor(model.color);
      publicAPI.setSpecularColor(model.color);
    };
    publicAPI.computeCompositeColor = notImplemented$3('ComputeCompositeColor');
    publicAPI.getColor = () => {
      // Inline computeCompositeColor
      let norm = 0.0;
      if (model.ambient + model.diffuse + model.specular > 0) {
        norm = 1.0 / (model.ambient + model.diffuse + model.specular);
      }
      for (let i = 0; i < 3; i++) {
        model.color[i] = norm * (model.ambient * model.ambientColor[i] + model.diffuse * model.diffuseColor[i] + model.specular * model.specularColor[i]);
      }
      return [].concat(model.color);
    };
    publicAPI.setSpecularPower = specularPower => {
      const roughness = 1 / Math.max(1.0, specularPower);
      if (model.roughness !== roughness || model.specularPower !== specularPower) {
        model.specularPower = specularPower; // Specular power still needs to be set as long as webgl is using it (otherwise testShaderReplacementsClear fails)
        model.roughness = roughness;
        publicAPI.modified();
      }
    };
    publicAPI.addShaderVariable = notImplemented$3('AddShaderVariable');
    publicAPI.setInterpolationToFlat = () => publicAPI.setInterpolation(Interpolation.FLAT);
    publicAPI.setInterpolationToGouraud = () => publicAPI.setInterpolation(Interpolation.GOURAUD);
    publicAPI.setInterpolationToPhong = () => publicAPI.setInterpolation(Interpolation.PHONG);
    publicAPI.getInterpolationAsString = () => macro.enumToString(Interpolation, model.interpolation);
    publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation$5.WIREFRAME);
    publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation$5.SURFACE);
    publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation$5.POINTS);
    publicAPI.getRepresentationAsString = () => macro.enumToString(Representation$5, model.representation);
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1t = {
    color: [1, 1, 1],
    ambientColor: [1, 1, 1],
    diffuseColor: [1, 1, 1],
    specularColor: [1, 1, 1],
    edgeColor: [0, 0, 0],
    ambient: 0,
    diffuse: 1,
    metallic: 0,
    roughness: 0.6,
    normalStrength: 1,
    emission: 1,
    baseIOR: 1.45,
    specular: 0,
    specularPower: 1,
    opacity: 1,
    interpolation: Interpolation.GOURAUD,
    representation: Representation$5.SURFACE,
    edgeVisibility: false,
    backfaceCulling: false,
    frontfaceCulling: false,
    pointSize: 1,
    lineWidth: 1,
    lighting: true,
    shading: false,
    materialName: null
  };

  // ----------------------------------------------------------------------------

  function extend$1y(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1t, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ['lighting', 'interpolation', 'ambient', 'diffuse', 'metallic', 'roughness', 'normalStrength', 'emission', 'baseIOR', 'specular', 'specularPower', 'opacity', 'edgeVisibility', 'lineWidth', 'pointSize', 'backfaceCulling', 'frontfaceCulling', 'representation', 'diffuseTexture', 'metallicTexture', 'roughnessTexture', 'normalTexture', 'ambientOcclusionTexture', 'emissionTexture']);
    macro.setGetArray(publicAPI, model, ['ambientColor', 'specularColor', 'diffuseColor', 'edgeColor'], 3);

    // Object methods
    vtkProperty(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1w = macro.newInstance(extend$1y, 'vtkProperty');

  // ----------------------------------------------------------------------------

  var vtkProperty$1 = {
    newInstance: newInstance$1w,
    extend: extend$1y,
    ...PropertyConst
  };

  const {
    vtkDebugMacro: vtkDebugMacro$7
  } = macro;

  // ----------------------------------------------------------------------------
  // vtkActor methods
  // ----------------------------------------------------------------------------

  function vtkActor(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkActor');

    // Capture 'parentClass' api for internal use
    const superClass = {
      ...publicAPI
    };
    publicAPI.getActors = () => [publicAPI];
    publicAPI.getIsOpaque = () => {
      if (model.forceOpaque) {
        return true;
      }
      if (model.forceTranslucent) {
        return false;
      }
      // make sure we have a property
      if (!model.property) {
        // force creation of a property
        publicAPI.getProperty();
      }
      let isOpaque = model.property.getOpacity() >= 1.0;

      // are we using an opaque texture, if any?
      isOpaque = isOpaque && (!model.texture || !model.texture.isTranslucent());

      // are we using an opaque scalar array, if any?
      isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
      return isOpaque;
    };
    publicAPI.hasTranslucentPolygonalGeometry = () => {
      if (model.mapper === null) {
        return false;
      }
      // make sure we have a property
      if (model.property === null) {
        // force creation of a property
        publicAPI.setProperty(publicAPI.makeProperty());
      }

      // is this actor opaque ?
      return !publicAPI.getIsOpaque();
    };
    publicAPI.makeProperty = vtkProperty$1.newInstance;
    publicAPI.getProperty = () => {
      if (model.property === null) {
        model.property = publicAPI.makeProperty();
      }
      return model.property;
    };
    publicAPI.getBounds = () => {
      if (model.mapper === null) {
        return model.bounds;
      }

      // Check for the special case when the mapper's bounds are unknown
      const bds = model.mapper.getBounds();
      if (!bds || bds.length !== 6) {
        return bds;
      }

      // Check for the special case when the actor is empty.
      if (bds[0] > bds[1]) {
        model.mapperBounds = bds.concat(); // copy the mapper's bounds
        model.bounds = [1, -1, 1, -1, 1, -1];
        model.boundsMTime.modified();
        return bds;
      }

      // Check if we have cached values for these bounds - we cache the
      // values returned by model.mapper.getBounds() and we store the time
      // of caching. If the values returned this time are different, or
      // the modified time of this class is newer than the cached time,
      // then we need to rebuild.
      if (!model.mapperBounds || bds[0] !== model.mapperBounds[0] || bds[1] !== model.mapperBounds[1] || bds[2] !== model.mapperBounds[2] || bds[3] !== model.mapperBounds[3] || bds[4] !== model.mapperBounds[4] || bds[5] !== model.mapperBounds[5] || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
        vtkDebugMacro$7('Recomputing bounds...');
        model.mapperBounds = bds.concat(); // copy the mapper's bounds
        const bbox = [];
        vtkBoundingBox.getCorners(bds, bbox);
        publicAPI.computeMatrix();
        const tmp4 = new Float64Array(16);
        transpose(tmp4, model.matrix);
        bbox.forEach(pt => transformMat4$1(pt, pt, tmp4));

        /* eslint-disable no-multi-assign */
        model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
        model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
        /* eslint-enable no-multi-assign */

        model.bounds = model.bounds.map((d, i) => i % 2 === 0 ? bbox.reduce((a, b) => a > b[i / 2] ? b[i / 2] : a, d) : bbox.reduce((a, b) => a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a, d));
        model.boundsMTime.modified();
      }
      return model.bounds;
    };
    publicAPI.getMTime = () => {
      let mt = superClass.getMTime();
      if (model.property !== null) {
        const time = model.property.getMTime();
        mt = time > mt ? time : mt;
      }
      if (model.backfaceProperty !== null) {
        const time = model.backfaceProperty.getMTime();
        mt = time > mt ? time : mt;
      }
      return mt;
    };
    publicAPI.getRedrawMTime = () => {
      let mt = model.mtime;
      if (model.mapper !== null) {
        let time = model.mapper.getMTime();
        mt = time > mt ? time : mt;
        if (model.mapper.getInput() !== null) {
          // FIXME !!! getInputAlgorithm / getInput
          model.mapper.getInputAlgorithm().update();
          time = model.mapper.getInput().getMTime();
          mt = time > mt ? time : mt;
        }
      }
      return mt;
    };
    publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
    publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
      if (model.mapper && model.mapper.processSelectorPixelBuffers) {
        model.mapper.processSelectorPixelBuffers(selector, pixelOffsets);
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1s = {
    mapper: null,
    property: null,
    backfaceProperty: null,
    forceOpaque: false,
    forceTranslucent: false,
    bounds: [1, -1, 1, -1, 1, -1]
  };

  // ----------------------------------------------------------------------------

  function extend$1x(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1s, initialValues);

    // Inheritance
    vtkProp3D$1.extend(publicAPI, model, initialValues);

    // vtkTimeStamp
    model.boundsMTime = {};
    macro.obj(model.boundsMTime);

    // Build VTK API
    macro.set(publicAPI, model, ['property']);
    macro.setGet(publicAPI, model, ['backfaceProperty', 'forceOpaque', 'forceTranslucent', 'mapper']);

    // Object methods
    vtkActor(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1v = macro.newInstance(extend$1x, 'vtkActor');

  // ----------------------------------------------------------------------------

  var vtkActor$1 = {
    newInstance: newInstance$1v,
    extend: extend$1x
  };

  const DataTypeByteSize = {
    Int8Array: 1,
    Uint8Array: 1,
    Uint8ClampedArray: 1,
    Int16Array: 2,
    Uint16Array: 2,
    Int32Array: 4,
    Uint32Array: 4,
    Float32Array: 4,
    Float64Array: 8
  };
  const VtkDataTypes$5 = {
    VOID: '',
    // not sure to know what that should be
    CHAR: 'Int8Array',
    SIGNED_CHAR: 'Int8Array',
    UNSIGNED_CHAR: 'Uint8Array',
    SHORT: 'Int16Array',
    UNSIGNED_SHORT: 'Uint16Array',
    INT: 'Int32Array',
    UNSIGNED_INT: 'Uint32Array',
    FLOAT: 'Float32Array',
    DOUBLE: 'Float64Array'
  };
  const DefaultDataType$1 = VtkDataTypes$5.FLOAT;
  var Constants$c = {
    DefaultDataType: DefaultDataType$1,
    DataTypeByteSize,
    VtkDataTypes: VtkDataTypes$5
  };

  const {
    vtkErrorMacro: vtkErrorMacro$s
  } = macro$1;
  const {
    DefaultDataType
  } = Constants$c;

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------
  const EPSILON$1 = 1e-6;

  // Original source from https://www.npmjs.com/package/compute-range
  // Modified to accept type arrays
  function fastComputeRange(arr, offset, numberOfComponents) {
    const len = arr.length;
    let min = Number.MAX_VALUE;
    let max = -Number.MAX_VALUE;
    let x;
    let i;

    // find first non-NaN value
    for (i = offset; i < len; i += numberOfComponents) {
      if (!Number.isNaN(arr[i])) {
        min = arr[i];
        max = min;
        break;
      }
    }
    for (; i < len; i += numberOfComponents) {
      x = arr[i];
      if (x < min) {
        min = x;
      } else if (x > max) {
        max = x;
      }
    }
    return {
      min,
      max
    };
  }

  /**
   * @deprecated please use fastComputeRange instead
   */
  function createRangeHelper() {
    let min = Number.MAX_VALUE;
    let max = -Number.MAX_VALUE;
    let count = 0;
    let sum = 0;
    return {
      add(value) {
        if (min > value) {
          min = value;
        }
        if (max < value) {
          max = value;
        }
        count++;
        sum += value;
      },
      get() {
        return {
          min,
          max,
          count,
          sum,
          mean: sum / count
        };
      },
      getRange() {
        return {
          min,
          max
        };
      }
    };
  }
  function computeRange(values) {
    let component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let numberOfComponents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    if (component < 0 && numberOfComponents > 1) {
      // Compute magnitude
      const size = values.length;
      const numberOfValues = size / numberOfComponents;
      const data = new Float64Array(numberOfValues);
      for (let i = 0, j = 0; i < numberOfValues; ++i) {
        for (let nextJ = j + numberOfComponents; j < nextJ; ++j) {
          data[i] += values[j] * values[j];
        }
        data[i] **= 0.5;
      }
      return fastComputeRange(data, 0, 1);
    }
    return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);
  }
  function ensureRangeSize(rangeArray) {
    let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const ranges = rangeArray || [];
    // Pad ranges with null value to get the
    while (ranges.length <= size) {
      ranges.push(null);
    }
    return ranges;
  }
  function getDataType(typedArray) {
    // Expects toString() to return "[object ...Array]"
    return Object.prototype.toString.call(typedArray).slice(8, -1);
  }
  function getMaxNorm(normArray) {
    const numComps = normArray.getNumberOfComponents();
    let maxNorm = 0.0;
    const tuple = new Array(numComps);
    for (let i = 0; i < normArray.getNumberOfTuples(); ++i) {
      normArray.getTuple(i, tuple);
      const norm$1 = norm(tuple, numComps);
      if (norm$1 > maxNorm) {
        maxNorm = norm$1;
      }
    }
    return maxNorm;
  }

  // ----------------------------------------------------------------------------
  // Static API
  // ----------------------------------------------------------------------------

  const STATIC$8 = {
    computeRange,
    createRangeHelper,
    fastComputeRange,
    getDataType,
    getMaxNorm
  };

  // ----------------------------------------------------------------------------
  // vtkDataArray methods
  // ----------------------------------------------------------------------------

  function vtkDataArray(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkDataArray');

    /**
     * Resize model.values and copy the old values to the new array.
     * @param {Number} requestedNumTuples Final expected number of tuples; must be >= 0
     * @returns {Boolean} True if a resize occured, false otherwise
     */
    function resize(requestedNumTuples) {
      if (requestedNumTuples < 0) {
        return false;
      }
      const numComps = publicAPI.getNumberOfComponents();
      const curNumTuples = model.values.length / (numComps > 0 ? numComps : 1);
      if (requestedNumTuples === curNumTuples) {
        return true;
      }
      if (requestedNumTuples > curNumTuples) {
        // Requested size is bigger than current size.  Allocate enough
        // memory to fit the requested size and be more than double the
        // currently allocated memory.
        const oldValues = model.values;
        model.values = newTypedArray(model.dataType, (requestedNumTuples + curNumTuples) * numComps);
        model.values.set(oldValues);
        return true;
      }

      // Requested size is smaller than currently allocated size
      if (model.size > requestedNumTuples * numComps) {
        model.size = requestedNumTuples * numComps;
        publicAPI.dataChange();
      }
      return true;
    }
    publicAPI.dataChange = () => {
      model.ranges = null;
      publicAPI.modified();
    };
    publicAPI.resize = requestedNumTuples => {
      resize(requestedNumTuples);
      const newSize = requestedNumTuples * publicAPI.getNumberOfComponents();
      if (model.size !== newSize) {
        model.size = newSize;
        publicAPI.dataChange();
        return true;
      }
      return false;
    };

    // FIXME, to rename into "clear()" or "reset()"
    publicAPI.initialize = () => {
      publicAPI.resize(0);
    };
    publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;

    // Description:
    // Return the data component at the location specified by tupleIdx and
    // compIdx.
    publicAPI.getComponent = function (tupleIdx) {
      let compIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return model.values[tupleIdx * model.numberOfComponents + compIdx];
    };

    // Description:
    // Set the data component at the location specified by tupleIdx and compIdx
    // to value.
    // Note that i is less than NumberOfTuples and j is less than
    //  NumberOfComponents. Make sure enough memory has been allocated
    // (use SetNumberOfTuples() and SetNumberOfComponents()).
    publicAPI.setComponent = (tupleIdx, compIdx, value) => {
      if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
        model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
        publicAPI.dataChange();
      }
    };
    publicAPI.getValue = valueIdx => {
      const idx = valueIdx / model.numberOfComponents;
      const comp = valueIdx % model.numberOfComponents;
      return publicAPI.getComponent(idx, comp);
    };
    publicAPI.setValue = (valueIdx, value) => {
      const idx = valueIdx / model.numberOfComponents;
      const comp = valueIdx % model.numberOfComponents;
      publicAPI.setComponent(idx, comp, value);
    };
    publicAPI.getData = () => model.size === model.values.length ? model.values : model.values.subarray(0, model.size);
    publicAPI.getRange = function () {
      let componentIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      let rangeIdx = componentIndex;
      if (rangeIdx < 0) {
        // If scalar data, then store in slot 0 (same as componentIndex = 0).
        // If vector data, then store in last slot.
        rangeIdx = model.numberOfComponents === 1 ? 0 : model.numberOfComponents;
      }
      let range = null;
      if (!model.ranges) {
        model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
      }
      range = model.ranges[rangeIdx];
      if (range) {
        model.rangeTuple[0] = range.min;
        model.rangeTuple[1] = range.max;
        return model.rangeTuple;
      }

      // Need to compute ranges...
      range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);
      model.ranges[rangeIdx] = range;
      model.rangeTuple[0] = range.min;
      model.rangeTuple[1] = range.max;
      return model.rangeTuple;
    };
    publicAPI.setRange = (rangeValue, componentIndex) => {
      if (!model.ranges) {
        model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
      }
      const range = {
        min: rangeValue.min,
        max: rangeValue.max
      };
      model.ranges[componentIndex] = range;
      model.rangeTuple[0] = range.min;
      model.rangeTuple[1] = range.max;
      return model.rangeTuple;
    };
    publicAPI.setTuple = (idx, tuple) => {
      const offset = idx * model.numberOfComponents;
      for (let i = 0; i < model.numberOfComponents; i++) {
        model.values[offset + i] = tuple[i];
      }
    };
    publicAPI.setTuples = (idx, tuples) => {
      let i = idx * model.numberOfComponents;
      const last = Math.min(tuples.length, model.size - i);
      for (let j = 0; j < last;) {
        model.values[i++] = tuples[j++];
      }
    };
    publicAPI.insertTuple = (idx, tuple) => {
      if (model.size <= idx * model.numberOfComponents) {
        model.size = (idx + 1) * model.numberOfComponents;
        resize(idx + 1);
      }
      publicAPI.setTuple(idx, tuple);
      return idx;
    };
    publicAPI.insertTuples = (idx, tuples) => {
      const end = idx + tuples.length / model.numberOfComponents;
      if (model.size < end * model.numberOfComponents) {
        model.size = end * model.numberOfComponents;
        resize(end);
      }
      publicAPI.setTuples(idx, tuples);
      return end;
    };
    publicAPI.insertNextTuple = tuple => {
      const idx = model.size / model.numberOfComponents;
      return publicAPI.insertTuple(idx, tuple);
    };
    publicAPI.insertNextTuples = tuples => {
      const idx = model.size / model.numberOfComponents;
      return publicAPI.insertTuples(idx, tuples);
    };
    publicAPI.findTuple = function (tuple) {
      let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSILON$1;
      for (let i = 0; i < model.size; i += model.numberOfComponents) {
        if (Math.abs(tuple[0] - model.values[i]) <= precision) {
          let match = true;
          for (let j = 1; j < model.numberOfComponents; ++j) {
            if (Math.abs(tuple[j] - model.values[i + j]) > precision) {
              match = false;
              break;
            }
          }
          if (match) {
            return i / model.numberOfComponents;
          }
        }
      }
      return -1;
    };
    publicAPI.getTuple = function (idx) {
      let tupleToFill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      const numberOfComponents = model.numberOfComponents || 1;
      const offset = idx * numberOfComponents;
      // Check most common component sizes first
      // to avoid doing a for loop if possible
      switch (numberOfComponents) {
        case 4:
          tupleToFill[3] = model.values[offset + 3];
        // eslint-disable-next-line no-fallthrough
        case 3:
          tupleToFill[2] = model.values[offset + 2];
        // eslint-disable-next-line no-fallthrough
        case 2:
          tupleToFill[1] = model.values[offset + 1];
        // eslint-disable-next-line no-fallthrough
        case 1:
          tupleToFill[0] = model.values[offset];
          break;
        default:
          for (let i = numberOfComponents - 1; i >= 0; --i) {
            tupleToFill[i] = model.values[offset + i];
          }
      }
      return tupleToFill;
    };
    publicAPI.getTuples = (fromId, toId) => {
      const from = (fromId ?? 0) * model.numberOfComponents;
      const to = (toId ?? publicAPI.getNumberOfTuples()) * model.numberOfComponents;
      const arr = publicAPI.getData().subarray(from, to);
      return arr.length > 0 ? arr : null;
    };
    publicAPI.getTupleLocation = function () {
      let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return idx * model.numberOfComponents;
    };
    publicAPI.getNumberOfComponents = () => model.numberOfComponents;
    publicAPI.getNumberOfValues = () => model.size;
    publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;
    publicAPI.getDataType = () => model.dataType;
    /* eslint-disable no-use-before-define */
    publicAPI.newClone = () => newInstance$1u({
      empty: true,
      name: model.name,
      dataType: model.dataType,
      numberOfComponents: model.numberOfComponents
    });
    /* eslint-enable no-use-before-define */

    publicAPI.getName = () => {
      if (!model.name) {
        publicAPI.modified();
        model.name = `vtkDataArray${publicAPI.getMTime()}`;
      }
      return model.name;
    };
    publicAPI.setData = (typedArray, numberOfComponents) => {
      model.values = typedArray;
      model.size = typedArray.length;
      model.dataType = getDataType(typedArray);
      if (numberOfComponents) {
        model.numberOfComponents = numberOfComponents;
      }
      if (model.size % model.numberOfComponents !== 0) {
        model.numberOfComponents = 1;
      }
      publicAPI.dataChange();
    };

    // Override serialization support
    publicAPI.getState = () => {
      if (model.deleted) {
        return null;
      }
      const jsonArchive = {
        ...model,
        vtkClass: publicAPI.getClassName()
      };

      // Convert typed array to regular array
      jsonArchive.values = Array.from(jsonArchive.values);
      delete jsonArchive.buffer;

      // Clean any empty data
      Object.keys(jsonArchive).forEach(keyName => {
        if (!jsonArchive[keyName]) {
          delete jsonArchive[keyName];
        }
      });

      // Sort resulting object by key name
      const sortedObj = {};
      Object.keys(jsonArchive).sort().forEach(name => {
        sortedObj[name] = jsonArchive[name];
      });

      // Remove mtime
      if (sortedObj.mtime) {
        delete sortedObj.mtime;
      }
      return sortedObj;
    };
    publicAPI.deepCopy = other => {
      // Retain current dataType and array reference before shallowCopy call.
      const currentType = publicAPI.getDataType();
      const currentArray = model.values;
      publicAPI.shallowCopy(other);

      // Avoid array reallocation if size already sufficient
      // and dataTypes match.
      if (currentArray?.length >= other.getNumberOfValues() && currentType === other.getDataType()) {
        currentArray.set(other.getData());
        model.values = currentArray;
        publicAPI.dataChange();
      } else {
        publicAPI.setData(other.getData().slice());
      }
    };
    publicAPI.interpolateTuple = (idx, source1, source1Idx, source2, source2Idx, t) => {
      const numberOfComponents = model.numberOfComponents || 1;
      if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {
        vtkErrorMacro$s('numberOfComponents must match');
      }
      const tuple1 = source1.getTuple(source1Idx);
      const tuple2 = source2.getTuple(source2Idx);
      const out = [];
      out.length = numberOfComponents;

      // Check most common component sizes first
      // to avoid doing a for loop if possible
      switch (numberOfComponents) {
        case 4:
          out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;
        // eslint-disable-next-line no-fallthrough
        case 3:
          out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;
        // eslint-disable-next-line no-fallthrough
        case 2:
          out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;
        // eslint-disable-next-line no-fallthrough
        case 1:
          out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;
          break;
        default:
          for (let i = 0; i < numberOfComponents; i++) {
            out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;
          }
      }
      return publicAPI.insertTuple(idx, out);
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  // size: The current size of the dataArray.
  // NOTE: The underlying typed array may be larger than 'size'.
  const DEFAULT_VALUES$1r = {
    name: '',
    numberOfComponents: 1,
    dataType: DefaultDataType,
    rangeTuple: [0, 0]
    // size: undefined,
    // values: null,
    // ranges: null,
  };

  // ----------------------------------------------------------------------------

  function extend$1w(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1r, initialValues);
    if (!model.empty && !model.values && !model.size) {
      throw new TypeError('Cannot create vtkDataArray object without: size > 0, values');
    }
    if (!model.values) {
      model.values = newTypedArray(model.dataType, model.size);
    } else if (Array.isArray(model.values)) {
      model.values = newTypedArrayFrom(model.dataType, model.values);
    }
    if (model.values) {
      // Takes the size if provided (can be lower than `model.values`) otherwise the actual length of `values`.
      model.size = model.size ?? model.values.length;
      model.dataType = getDataType(model.values);
    }

    // Object methods
    obj(publicAPI, model);
    set(publicAPI, model, ['name', 'numberOfComponents']);
    if (model.size % model.numberOfComponents !== 0) {
      throw new RangeError('model.size is not a multiple of model.numberOfComponents');
    }

    // Object specific methods
    vtkDataArray(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1u = newInstance$1I(extend$1w, 'vtkDataArray');

  // ----------------------------------------------------------------------------

  var vtkDataArray$1 = {
    newInstance: newInstance$1u,
    extend: extend$1w,
    ...STATIC$8,
    ...Constants$c
  };

  // ----------------------------------------------------------------------------
  // vtkAbstractMapper methods
  // ----------------------------------------------------------------------------

  function vtkAbstractMapper(publicAPI, model) {
    model.classHierarchy.push('vtkAbstractMapper');
    publicAPI.update = () => {
      publicAPI.getInputData();
    };
    publicAPI.addClippingPlane = plane => {
      if (!plane.isA('vtkPlane')) {
        return false;
      }
      if (!model.clippingPlanes.includes(plane)) {
        model.clippingPlanes.push(plane);
        publicAPI.modified();
        return true;
      }
      return false;
    };
    publicAPI.getNumberOfClippingPlanes = () => model.clippingPlanes.length;
    publicAPI.removeAllClippingPlanes = () => {
      if (model.clippingPlanes.length === 0) {
        return false;
      }
      model.clippingPlanes.length = 0;
      publicAPI.modified();
      return true;
    };
    publicAPI.removeClippingPlane = clippingPlane => {
      const i = model.clippingPlanes.indexOf(clippingPlane);
      if (i === -1) {
        return false;
      }
      model.clippingPlanes.splice(i, 1);
      publicAPI.modified();
      return true;
    };
    publicAPI.getClippingPlanes = () => model.clippingPlanes;
    publicAPI.setClippingPlanes = planes => {
      if (!planes) {
        return;
      }
      if (!Array.isArray(planes)) {
        publicAPI.addClippingPlane(planes);
      } else {
        const nbPlanes = planes.length;
        for (let i = 0; i < nbPlanes && i < 6; i++) {
          publicAPI.addClippingPlane(planes[i]);
        }
      }
    };
    publicAPI.getClippingPlaneInDataCoords = (propMatrix, i, hnormal) => {
      const clipPlanes = model.clippingPlanes;
      const mat = propMatrix;
      if (clipPlanes) {
        const n = clipPlanes.length;
        if (i >= 0 && i < n) {
          // Get the plane
          const plane = clipPlanes[i];
          const normal = plane.getNormal();
          const origin = plane.getOrigin();

          // Compute the plane equation
          const v1 = normal[0];
          const v2 = normal[1];
          const v3 = normal[2];
          const v4 = -(v1 * origin[0] + v2 * origin[1] + v3 * origin[2]);

          // Transform normal from world to data coords
          hnormal[0] = v1 * mat[0] + v2 * mat[4] + v3 * mat[8] + v4 * mat[12];
          hnormal[1] = v1 * mat[1] + v2 * mat[5] + v3 * mat[9] + v4 * mat[13];
          hnormal[2] = v1 * mat[2] + v2 * mat[6] + v3 * mat[10] + v4 * mat[14];
          hnormal[3] = v1 * mat[3] + v2 * mat[7] + v3 * mat[11] + v4 * mat[15];
          return;
        }
      }
      macro.vtkErrorMacro(`Clipping plane index ${i} is out of range.`);
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1q = {
    clippingPlanes: []
  };

  // ----------------------------------------------------------------------------

  function extend$1v(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1q, initialValues);

    // Object methods
    macro.obj(publicAPI, model);
    macro.algo(publicAPI, model, 1, 0);
    if (!model.clippingPlanes) {
      model.clippingPlanes = [];
    }
    vtkAbstractMapper(publicAPI, model);
  }

  // ----------------------------------------------------------------------------
  var vtkAbstractMapper$1 = {
    extend: extend$1v
  };

  // ----------------------------------------------------------------------------
  // vtkAbstractMapper methods
  // ----------------------------------------------------------------------------

  function vtkAbstractMapper3D(publicAPI, model) {
    publicAPI.getBounds = () => {
      macro.vtkErrorMacro(`vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED`);
      return createUninitializedBounds();
    };
    publicAPI.getCenter = () => {
      const bounds = publicAPI.getBounds();
      model.center = vtkBoundingBox.isValid(bounds) ? vtkBoundingBox.getCenter(bounds) : null;
      return model.center?.slice();
    };
    publicAPI.getLength = () => {
      const bounds = publicAPI.getBounds();
      return vtkBoundingBox.getDiagonalLength(bounds);
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const defaultValues$4 = initialValues => ({
    bounds: [...vtkBoundingBox.INIT_BOUNDS],
    center: [0, 0, 0],
    viewSpecificProperties: {},
    ...initialValues
  });

  // ----------------------------------------------------------------------------

  function extend$1u(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, defaultValues$4(initialValues));
    // Inheritance
    vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ['viewSpecificProperties']);
    vtkAbstractMapper3D(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  var vtkAbstractMapper3D$1 = {
    extend: extend$1u
  };

  const {
    vtkErrorMacro: vtkErrorMacro$r,
    vtkWarningMacro: vtkWarningMacro$5
  } = macro;

  // ----------------------------------------------------------------------------
  // vtkFieldData methods
  // ----------------------------------------------------------------------------

  function vtkFieldData(publicAPI, model) {
    model.classHierarchy.push('vtkFieldData');
    const superGetState = publicAPI.getState;

    // Decode serialized data if any
    if (model.arrays) {
      model.arrays = model.arrays.map(item => ({
        data: vtk(item.data)
      }));
    }
    publicAPI.initialize = () => {
      publicAPI.initializeFields();
      publicAPI.copyAllOn();
      publicAPI.clearFieldFlags();
    };
    publicAPI.initializeFields = () => {
      model.arrays = [];
      model.copyFieldFlags = {};
      publicAPI.modified();
    };
    publicAPI.copyStructure = other => {
      publicAPI.initializeFields();
      model.copyFieldFlags = other.getCopyFieldFlags().map(x => x); // Deep-copy
      model.arrays = other.arrays().map(x => ({
        array: x
      })); // Deep-copy
      // TODO: Copy array information objects (once we support information objects)
    };

    publicAPI.getNumberOfArrays = () => model.arrays.length;
    publicAPI.getNumberOfActiveArrays = () => model.arrays.length;
    publicAPI.addArray = arr => {
      const name = arr.getName();
      const {
        array,
        index
      } = publicAPI.getArrayWithIndex(name);
      if (array != null) {
        model.arrays[index] = {
          data: arr
        };
        return index;
      }
      model.arrays = [].concat(model.arrays, {
        data: arr
      });
      return model.arrays.length - 1;
    };
    publicAPI.removeAllArrays = () => {
      model.arrays = [];
    };
    publicAPI.removeArray = arrayName => {
      const index = model.arrays.findIndex(array => array.data.getName() === arrayName);
      return publicAPI.removeArrayByIndex(index);
    };
    publicAPI.removeArrayByIndex = arrayIdx => {
      if (arrayIdx !== -1 && arrayIdx < model.arrays.length) {
        model.arrays.splice(arrayIdx, 1);
        // TBD modified() ?
        return true;
      }
      return false;
    };
    publicAPI.getArrays = () => model.arrays.map(entry => entry.data);
    publicAPI.getArray = arraySpec => typeof arraySpec === 'number' ? publicAPI.getArrayByIndex(arraySpec) : publicAPI.getArrayByName(arraySpec);
    publicAPI.getArrayByName = arrayName => model.arrays.reduce((a, b, i) => b.data.getName() === arrayName ? b.data : a, null);
    publicAPI.getArrayWithIndex = arrayName => {
      const index = model.arrays.findIndex(array => array.data.getName() === arrayName);
      return {
        array: index !== -1 ? model.arrays[index].data : null,
        index
      };
    };
    publicAPI.getArrayByIndex = idx => idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;
    publicAPI.hasArray = arrayName => publicAPI.getArrayWithIndex(arrayName).index >= 0;
    publicAPI.getArrayName = idx => {
      const arr = model.arrays[idx];
      return arr ? arr.data.getName() : '';
    };
    publicAPI.getCopyFieldFlags = () => model.copyFieldFlags;
    publicAPI.getFlag = arrayName => model.copyFieldFlags[arrayName];
    publicAPI.passData = function (other) {
      let fromId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      let toId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      other.getArrays().forEach(arr => {
        const copyFlag = publicAPI.getFlag(arr.getName());
        if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
          let destArr = publicAPI.getArrayByName(arr.getName());
          if (!destArr) {
            if (fromId < 0 || fromId > arr.getNumberOfTuples()) {
              // TBD: should this be a deep or a shallow copy?
              publicAPI.addArray(arr);
              other.getAttributes(arr).forEach(attrType => {
                publicAPI.setAttribute(arr, attrType);
              });
            } else {
              const ncomps = arr.getNumberOfComponents();
              let newSize = arr.getNumberOfValues();
              const tId = toId > -1 ? toId : fromId;
              if (newSize <= tId * ncomps) {
                newSize = (tId + 1) * ncomps;
              }
              destArr = vtkDataArray$1.newInstance({
                name: arr.getName(),
                dataType: arr.getDataType(),
                numberOfComponents: ncomps,
                values: macro.newTypedArray(arr.getDataType(), newSize),
                size: 0
              });
              destArr.insertTuple(tId, arr.getTuple(fromId));
              publicAPI.addArray(destArr);
              other.getAttributes(arr).forEach(attrType => {
                publicAPI.setAttribute(destArr, attrType);
              });
            }
          } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
            if (fromId > -1 && fromId < arr.getNumberOfTuples()) {
              const tId = toId > -1 ? toId : fromId;
              destArr.insertTuple(tId, arr.getTuple(fromId));
            } else {
              // if `fromId` is not provided, just copy all (or as much possible)
              // from `arr` to `destArr`.
              destArr.insertTuples(0, arr.getTuples());
            }
          } else {
            vtkErrorMacro$r('Unhandled case in passData');
          }
        }
      });
    };
    publicAPI.interpolateData = function (other) {
      let fromId1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      let fromId2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      let toId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
      let t = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;
      other.getArrays().forEach(arr => {
        const copyFlag = publicAPI.getFlag(arr.getName());
        if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
          let destArr = publicAPI.getArrayByName(arr.getName());
          if (!destArr) {
            if (fromId1 < 0 || fromId2 < 0 || fromId1 > arr.getNumberOfTuples()) {
              // TBD: should this be a deep or a shallow copy?
              publicAPI.addArray(arr);
              other.getAttributes(arr).forEach(attrType => {
                publicAPI.setAttribute(arr, attrType);
              });
            } else {
              const ncomps = arr.getNumberOfComponents();
              let newSize = arr.getNumberOfValues();
              // TODO: Is this supposed to happen?
              const tId = toId > -1 ? toId : fromId1;
              if (newSize <= tId * ncomps) {
                newSize = (tId + 1) * ncomps;
              }
              destArr = vtkDataArray$1.newInstance({
                name: arr.getName(),
                dataType: arr.getDataType(),
                numberOfComponents: ncomps,
                values: macro.newTypedArray(arr.getDataType(), newSize),
                size: 0
              });
              destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);
              publicAPI.addArray(destArr);
              other.getAttributes(arr).forEach(attrType => {
                publicAPI.setAttribute(destArr, attrType);
              });
            }
          } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
            if (fromId1 > -1 && fromId1 < arr.getNumberOfTuples()) {
              const tId = toId > -1 ? toId : fromId1;
              destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);
              vtkWarningMacro$5('Unexpected case in interpolateData');
            } else {
              // if `fromId` is not provided, just copy all (or as much possible)
              // from `arr` to `destArr`.
              destArr.insertTuples(arr.getTuples());
            }
          } else {
            vtkErrorMacro$r('Unhandled case in interpolateData');
          }
        }
      });
    };
    publicAPI.copyFieldOn = arrayName => {
      model.copyFieldFlags[arrayName] = true;
    };
    publicAPI.copyFieldOff = arrayName => {
      model.copyFieldFlags[arrayName] = false;
    };
    publicAPI.copyAllOn = () => {
      if (!model.doCopyAllOn || model.doCopyAllOff) {
        model.doCopyAllOn = true;
        model.doCopyAllOff = false;
        publicAPI.modified();
      }
    };
    publicAPI.copyAllOff = () => {
      if (model.doCopyAllOn || !model.doCopyAllOff) {
        model.doCopyAllOn = false;
        model.doCopyAllOff = true;
        publicAPI.modified();
      }
    };
    publicAPI.clearFieldFlags = () => {
      model.copyFieldFlags = {};
    };
    publicAPI.deepCopy = other => {
      model.arrays = other.getArrays().map(arr => {
        const arrNew = arr.newClone();
        arrNew.deepCopy(arr);
        return {
          data: arrNew
        };
      });
    };
    publicAPI.copyFlags = other => other.getCopyFieldFlags().map(x => x);
    // TODO: publicAPI.squeeze = () => model.arrays.forEach(entry => entry.data.squeeze());
    publicAPI.reset = () => model.arrays.forEach(entry => entry.data.reset());
    // TODO: getActualMemorySize
    publicAPI.getMTime = () => model.arrays.reduce((a, b) => b.data.getMTime() > a ? b.data.getMTime() : a, model.mtime);
    // TODO: publicAPI.getField = (ids, other) => { copy ids from other into this model's arrays }
    // TODO: publicAPI.getArrayContainingComponent = (component) => ...
    publicAPI.getNumberOfComponents = () => model.arrays.reduce((a, b) => a + b.data.getNumberOfComponents(), 0);
    publicAPI.getNumberOfTuples = () => model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;
    publicAPI.getState = () => {
      const result = superGetState();
      if (result) {
        result.arrays = model.arrays.map(item => ({
          data: item.data.getState()
        }));
      }
      return result;
    };
  }
  const DEFAULT_VALUES$1p = {
    arrays: [],
    copyFieldFlags: [],
    // fields not to copy
    doCopyAllOn: true,
    doCopyAllOff: false
  };
  function extend$1t(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1p, initialValues);
    macro.obj(publicAPI, model);
    vtkFieldData(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1t = macro.newInstance(extend$1t, 'vtkFieldData');

  // ----------------------------------------------------------------------------

  var vtkFieldData$1 = {
    newInstance: newInstance$1t,
    extend: extend$1t
  };

  const AttributeTypes$1 = {
    SCALARS: 0,
    VECTORS: 1,
    NORMALS: 2,
    TCOORDS: 3,
    TENSORS: 4,
    GLOBALIDS: 5,
    PEDIGREEIDS: 6,
    EDGEFLAG: 7,
    NUM_ATTRIBUTES: 8
  };
  const AttributeLimitTypes = {
    MAX: 0,
    EXACT: 1,
    NOLIMIT: 2
  };
  const CellGhostTypes = {
    DUPLICATECELL: 1,
    // the cell is present on multiple processors
    HIGHCONNECTIVITYCELL: 2,
    // the cell has more neighbors than in a regular mesh
    LOWCONNECTIVITYCELL: 4,
    // the cell has less neighbors than in a regular mesh
    REFINEDCELL: 8,
    // other cells are present that refines it.
    EXTERIORCELL: 16,
    // the cell is on the exterior of the data set
    HIDDENCELL: 32 // the cell is needed to maintain connectivity, but the data values should be ignored.
  };

  const PointGhostTypes = {
    DUPLICATEPOINT: 1,
    // the cell is present on multiple processors
    HIDDENPOINT: 2 // the point is needed to maintain connectivity, but the data values should be ignored.
  };

  const AttributeCopyOperations$1 = {
    COPYTUPLE: 0,
    INTERPOLATE: 1,
    PASSDATA: 2,
    ALLCOPY: 3 // all of the above
  };

  const ghostArrayName = 'vtkGhostType';
  const DesiredOutputPrecision = {
    DEFAULT: 0,
    // use the point type that does not truncate any data
    SINGLE: 1,
    // use Float32Array
    DOUBLE: 2 // use Float64Array
  };

  var Constants$b = {
    AttributeCopyOperations: AttributeCopyOperations$1,
    AttributeLimitTypes,
    AttributeTypes: AttributeTypes$1,
    CellGhostTypes,
    DesiredOutputPrecision,
    PointGhostTypes,
    ghostArrayName
  };

  const {
    AttributeTypes,
    AttributeCopyOperations
  } = Constants$b;
  const {
    vtkWarningMacro: vtkWarningMacro$4
  } = macro;

  // ----------------------------------------------------------------------------
  // vtkDataSetAttributes methods
  // ----------------------------------------------------------------------------

  function vtkDataSetAttributes(publicAPI, model) {
    const attrTypes = ['Scalars', 'Vectors', 'Normals', 'TCoords', 'Tensors', 'GlobalIds', 'PedigreeIds'];
    function cleanAttributeType(attType) {
      // Given an integer or string, convert the result to one of the
      // strings in the "attrTypes" array above or null (if
      // no match is found)
      let cleanAttType = attrTypes.find(ee => AttributeTypes[ee.toUpperCase()] === attType || typeof attType !== 'number' && ee.toLowerCase() === attType.toLowerCase());
      if (typeof cleanAttType === 'undefined') {
        cleanAttType = null;
      }
      return cleanAttType;
    }

    // Set our className
    model.classHierarchy.push('vtkDataSetAttributes');
    const superClass = {
      ...publicAPI
    };
    publicAPI.checkNumberOfComponents = x => true; // TODO

    publicAPI.setAttribute = (arr, uncleanAttType) => {
      const attType = cleanAttributeType(uncleanAttType);
      if (arr && attType.toUpperCase() === 'PEDIGREEIDS' && !arr.isA('vtkDataArray')) {
        vtkWarningMacro$4(`Cannot set attribute ${attType}. The attribute must be a vtkDataArray.`);
        return -1;
      }
      if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {
        vtkWarningMacro$4(`Cannot set attribute ${attType}. Incorrect number of components.`);
        return -1;
      }
      let currentAttribute = model[`active${attType}`];
      if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {
        if (model.arrays[currentAttribute] === arr) {
          return currentAttribute;
        }
        // FIXME setting an array actually changes its index
        publicAPI.removeArrayByIndex(currentAttribute);
      }
      if (arr) {
        currentAttribute = publicAPI.addArray(arr);
        model[`active${attType}`] = currentAttribute;
      } else {
        model[`active${attType}`] = -1;
      }
      publicAPI.modified();
      return model[`active${attType}`];
    };
    publicAPI.getAttributes = arr => attrTypes.filter(attrType => publicAPI[`get${attrType}`]() === arr);
    publicAPI.setActiveAttributeByName = (arrayName, attType) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);
    publicAPI.setActiveAttributeByIndex = (arrayIdx, uncleanAttType) => {
      const attType = cleanAttributeType(uncleanAttType);
      if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {
        if (attType.toUpperCase() !== 'PEDIGREEIDS') {
          const arr = publicAPI.getArrayByIndex(arrayIdx);
          if (!arr.isA('vtkDataArray')) {
            vtkWarningMacro$4(`Cannot set attribute ${attType}. Only vtkDataArray subclasses can be set as active attributes.`);
            return -1;
          }
          if (!publicAPI.checkNumberOfComponents(arr, attType)) {
            vtkWarningMacro$4(`Cannot set attribute ${attType}. Incorrect number of components.`);
            return -1;
          }
        }
        model[`active${attType}`] = arrayIdx;
        publicAPI.modified();
        return arrayIdx;
      }
      if (arrayIdx === -1) {
        model[`active${attType}`] = arrayIdx;
        publicAPI.modified();
      }
      return -1;
    };
    publicAPI.getActiveAttribute = attType => {
      // Given an integer enum value or a string (with random capitalization),
      // find the matching string in attrTypes.
      const cleanAttType = cleanAttributeType(attType);
      return publicAPI[`get${cleanAttType}`]();
    };

    // Override to allow proper handling of active attributes
    publicAPI.removeAllArrays = () => {
      attrTypes.forEach(attType => {
        model[`active${attType}`] = -1;
      });
      superClass.removeAllArrays();
    };

    // Override to allow proper handling of active attributes
    publicAPI.removeArrayByIndex = arrayIdx => {
      if (arrayIdx !== -1) {
        attrTypes.forEach(attType => {
          if (arrayIdx === model[`active${attType}`]) {
            model[`active${attType}`] = -1;
          } else if (arrayIdx < model[`active${attType}`]) {
            model[`active${attType}`] -= 1;
          }
        });
      }
      return superClass.removeArrayByIndex(arrayIdx);
    };
    attrTypes.forEach(value => {
      const activeVal = `active${value}`;
      publicAPI[`get${value}`] = () => publicAPI.getArrayByIndex(model[activeVal]);
      publicAPI[`set${value}`] = da => publicAPI.setAttribute(da, value);
      publicAPI[`setActive${value}`] = arrayName => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);
      publicAPI[`copy${value}Off`] = () => {
        const attType = value.toUpperCase();
        model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = false;
      };
      publicAPI[`copy${value}On`] = () => {
        const attType = value.toUpperCase();
        model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][AttributeTypes[attType]] = true;
      };
    });
    publicAPI.initializeAttributeCopyFlags = () => {
      // Default to copying all attributes in every circumstance:
      model.copyAttributeFlags = [];
      Object.keys(AttributeCopyOperations).filter(op => op !== 'ALLCOPY').forEach(attCopyOp => {
        model.copyAttributeFlags[AttributeCopyOperations[attCopyOp]] = Object.keys(AttributeTypes).filter(ty => ty !== 'NUM_ATTRIBUTES').reduce((a, b) => {
          a[AttributeTypes[b]] = true;
          return a;
        }, []);
      });
      // Override some operations where we don't want to copy:
      model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.GLOBALIDS] = false;
      model.copyAttributeFlags[AttributeCopyOperations.INTERPOLATE][AttributeTypes.GLOBALIDS] = false;
      model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][AttributeTypes.PEDIGREEIDS] = false;
    };
    publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags);

    // Process dataArrays if any
    if (model.dataArrays && Object.keys(model.dataArrays).length) {
      Object.keys(model.dataArrays).forEach(name => {
        if (!model.dataArrays[name].ref && model.dataArrays[name].type === 'vtkDataArray') {
          publicAPI.addArray(vtkDataArray$1.newInstance(model.dataArrays[name]));
        }
      });
    }
    const superShallowCopy = publicAPI.shallowCopy;
    publicAPI.shallowCopy = (other, debug) => {
      superShallowCopy(other, debug);
      model.arrays = other.getArrays().map(arr => {
        const arrNew = arr.newClone();
        arrNew.shallowCopy(arr, debug);
        return {
          data: arrNew
        };
      });
    };
    publicAPI.initializeAttributeCopyFlags();
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1o = {
    activeScalars: -1,
    activeVectors: -1,
    activeTensors: -1,
    activeNormals: -1,
    activeTCoords: -1,
    activeGlobalIds: -1,
    activePedigreeIds: -1
  };

  // ----------------------------------------------------------------------------

  function extend$1s(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1o, initialValues);

    // Object methods
    vtkFieldData$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ['activeScalars', 'activeNormals', 'activeTCoords', 'activeVectors', 'activeTensors', 'activeGlobalIds', 'activePedigreeIds']);
    if (!model.arrays) {
      model.arrays = {};
    }

    // Object specific methods
    vtkDataSetAttributes(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1s = macro.newInstance(extend$1s, 'vtkDataSetAttributes');

  // ----------------------------------------------------------------------------

  var vtkDataSetAttributes$1 = {
    newInstance: newInstance$1s,
    extend: extend$1s,
    ...Constants$b
  };

  // Specify how data arrays can be used by data objects
  const FieldDataTypes = {
    UNIFORM: 0,
    // data that does not vary over points/cells/etc.
    DATA_OBJECT_FIELD: 0,
    // to match VTK

    COORDINATE: 1,
    // data that specifies the location of each point
    POINT_DATA: 1,
    // to match VTK

    POINT: 2,
    // data defined at each point, but that does not specify the point location
    POINT_FIELD_DATA: 2,
    // to match VTK

    CELL: 3,
    // data defined at each cell, but that does not specify the cell
    CELL_FIELD_DATA: 3,
    // to match VTK

    VERTEX: 4,
    // data defined at each graph vertex, but that does not specify the graph vertex
    VERTEX_FIELD_DATA: 4,
    // to match VTK

    EDGE: 5,
    // data defined at each graph edge, but that does not specify the graph edge
    EDGE_FIELD_DATA: 5,
    // to match VTK

    ROW: 6,
    // data specifying a table row
    ROW_DATA: 6 // to match VTK
  };

  const FieldAssociations$5 = {
    FIELD_ASSOCIATION_POINTS: 0,
    FIELD_ASSOCIATION_CELLS: 1,
    FIELD_ASSOCIATION_NONE: 2,
    FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,
    FIELD_ASSOCIATION_VERTICES: 4,
    FIELD_ASSOCIATION_EDGES: 5,
    FIELD_ASSOCIATION_ROWS: 6,
    NUMBER_OF_ASSOCIATIONS: 7
  };
  var Constants$a = {
    FieldDataTypes,
    FieldAssociations: FieldAssociations$5
  };

  // import vtkBoundingBox from '../BoundingBox';
  // import * as vtkMath from '../../Core/Math';
  //
  // function getBounds(dataset) {
  //   if (dataset.bounds) {
  //     return dataset.bounds;
  //   }
  //   if (dataset.type && dataset[dataset.type]) {
  //     const ds = dataset[dataset.type];
  //     if (ds.bounds) {
  //       return ds.bounds;
  //     }
  //     if (ds.Points && ds.Points.bounds) {
  //       return ds.Points.bounds;
  //     }

  //     if (ds.Points && ds.Points.values) {
  //       const array = ds.Points.values;
  //       const bbox = [...vtkBoundingBox.INIT_BOUNDS];
  //       const size = array.length;
  //       const delta = ds.Points.numberOfComponents ? ds.Points.numberOfComponents : 3;
  //       for (let idx = 0; idx < size; idx += delta) {
  //         vtkBoundingBox.addPoint(bbox, array[idx * delta], array[(idx * delta) + 1], array[(idx * delta) + 2]);
  //       }
  //       ds.Points.bounds = bbox;
  //       return ds.Points.bounds;
  //     }
  //   }
  //   return vtkMath.createUninitializedBounds();
  // }

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  const DATASET_FIELDS = ['pointData', 'cellData', 'fieldData'];

  // ----------------------------------------------------------------------------
  // vtkDataSet methods
  // ----------------------------------------------------------------------------

  function vtkDataSet(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkDataSet');

    // Add dataset attributes
    DATASET_FIELDS.forEach(fieldName => {
      if (!model[fieldName]) {
        model[fieldName] = vtkDataSetAttributes$1.newInstance();
      } else {
        model[fieldName] = vtk(model[fieldName]);
      }
    });
    const superShallowCopy = publicAPI.shallowCopy;
    publicAPI.shallowCopy = function (other) {
      let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      superShallowCopy(other, debug);
      DATASET_FIELDS.forEach(fieldName => {
        model[fieldName] = vtkDataSetAttributes$1.newInstance();
        model[fieldName].shallowCopy(other.getReferenceByName(fieldName));
      });
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1n = {
    // pointData: null,
    // cellData: null,
    // fieldData: null,
  };

  // ----------------------------------------------------------------------------

  function extend$1r(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1n, initialValues);

    // Object methods
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, DATASET_FIELDS);

    // Object specific methods
    vtkDataSet(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1r = macro.newInstance(extend$1r, 'vtkDataSet');

  // ----------------------------------------------------------------------------

  var vtkDataSet$1 = {
    newInstance: newInstance$1r,
    extend: extend$1r,
    ...Constants$a
  };

  const StructuredType$1 = {
    UNCHANGED: 0,
    SINGLE_POINT: 1,
    X_LINE: 2,
    Y_LINE: 3,
    Z_LINE: 4,
    XY_PLANE: 5,
    YZ_PLANE: 6,
    XZ_PLANE: 7,
    XYZ_GRID: 8,
    EMPTY: 9
  };
  var Constants$9 = {
    StructuredType: StructuredType$1
  };

  const {
    StructuredType
  } = Constants$9;
  function getDataDescriptionFromExtent(inExt) {
    let dataDim = 0;
    for (let i = 0; i < 3; ++i) {
      if (inExt[i * 2] < inExt[i * 2 + 1]) {
        dataDim++;
      }
    }
    if (inExt[0] > inExt[1] || inExt[2] > inExt[3] || inExt[4] > inExt[5]) {
      return StructuredType.EMPTY;
    }
    if (dataDim === 3) {
      return StructuredType.XYZ_GRID;
    }
    if (dataDim === 2) {
      if (inExt[0] === inExt[1]) {
        return StructuredType.YZ_PLANE;
      }
      if (inExt[2] === inExt[3]) {
        return StructuredType.XZ_PLANE;
      }
      return StructuredType.XY_PLANE;
    }
    if (dataDim === 1) {
      if (inExt[0] < inExt[1]) {
        return StructuredType.X_LINE;
      }
      if (inExt[2] < inExt[3]) {
        return StructuredType.Y_LINE;
      }
      return StructuredType.Z_LINE;
    }
    return StructuredType.SINGLE_POINT;
  }
  var vtkStructuredData = {
    getDataDescriptionFromExtent,
    ...Constants$9
  };

  const {
    vtkErrorMacro: vtkErrorMacro$q
  } = macro;

  // ----------------------------------------------------------------------------
  // vtkImageData methods
  // ----------------------------------------------------------------------------

  function vtkImageData(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkImageData');
    publicAPI.setExtent = function () {
      if (model.deleted) {
        vtkErrorMacro$q('instance deleted - cannot call any method');
        return false;
      }
      for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {
        inExtent[_key] = arguments[_key];
      }
      const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;
      if (extentArray.length !== 6) {
        return false;
      }
      const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);
      if (changeDetected) {
        model.extent = extentArray.slice();
        model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);
        publicAPI.modified();
      }
      return changeDetected;
    };
    publicAPI.setDimensions = function () {
      let i;
      let j;
      let k;
      if (model.deleted) {
        vtkErrorMacro$q('instance deleted - cannot call any method');
        return;
      }
      if (arguments.length === 1) {
        const array = arguments.length <= 0 ? undefined : arguments[0];
        i = array[0];
        j = array[1];
        k = array[2];
      } else if (arguments.length === 3) {
        i = arguments.length <= 0 ? undefined : arguments[0];
        j = arguments.length <= 1 ? undefined : arguments[1];
        k = arguments.length <= 2 ? undefined : arguments[2];
      } else {
        vtkErrorMacro$q('Bad dimension specification');
        return;
      }
      publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);
    };
    publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];
    publicAPI.getNumberOfCells = () => {
      const dims = publicAPI.getDimensions();
      let nCells = 1;
      for (let i = 0; i < 3; i++) {
        if (dims[i] === 0) {
          return 0;
        }
        if (dims[i] > 1) {
          nCells *= dims[i] - 1;
        }
      }
      return nCells;
    };
    publicAPI.getNumberOfPoints = () => {
      const dims = publicAPI.getDimensions();
      return dims[0] * dims[1] * dims[2];
    };
    publicAPI.getPoint = index => {
      const dims = publicAPI.getDimensions();
      if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {
        vtkErrorMacro$q('Requesting a point from an empty image.');
        return null;
      }
      const ijk = new Float64Array(3);
      switch (model.dataDescription) {
        case StructuredType$1.EMPTY:
          return null;
        case StructuredType$1.SINGLE_POINT:
          break;
        case StructuredType$1.X_LINE:
          ijk[0] = index;
          break;
        case StructuredType$1.Y_LINE:
          ijk[1] = index;
          break;
        case StructuredType$1.Z_LINE:
          ijk[2] = index;
          break;
        case StructuredType$1.XY_PLANE:
          ijk[0] = index % dims[0];
          ijk[1] = index / dims[0];
          break;
        case StructuredType$1.YZ_PLANE:
          ijk[1] = index % dims[1];
          ijk[2] = index / dims[1];
          break;
        case StructuredType$1.XZ_PLANE:
          ijk[0] = index % dims[0];
          ijk[2] = index / dims[0];
          break;
        case StructuredType$1.XYZ_GRID:
          ijk[0] = index % dims[0];
          ijk[1] = index / dims[0] % dims[1];
          ijk[2] = index / (dims[0] * dims[1]);
          break;
        default:
          vtkErrorMacro$q('Invalid dataDescription');
          break;
      }
      const coords = [0, 0, 0];
      publicAPI.indexToWorld(ijk, coords);
      return coords;
    };

    // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;
    // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;
    // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;
    // virtual vtkIdType FindPoint(double x, double y, double z)
    // {
    //   return this->vtkDataSet::FindPoint(x, y, z);
    // }
    // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;
    // vtkIdType FindCell(
    //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,
    //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;
    // vtkIdType FindCell(
    //   double x[3], vtkCell *cell, vtkGenericCell *gencell,
    //   vtkIdType cellId, double tol2, int& subId,
    //   double pcoords[3], double *weights) VTK_OVERRIDE;
    // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,
    //                                 double tol2, int& subId, double pcoords[3],
    //                                 double *weights) VTK_OVERRIDE;
    // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;
    // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE
    //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,
    //                                     this->GetDimensions());}
    // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE
    //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}
    // void ComputeBounds() VTK_OVERRIDE;
    // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest

    publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());
    publicAPI.extentToBounds = ex => vtkBoundingBox.transformBounds(ex, model.indexToWorld);
    publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);

    // Internal, shouldn't need to call this manually.
    publicAPI.computeTransforms = () => {
      fromTranslation(model.indexToWorld, model.origin);
      model.indexToWorld[0] = model.direction[0];
      model.indexToWorld[1] = model.direction[1];
      model.indexToWorld[2] = model.direction[2];
      model.indexToWorld[4] = model.direction[3];
      model.indexToWorld[5] = model.direction[4];
      model.indexToWorld[6] = model.direction[5];
      model.indexToWorld[8] = model.direction[6];
      model.indexToWorld[9] = model.direction[7];
      model.indexToWorld[10] = model.direction[8];
      scale$2(model.indexToWorld, model.indexToWorld, model.spacing);
      invert(model.worldToIndex, model.indexToWorld);
    };
    publicAPI.indexToWorld = function (ain) {
      let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      transformMat4$1(aout, ain, model.indexToWorld);
      return aout;
    };
    publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;
    publicAPI.worldToIndex = function (ain) {
      let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      transformMat4$1(aout, ain, model.worldToIndex);
      return aout;
    };
    publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;
    publicAPI.indexToWorldBounds = function (bin) {
      let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);
    };
    publicAPI.worldToIndexBounds = function (bin) {
      let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);
    };

    // Make sure the transform is correct
    publicAPI.onModified(publicAPI.computeTransforms);
    publicAPI.computeTransforms();
    publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());
    publicAPI.computeHistogram = function (worldBounds) {
      let voxelFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      const bounds = [0, 0, 0, 0, 0, 0];
      publicAPI.worldToIndexBounds(worldBounds, bounds);
      const point1 = [0, 0, 0];
      const point2 = [0, 0, 0];
      vtkBoundingBox.computeCornerPoints(bounds, point1, point2);
      roundVector(point1, point1);
      roundVector(point2, point2);
      const dimensions = publicAPI.getDimensions();
      clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);
      clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);
      const yStride = dimensions[0];
      const zStride = dimensions[0] * dimensions[1];
      const pixels = publicAPI.getPointData().getScalars().getData();
      let maximum = -Infinity;
      let minimum = Infinity;
      let sumOfSquares = 0;
      let isum = 0;
      let inum = 0;
      for (let z = point1[2]; z <= point2[2]; z++) {
        for (let y = point1[1]; y <= point2[1]; y++) {
          let index = point1[0] + y * yStride + z * zStride;
          for (let x = point1[0]; x <= point2[0]; x++) {
            if (!voxelFunc || voxelFunc([x, y, z], bounds)) {
              const pixel = pixels[index];
              if (pixel > maximum) maximum = pixel;
              if (pixel < minimum) minimum = pixel;
              sumOfSquares += pixel * pixel;
              isum += pixel;
              inum += 1;
            }
            ++index;
          }
        }
      }
      const average = inum > 0 ? isum / inum : 0;
      const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;
      const sigma = Math.sqrt(variance);
      return {
        minimum,
        maximum,
        average,
        variance,
        sigma,
        count: inum
      };
    };

    // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).
    // Scalar data could be tuples for color information?
    publicAPI.computeIncrements = function (extent) {
      let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      const increments = [];
      let incr = numberOfComponents;

      // Calculate array increment offsets
      // similar to c++ vtkImageData::ComputeIncrements
      for (let idx = 0; idx < 3; ++idx) {
        increments[idx] = incr;
        incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;
      }
      return increments;
    };

    /**
     * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.
     * @return {Number} the corresponding flattened index in the scalar array
     */
    publicAPI.computeOffsetIndex = _ref => {
      let [i, j, k] = _ref;
      const extent = publicAPI.getExtent();
      const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
      const increments = publicAPI.computeIncrements(extent, numberOfComponents);
      // Use the array increments to find the pixel index
      // similar to c++ vtkImageData::GetArrayPointer
      // Math.floor to catch "practically 0" e^-15 scenarios.
      return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);
    };

    /**
     * @param {Number[]} xyz the [x,y,z] Array in world coordinates
     * @return {Number|NaN} the corresponding pixel's index in the scalar array
     */
    publicAPI.getOffsetIndexFromWorld = xyz => {
      const extent = publicAPI.getExtent();
      const index = publicAPI.worldToIndex(xyz);

      // Confirm indexed i,j,k coords are within the bounds of the volume
      for (let idx = 0; idx < 3; ++idx) {
        if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {
          vtkErrorMacro$q(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);
          return NaN;
        }
      }

      // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream
      return publicAPI.computeOffsetIndex(index);
    };
    /**
     * @param {Number[]} xyz the [x,y,z] Array in world coordinates
     * @param {Number?} comp the scalar component index for multi-component scalars
     * @return {Number|NaN} the corresponding pixel's scalar value
     */
    publicAPI.getScalarValueFromWorld = function (xyz) {
      let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
      if (comp < 0 || comp >= numberOfComponents) {
        vtkErrorMacro$q(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);
        return NaN;
      }
      const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);
      if (Number.isNaN(offsetIndex)) {
        // VTK Error Macro will have been tripped already, no need to do it again,
        return offsetIndex;
      }
      return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1m = {
    direction: null,
    // a mat3
    indexToWorld: null,
    // a mat4
    worldToIndex: null,
    // a mat4
    spacing: [1.0, 1.0, 1.0],
    origin: [0.0, 0.0, 0.0],
    extent: [0, -1, 0, -1, 0, -1],
    dataDescription: StructuredType$1.EMPTY
  };

  // ----------------------------------------------------------------------------

  function extend$1q(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1m, initialValues);

    // Inheritance
    vtkDataSet$1.extend(publicAPI, model, initialValues);
    if (!model.direction) {
      model.direction = identity$4(new Float64Array(9));
    } else if (Array.isArray(model.direction)) {
      model.direction = new Float64Array(model.direction.slice(0, 9));
    }
    model.indexToWorld = new Float64Array(16);
    model.worldToIndex = new Float64Array(16);

    // Set/Get methods
    macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);
    macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);
    macro.setGetArray(publicAPI, model, ['direction'], 9);
    macro.getArray(publicAPI, model, ['extent'], 6);

    // Object specific methods
    vtkImageData(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1q = macro.newInstance(extend$1q, 'vtkImageData');

  // ----------------------------------------------------------------------------

  var vtkImageData$1 = {
    newInstance: newInstance$1q,
    extend: extend$1q
  };

  const VectorMode$3 = {
    MAGNITUDE: 0,
    COMPONENT: 1,
    RGBCOLORS: 2
  };
  const ScalarMappingTarget$1 = {
    LUMINANCE: 1,
    LUMINANCE_ALPHA: 2,
    RGB: 3,
    RGBA: 4
  };
  var vtkScalarsToColors$2 = {
    VectorMode: VectorMode$3,
    ScalarMappingTarget: ScalarMappingTarget$1
  };

  const ColorMode$3 = {
    DEFAULT: 0,
    MAP_SCALARS: 1,
    DIRECT_SCALARS: 2
  };
  const ScalarMode$5 = {
    DEFAULT: 0,
    USE_POINT_DATA: 1,
    USE_CELL_DATA: 2,
    USE_POINT_FIELD_DATA: 3,
    USE_CELL_FIELD_DATA: 4,
    USE_FIELD_DATA: 5
  };
  const GetArray$2 = {
    BY_ID: 0,
    BY_NAME: 1
  };
  var Constants$8 = {
    ColorMode: ColorMode$3,
    GetArray: GetArray$2,
    ScalarMode: ScalarMode$5
  };

  const {
    ScalarMappingTarget,
    VectorMode: VectorMode$2
  } = vtkScalarsToColors$2;
  const {
    VtkDataTypes: VtkDataTypes$4
  } = vtkDataArray$1;
  const {
    ColorMode: ColorMode$2
  } = Constants$8;
  const {
    vtkErrorMacro: vtkErrorMacro$p
  } = macro;

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  // Add module-level functions or api that you want to expose statically via
  // the next section...

  // ----------------------------------------------------------------------------
  // Static API
  // ----------------------------------------------------------------------------

  function intColorToUChar(c) {
    return c;
  }
  function floatColorToUChar(c) {
    return Math.floor(c * 255.0 + 0.5);
  }

  // ----------------------------------------------------------------------------
  // vtkScalarsToColors methods
  // ----------------------------------------------------------------------------

  function vtkScalarsToColors(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkScalarsToColors');
    publicAPI.setVectorModeToMagnitude = () => publicAPI.setVectorMode(VectorMode$2.MAGNITUDE);
    publicAPI.setVectorModeToComponent = () => publicAPI.setVectorMode(VectorMode$2.COMPONENT);
    publicAPI.setVectorModeToRGBColors = () => publicAPI.setVectorMode(VectorMode$2.RGBCOLORS);
    publicAPI.build = () => {};
    publicAPI.isOpaque = () => true;

    //----------------------------------------------------------------------------
    publicAPI.setAnnotations = (values, annotations) => {
      if (values && !annotations || !values && annotations) {
        return;
      }
      if (values && annotations && values.length !== annotations.length) {
        vtkErrorMacro$p('Values and annotations do not have the same number of tuples so ignoring');
        return;
      }
      model.annotationArray = [];
      if (annotations && values) {
        const num = annotations.length;
        for (let i = 0; i < num; i++) {
          model.annotationArray.push({
            value: values[i],
            annotation: String(annotations[i])
          });
        }
      }
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    };

    //----------------------------------------------------------------------------
    publicAPI.setAnnotation = (value, annotation) => {
      let i = publicAPI.checkForAnnotatedValue(value);
      let modified = false;
      if (i >= 0) {
        if (model.annotationArray[i].annotation !== annotation) {
          model.annotationArray[i].annotation = annotation;
          modified = true;
        }
      } else {
        model.annotationArray.push({
          value,
          annotation
        });
        i = model.annotationArray.length - 1;
        modified = true;
      }
      if (modified) {
        publicAPI.updateAnnotatedValueMap();
        publicAPI.modified();
      }
      return i;
    };

    //----------------------------------------------------------------------------
    publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length;

    //----------------------------------------------------------------------------
    publicAPI.getAnnotatedValue = idx => {
      if (idx < 0 || idx >= model.annotationArray.length) {
        return null;
      }
      return model.annotationArray[idx].value;
    };

    //----------------------------------------------------------------------------
    publicAPI.getAnnotation = idx => {
      if (model.annotationArray[idx] === undefined) {
        return null;
      }
      return model.annotationArray[idx].annotation;
    };

    //----------------------------------------------------------------------------
    publicAPI.getAnnotatedValueIndex = val => model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;

    //----------------------------------------------------------------------------
    publicAPI.removeAnnotation = value => {
      const i = publicAPI.checkForAnnotatedValue(value);
      const needToRemove = i >= 0;
      if (needToRemove) {
        model.annotationArray.splice(i, 1);
        publicAPI.updateAnnotatedValueMap();
        publicAPI.modified();
      }
      return needToRemove;
    };

    //----------------------------------------------------------------------------
    publicAPI.resetAnnotations = () => {
      model.annotationArray = [];
      model.annotatedValueMap = [];
      publicAPI.modified();
    };

    //----------------------------------------------------------------------------
    publicAPI.getAnnotationColor = (val, rgba) => {
      if (model.indexedLookup) {
        const i = publicAPI.getAnnotatedValueIndex(val);
        publicAPI.getIndexedColor(i, rgba);
      } else {
        publicAPI.getColor(parseFloat(val), rgba);
        rgba[3] = 1.0;
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.checkForAnnotatedValue = value => publicAPI.getAnnotatedValueIndexInternal(value);

    //----------------------------------------------------------------------------
    // An unsafe version of vtkScalarsToColors::CheckForAnnotatedValue for
    // internal use (no pointer checks performed)
    publicAPI.getAnnotatedValueIndexInternal = value => {
      if (model.annotatedValueMap[value] !== undefined) {
        const na = model.annotationArray.length;
        return model.annotatedValueMap[value] % na;
      }
      // Treat as a NaN
      return -1;
    };

    //----------------------------------------------------------------------------
    publicAPI.getIndexedColor = (val, rgba) => {
      rgba[0] = 0.0;
      rgba[1] = 0.0;
      rgba[2] = 0.0;
      rgba[3] = 0.0;
    };

    //----------------------------------------------------------------------------
    publicAPI.updateAnnotatedValueMap = () => {
      model.annotatedValueMap = [];
      const na = model.annotationArray.length;
      for (let i = 0; i < na; i++) {
        model.annotatedValueMap[model.annotationArray[i].value] = i;
      }
    };

    // Description:
    // Internal methods that map a data array into a 4-component,
    // unsigned char RGBA array. The color mode determines the behavior
    // of mapping. If ColorMode.DEFAULT is set, then unsigned char
    // data arrays are treated as colors (and converted to RGBA if
    // necessary); If ColorMode.DIRECT_SCALARS is set, then all arrays
    // are treated as colors (integer types are clamped in the range 0-255,
    // floating point arrays are clamped in the range 0.0-1.0. Note 'char' does
    // not have enough values to represent a color so mapping this type is
    // considered an error);
    // otherwise, the data is mapped through this instance
    // of ScalarsToColors. The component argument is used for data
    // arrays with more than one component; it indicates which component
    // to use to do the blending.  When the component argument is -1,
    // then the this object uses its own selected technique to change a
    // vector into a scalar to map.
    publicAPI.mapScalars = (scalars, colorMode, componentIn) => {
      const numberOfComponents = scalars.getNumberOfComponents();
      let newColors = null;

      // map scalars through lookup table only if needed
      if (colorMode === ColorMode$2.DEFAULT && scalars.getDataType() === VtkDataTypes$4.UNSIGNED_CHAR || colorMode === ColorMode$2.DIRECT_SCALARS && scalars) {
        newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());
      } else {
        const newscalars = {
          type: 'vtkDataArray',
          name: 'temp',
          numberOfComponents: 4,
          dataType: VtkDataTypes$4.UNSIGNED_CHAR
        };
        const s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());
        newscalars.values = s;
        newscalars.size = s.length;
        newColors = vtkDataArray$1.newInstance(newscalars);
        let component = componentIn;

        // If mapper did not specify a component, use the VectorMode
        if (component < 0 && numberOfComponents > 1) {
          publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, -1, -1);
        } else {
          if (component < 0) {
            component = 0;
          }
          if (component >= numberOfComponents) {
            component = numberOfComponents - 1;
          }

          // Map the scalars to colors
          publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget.RGBA, component);
        }
      }
      return newColors;
    };
    publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {
      const length = input.getNumberOfTuples();
      const inIncr = input.getNumberOfComponents();
      const outputV = output.getData();
      const inputV = input.getData();
      for (let i = 0; i < length; i++) {
        let sum = 0.0;
        for (let j = 0; j < compsToUse; j++) {
          sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];
        }
        outputV[i] = Math.sqrt(sum);
      }
    };

    //----------------------------------------------------------------------------
    // Map a set of vector values through the table
    publicAPI.mapVectorsThroughTable = (input, output, outputFormat, vectorComponentIn, vectorSizeIn) => {
      let vectorMode = publicAPI.getVectorMode();
      let vectorSize = vectorSizeIn;
      let vectorComponent = vectorComponentIn;
      const inComponents = input.getNumberOfComponents();
      if (vectorMode === VectorMode$2.COMPONENT) {
        // make sure vectorComponent is within allowed range
        if (vectorComponent === -1) {
          // if set to -1, use default value provided by table
          vectorComponent = publicAPI.getVectorComponent();
        }
        if (vectorComponent < 0) {
          vectorComponent = 0;
        }
        if (vectorComponent >= inComponents) {
          vectorComponent = inComponents - 1;
        }
      } else {
        // make sure vectorSize is within allowed range
        if (vectorSize === -1) {
          // if set to -1, use default value provided by table
          vectorSize = publicAPI.getVectorSize();
        }
        if (vectorSize <= 0) {
          vectorComponent = 0;
          vectorSize = inComponents;
        } else {
          if (vectorComponent < 0) {
            vectorComponent = 0;
          }
          if (vectorComponent >= inComponents) {
            vectorComponent = inComponents - 1;
          }
          if (vectorComponent + vectorSize > inComponents) {
            vectorSize = inComponents - vectorComponent;
          }
        }
        if (vectorMode === VectorMode$2.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {
          vectorMode = VectorMode$2.COMPONENT;
        }
      }

      // increment input pointer to the first component to map
      let inputOffset = 0;
      if (vectorComponent > 0) {
        inputOffset = vectorComponent;
      }

      // map according to the current vector mode
      switch (vectorMode) {
        case VectorMode$2.COMPONENT:
          {
            publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);
            break;
          }
        case VectorMode$2.RGBCOLORS:
          {
            // publicAPI.mapColorsToColors(
            //   input, output, inComponents, vectorSize,
            //   outputFormat);
            break;
          }

        // MAGNITUDE is considered default
        case VectorMode$2.MAGNITUDE:
        default:
          {
            const magValues = vtkDataArray$1.newInstance({
              numberOfComponents: 1,
              values: new Float32Array(input.getNumberOfTuples())
            });
            publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);
            publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);
            break;
          }
      }
    };
    publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {
      const a = convtFun(alpha);
      const values = colors.getData();
      const newValues = newColors.getData();
      const size = values.length;
      const component = 0;
      const tuple = 1;
      let count = 0;
      for (let i = component; i < size; i += tuple) {
        const l = convtFun(values[i]);
        newValues[count * 4] = l;
        newValues[count * 4 + 1] = l;
        newValues[count * 4 + 2] = l;
        newValues[count * 4 + 3] = a;
        count++;
      }
    };
    publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {
      const values = colors.getData();
      const newValues = newColors.getData();
      const size = values.length;
      const component = 0;
      const tuple = 2;
      let count = 0;
      for (let i = component; i < size; i += tuple) {
        const l = convtFun(values[i]);
        newValues[count] = l;
        newValues[count + 1] = l;
        newValues[count + 2] = l;
        newValues[count + 3] = convtFun(values[i + 1]) * alpha;
        count += 4;
      }
    };
    publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {
      const a = floatColorToUChar(alpha);
      const values = colors.getData();
      const newValues = newColors.getData();
      const size = values.length;
      const component = 0;
      const tuple = 3;
      let count = 0;
      for (let i = component; i < size; i += tuple) {
        newValues[count * 4] = convtFun(values[i]);
        newValues[count * 4 + 1] = convtFun(values[i + 1]);
        newValues[count * 4 + 2] = convtFun(values[i + 2]);
        newValues[count * 4 + 3] = a;
        count++;
      }
    };
    publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {
      const values = colors.getData();
      const newValues = newColors.getData();
      const size = values.length;
      const component = 0;
      const tuple = 4;
      let count = 0;
      for (let i = component; i < size; i += tuple) {
        newValues[count * 4] = convtFun(values[i]);
        newValues[count * 4 + 1] = convtFun(values[i + 1]);
        newValues[count * 4 + 2] = convtFun(values[i + 2]);
        newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;
        count++;
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.convertToRGBA = (colors, numComp, numTuples) => {
      let {
        alpha
      } = model;
      if (numComp === 4 && alpha >= 1.0 && colors.getDataType() === VtkDataTypes$4.UNSIGNED_CHAR) {
        return colors;
      }
      const newColors = vtkDataArray$1.newInstance({
        numberOfComponents: 4,
        empty: true,
        size: 4 * numTuples,
        dataType: VtkDataTypes$4.UNSIGNED_CHAR
      });
      if (numTuples <= 0) {
        return newColors;
      }
      alpha = alpha > 0 ? alpha : 0;
      alpha = alpha < 1 ? alpha : 1;
      let convtFun = intColorToUChar;
      if (colors.getDataType() === VtkDataTypes$4.FLOAT || colors.getDataType() === VtkDataTypes$4.DOUBLE) {
        convtFun = floatColorToUChar;
      }
      switch (numComp) {
        case 1:
          publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);
          break;
        case 2:
          publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);
          break;
        case 3:
          publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);
          break;
        case 4:
          publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);
          break;
        default:
          vtkErrorMacro$p('Cannot convert colors');
          return null;
      }
      return newColors;
    };
    publicAPI.usingLogScale = () => false;
    publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;
    publicAPI.setRange = (min, max) => publicAPI.setMappingRange(min, max);
    publicAPI.getRange = () => publicAPI.getMappingRange();
    publicAPI.areScalarsOpaque = (scalars, colorMode, componentIn) => {
      if (!scalars) {
        return publicAPI.isOpaque();
      }
      const numberOfComponents = scalars.getNumberOfComponents();

      // map scalars through lookup table only if needed
      if (colorMode === ColorMode$2.DEFAULT && scalars.getDataType() === VtkDataTypes$4.UNSIGNED_CHAR || colorMode === ColorMode$2.DIRECT_SCALARS) {
        // we will be using the scalars directly, so look at the number of
        // components and the range
        if (numberOfComponents === 3 || numberOfComponents === 1) {
          return model.alpha >= 1.0;
        }
        // otherwise look at the range of the alpha channel
        const range = scalars.getRange(numberOfComponents - 1);
        return range[0] === 255;
      }
      return true;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1l = {
    alpha: 1.0,
    vectorComponent: 0,
    vectorSize: -1,
    vectorMode: VectorMode$2.COMPONENT,
    mappingRange: null,
    annotationArray: null,
    annotatedValueMap: null,
    indexedLookup: false
  };

  // ----------------------------------------------------------------------------

  function extend$1p(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1l, initialValues);

    // Object methods
    macro.obj(publicAPI, model);
    model.mappingRange = [0, 255];
    model.annotationArray = [];
    model.annotatedValueMap = [];

    // Create get-set macros
    macro.setGet(publicAPI, model, ['vectorSize', 'vectorComponent', 'vectorMode', 'alpha', 'indexedLookup']);

    // Create set macros for array (needs to know size)
    macro.setArray(publicAPI, model, ['mappingRange'], 2);

    // Create get macros for array
    macro.getArray(publicAPI, model, ['mappingRange']);

    // For more macro methods, see "Sources/macros.js"

    // Object specific methods
    vtkScalarsToColors(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1p = macro.newInstance(extend$1p, 'vtkScalarsToColors');

  // ----------------------------------------------------------------------------

  var vtkScalarsToColors$1 = {
    newInstance: newInstance$1p,
    extend: extend$1p,
    ...vtkScalarsToColors$2
  };

  const {
    vtkErrorMacro: vtkErrorMacro$o
  } = macro;

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  // Add module-level functions or api that you want to expose statically via
  // the next section...

  // ----------------------------------------------------------------------------
  // Static API
  // ----------------------------------------------------------------------------

  const BELOW_RANGE_COLOR_INDEX = 0;
  const ABOVE_RANGE_COLOR_INDEX = 1;
  const NAN_COLOR_INDEX = 2;

  // ----------------------------------------------------------------------------
  // vtkMyClass methods
  // ----------------------------------------------------------------------------

  function vtkLookupTable(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkLookupTable');

    //----------------------------------------------------------------------------
    // Description:
    // Return true if all of the values defining the mapping have an opacity
    // equal to 1. Default implementation return true.
    publicAPI.isOpaque = () => {
      if (model.opaqueFlagBuildTime.getMTime() < publicAPI.getMTime()) {
        let opaque = true;
        if (model.nanColor[3] < 1.0) {
          opaque = 0;
        }
        if (model.useBelowRangeColor && model.belowRangeColor[3] < 1.0) {
          opaque = 0;
        }
        if (model.useAboveRangeColor && model.aboveRangeColor[3] < 1.0) {
          opaque = 0;
        }
        for (let i = 3; i < model.table.length && opaque; i += 4) {
          if (model.table[i] < 255) {
            opaque = false;
          }
        }
        model.opaqueFlag = opaque;
        model.opaqueFlagBuildTime.modified();
      }
      return model.opaqueFlag;
    };
    publicAPI.usingLogScale = () => false;

    //----------------------------------------------------------------------------
    publicAPI.getNumberOfAvailableColors = () => model.table.length / 4;

    //----------------------------------------------------------------------------
    // Apply shift/scale to the scalar value v and return the index.
    publicAPI.linearIndexLookup = (v, p) => {
      let dIndex = 0;
      const nv = Number(v);
      if (nv < p.range[0]) {
        dIndex = p.maxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
      } else if (nv > p.range[1]) {
        dIndex = p.maxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
      } else {
        dIndex = (nv + p.shift) * p.scale;

        // This conditional is needed because when v is very close to
        // p.Range[1], it may map above p.MaxIndex in the linear mapping
        // above.
        dIndex = dIndex < p.maxIndex ? dIndex : p.maxIndex;
      }
      return Math.floor(dIndex);
    };
    publicAPI.linearLookup = (v, table, p) => {
      let index = 0;
      if (isNan(v)) {
        index = Math.floor(p.maxIndex + 1.5 + NAN_COLOR_INDEX);
      } else {
        index = publicAPI.linearIndexLookup(v, p);
      }
      const offset = 4 * index;
      return table.slice(offset, offset + 4);
    };
    publicAPI.indexedLookupFunction = (v, table, p) => {
      let index = publicAPI.getAnnotatedValueIndexInternal(v);
      if (index === -1) {
        index = model.numberOfColors + NAN_COLOR_INDEX;
      }
      const offset = 4 * index;
      return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];
    };

    //----------------------------------------------------------------------------
    publicAPI.lookupShiftAndScale = (range, p) => {
      p.shift = -range[0];
      p.scale = Number.MAX_VALUE;
      if (range[1] > range[0]) {
        p.scale = (p.maxIndex + 1) / (range[1] - range[0]);
      }
    };

    // Public API methods
    publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {
      let lookupFunc = publicAPI.linearLookup;
      if (model.indexedLookup) {
        lookupFunc = publicAPI.indexedLookupFunction;
      }
      const trange = publicAPI.getMappingRange();
      const p = {
        maxIndex: publicAPI.getNumberOfColors() - 1,
        range: trange,
        shift: 0.0,
        scale: 0.0
      };
      publicAPI.lookupShiftAndScale(trange, p);
      const alpha = publicAPI.getAlpha();
      const length = input.getNumberOfTuples();
      const inIncr = input.getNumberOfComponents();
      const outputV = output.getData();
      const inputV = input.getData();
      if (alpha >= 1.0) {
        if (outFormat === ScalarMappingTarget$1.RGBA) {
          for (let i = 0; i < length; i++) {
            const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
            outputV[i * 4] = cptr[0];
            outputV[i * 4 + 1] = cptr[1];
            outputV[i * 4 + 2] = cptr[2];
            outputV[i * 4 + 3] = cptr[3];
          }
        }
      } else {
        /* eslint-disable no-lonely-if */
        if (outFormat === ScalarMappingTarget$1.RGBA) {
          for (let i = 0; i < length; i++) {
            const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
            outputV[i * 4] = cptr[0];
            outputV[i * 4 + 1] = cptr[1];
            outputV[i * 4 + 2] = cptr[2];
            outputV[i * 4 + 3] = Math.floor(cptr[3] * alpha + 0.5);
          }
        }
      } // alpha blending
    };

    publicAPI.forceBuild = () => {
      let hinc = 0.0;
      let sinc = 0.0;
      let vinc = 0.0;
      let ainc = 0.0;
      const maxIndex = model.numberOfColors - 1;
      if (maxIndex) {
        hinc = (model.hueRange[1] - model.hueRange[0]) / maxIndex;
        sinc = (model.saturationRange[1] - model.saturationRange[0]) / maxIndex;
        vinc = (model.valueRange[1] - model.valueRange[0]) / maxIndex;
        ainc = (model.alphaRange[1] - model.alphaRange[0]) / maxIndex;
      }
      model.table.length = 4 * maxIndex + 16;
      const hsv = [];
      const rgba = [];
      for (let i = 0; i <= maxIndex; i++) {
        hsv[0] = model.hueRange[0] + i * hinc;
        hsv[1] = model.saturationRange[0] + i * sinc;
        hsv[2] = model.valueRange[0] + i * vinc;
        hsv2rgb(hsv, rgba);
        rgba[3] = model.alphaRange[0] + i * ainc;

        //  case VTK_RAMP_LINEAR:
        model.table[i * 4] = rgba[0] * 255.0 + 0.5;
        model.table[i * 4 + 1] = rgba[1] * 255.0 + 0.5;
        model.table[i * 4 + 2] = rgba[2] * 255.0 + 0.5;
        model.table[i * 4 + 3] = rgba[3] * 255.0 + 0.5;
      }
      publicAPI.buildSpecialColors();
      model.buildTime.modified();
    };
    publicAPI.setTable = table => {
      // Handle JS array (assume 2D array)
      if (Array.isArray(table)) {
        const nbComponents = table[0].length;
        model.numberOfColors = table.length;
        const colorOffset = 4 - nbComponents;
        let offset = 0;
        // fill table
        for (let i = 0; i < model.numberOfColors; i++) {
          model.table[i * 4] = 255;
          model.table[i * 4 + 1] = 255;
          model.table[i * 4 + 2] = 255;
          model.table[i * 4 + 3] = 255;
        }
        // extract colors
        for (let i = 0; i < table.length; i++) {
          const color = table[i];
          for (let j = 0; j < nbComponents; j++) {
            model.table[offset++] = color[j];
          }
          offset += colorOffset;
        }
        publicAPI.buildSpecialColors();
        model.insertTime.modified();
        publicAPI.modified();
        return true;
      }
      if (table.getNumberOfComponents() !== 4) {
        vtkErrorMacro$o('Expected 4 components for RGBA colors');
        return false;
      }
      if (table.getDataType() !== VtkDataTypes$5.UNSIGNED_CHAR) {
        vtkErrorMacro$o('Expected unsigned char values for RGBA colors');
        return false;
      }
      model.numberOfColors = table.getNumberOfTuples();
      const data = table.getData();
      model.table.length = data.length;
      for (let i = 0; i < data.length; i++) {
        model.table[i] = data[i];
      }
      publicAPI.buildSpecialColors();
      model.insertTime.modified();
      publicAPI.modified();
      return true;
    };
    publicAPI.buildSpecialColors = () => {
      // Add "special" colors (NaN, below range, above range) to table here.
      const {
        numberOfColors
      } = model;
      const tptr = model.table;
      let base = (numberOfColors + BELOW_RANGE_COLOR_INDEX) * 4;

      // Below range color
      if (model.useBelowRangeColor || numberOfColors === 0) {
        tptr[base] = model.belowRangeColor[0] * 255.0 + 0.5;
        tptr[base + 1] = model.belowRangeColor[1] * 255.0 + 0.5;
        tptr[base + 2] = model.belowRangeColor[2] * 255.0 + 0.5;
        tptr[base + 3] = model.belowRangeColor[3] * 255.0 + 0.5;
      } else {
        // Duplicate the first color in the table.
        tptr[base] = tptr[0];
        tptr[base + 1] = tptr[1];
        tptr[base + 2] = tptr[2];
        tptr[base + 3] = tptr[3];
      }

      // Above range color
      base = (numberOfColors + ABOVE_RANGE_COLOR_INDEX) * 4;
      if (model.useAboveRangeColor || numberOfColors === 0) {
        tptr[base] = model.aboveRangeColor[0] * 255.0 + 0.5;
        tptr[base + 1] = model.aboveRangeColor[1] * 255.0 + 0.5;
        tptr[base + 2] = model.aboveRangeColor[2] * 255.0 + 0.5;
        tptr[base + 3] = model.aboveRangeColor[3] * 255.0 + 0.5;
      } else {
        // Duplicate the last color in the table.
        tptr[base] = tptr[4 * (numberOfColors - 1) + 0];
        tptr[base + 1] = tptr[4 * (numberOfColors - 1) + 1];
        tptr[base + 2] = tptr[4 * (numberOfColors - 1) + 2];
        tptr[base + 3] = tptr[4 * (numberOfColors - 1) + 3];
      }

      // Always use NanColor
      base = (numberOfColors + NAN_COLOR_INDEX) * 4;
      tptr[base] = model.nanColor[0] * 255.0 + 0.5;
      tptr[base + 1] = model.nanColor[1] * 255.0 + 0.5;
      tptr[base + 2] = model.nanColor[2] * 255.0 + 0.5;
      tptr[base + 3] = model.nanColor[3] * 255.0 + 0.5;
    };
    publicAPI.build = () => {
      if (model.table.length < 1 || publicAPI.getMTime() > model.buildTime.getMTime() && model.insertTime.getMTime() <= model.buildTime.getMTime()) {
        publicAPI.forceBuild();
      }
    };
    if (model.table.length > 0) {
      // Ensure that special colors are properly included in the table
      publicAPI.buildSpecialColors();

      // ensure insertTime is more recently modified than buildTime if
      // a table is provided via the constructor
      model.insertTime.modified();
    }
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1k = {
    numberOfColors: 256,
    // table: null,

    hueRange: [0.0, 0.66667],
    saturationRange: [1.0, 1.0],
    valueRange: [1.0, 1.0],
    alphaRange: [1.0, 1.0],
    nanColor: [0.5, 0.0, 0.0, 1.0],
    belowRangeColor: [0.0, 0.0, 0.0, 1.0],
    aboveRangeColor: [1.0, 1.0, 1.0, 1.0],
    useAboveRangeColor: false,
    useBelowRangeColor: false,
    alpha: 1.0
    // buildTime: null,
    // opaqueFlagBuildTime: null,
    // insertTime: null,
  };

  // ----------------------------------------------------------------------------

  function extend$1o(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1k, initialValues);

    // Inheritance
    vtkScalarsToColors$1.extend(publicAPI, model, initialValues);

    // Internal objects initialization
    if (!model.table) {
      model.table = [];
    }
    model.buildTime = {};
    macro.obj(model.buildTime);
    model.opaqueFlagBuildTime = {};
    macro.obj(model.opaqueFlagBuildTime, {
      mtime: 0
    });
    model.insertTime = {};
    macro.obj(model.insertTime, {
      mtime: 0
    });

    // Create get-only macros
    macro.get(publicAPI, model, ['buildTime']);

    // Create get-set macros
    macro.setGet(publicAPI, model, ['numberOfColors', 'useAboveRangeColor', 'useBelowRangeColor']);

    // Create set macros for array (needs to know size)
    macro.setArray(publicAPI, model, ['alphaRange', 'hueRange', 'saturationRange', 'valueRange'], 2);
    macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4);

    // Create get macros for array
    macro.getArray(publicAPI, model, ['hueRange', 'saturationRange', 'valueRange', 'alphaRange', 'nanColor', 'belowRangeColor', 'aboveRangeColor']);

    // For more macro methods, see "Sources/macros.js"

    // Object specific methods
    vtkLookupTable(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1o = macro.newInstance(extend$1o, 'vtkLookupTable');

  // ----------------------------------------------------------------------------

  var vtkLookupTable$1 = {
    newInstance: newInstance$1o,
    extend: extend$1o
  };

  let resolveCoincidentTopologyPolygonOffsetFaces = 1;
  let resolveCoincidentTopology = 0;
  const RESOLVE_COINCIDENT_TOPOLOGY_MODE = ['VTK_RESOLVE_OFF', 'VTK_RESOLVE_POLYGON_OFFSET'];
  function getResolveCoincidentTopologyPolygonOffsetFaces() {
    return resolveCoincidentTopologyPolygonOffsetFaces;
  }
  function setResolveCoincidentTopologyPolygonOffsetFaces(value) {
    resolveCoincidentTopologyPolygonOffsetFaces = value;
  }
  function getResolveCoincidentTopology() {
    return resolveCoincidentTopology;
  }
  function setResolveCoincidentTopology() {
    let mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    resolveCoincidentTopology = mode;
  }
  function setResolveCoincidentTopologyToDefault() {
    setResolveCoincidentTopology(0); // VTK_RESOLVE_OFF
  }

  function setResolveCoincidentTopologyToOff() {
    setResolveCoincidentTopology(0); // VTK_RESOLVE_OFF
  }

  function setResolveCoincidentTopologyToPolygonOffset() {
    setResolveCoincidentTopology(1); // VTK_RESOLVE_POLYGON_OFFSET
  }

  function getResolveCoincidentTopologyAsString() {
    return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];
  }
  var otherStaticMethods$1 = {
    getResolveCoincidentTopologyAsString,
    getResolveCoincidentTopologyPolygonOffsetFaces,
    getResolveCoincidentTopology,
    setResolveCoincidentTopology,
    setResolveCoincidentTopologyPolygonOffsetFaces,
    setResolveCoincidentTopologyToDefault,
    setResolveCoincidentTopologyToOff,
    setResolveCoincidentTopologyToPolygonOffset
  };

  /* eslint-disable arrow-body-style */
  function addCoincidentTopologyMethods(publicAPI, model, nameList) {
    nameList.forEach(item => {
      publicAPI[`get${item.method}`] = () => model[item.key];
      publicAPI[`set${item.method}`] = (factor, offset) => {
        model[item.key] = {
          factor,
          offset
        };
      };
    });
  }
  const CATEGORIES = ['Polygon', 'Line', 'Point'];

  // CoincidentTopology static methods ------------------------------------------

  const staticOffsetModel = {
    Polygon: {
      factor: 2,
      offset: 0
    },
    Line: {
      factor: 1,
      offset: -1
    },
    Point: {
      factor: 0,
      offset: -2
    }
  };
  const staticOffsetAPI$1 = {};
  addCoincidentTopologyMethods(staticOffsetAPI$1, staticOffsetModel, CATEGORIES.map(key => ({
    key,
    method: `ResolveCoincidentTopology${key}OffsetParameters`
  })));
  function implementCoincidentTopologyMethods(publicAPI, model) {
    if (model.resolveCoincidentTopology === undefined) {
      model.resolveCoincidentTopology = false;
    }
    macro.setGet(publicAPI, model, ['resolveCoincidentTopology']);

    // Relative methods
    model.topologyOffset = {
      Polygon: {
        factor: 0,
        offset: 0
      },
      Line: {
        factor: 0,
        offset: 0
      },
      Point: {
        factor: 0,
        offset: 0
      }
    };

    // Add Static methods to our instance
    Object.keys(otherStaticMethods$1).forEach(methodName => {
      publicAPI[methodName] = otherStaticMethods$1[methodName];
    });
    Object.keys(staticOffsetAPI$1).forEach(methodName => {
      publicAPI[methodName] = staticOffsetAPI$1[methodName];
    });
    addCoincidentTopologyMethods(publicAPI, model.topologyOffset, CATEGORIES.map(key => ({
      key,
      method: `RelativeCoincidentTopology${key}OffsetParameters`
    })));
    publicAPI.getCoincidentTopologyPolygonOffsetParameters = () => {
      const globalValue = staticOffsetAPI$1.getResolveCoincidentTopologyPolygonOffsetParameters();
      const localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();
      return {
        factor: globalValue.factor + localValue.factor,
        offset: globalValue.offset + localValue.offset
      };
    };
    publicAPI.getCoincidentTopologyLineOffsetParameters = () => {
      const globalValue = staticOffsetAPI$1.getResolveCoincidentTopologyLineOffsetParameters();
      const localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();
      return {
        factor: globalValue.factor + localValue.factor,
        offset: globalValue.offset + localValue.offset
      };
    };
    publicAPI.getCoincidentTopologyPointOffsetParameter = () => {
      const globalValue = staticOffsetAPI$1.getResolveCoincidentTopologyPointOffsetParameters();
      const localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();
      return {
        factor: globalValue.factor + localValue.factor,
        offset: globalValue.offset + localValue.offset
      };
    };
  }
  var CoincidentTopologyHelper = {
    implementCoincidentTopologyMethods,
    staticOffsetAPI: staticOffsetAPI$1,
    otherStaticMethods: otherStaticMethods$1,
    CATEGORIES
  };

  const PassTypes$1 = {
    MIN_KNOWN_PASS: 0,
    ACTOR_PASS: 0,
    COMPOSITE_INDEX_PASS: 1,
    ID_LOW24: 2,
    ID_HIGH24: 3,
    MAX_KNOWN_PASS: 3
  };
  var Constants$7 = {
    PassTypes: PassTypes$1
  };

  const {
    FieldAssociations: FieldAssociations$4
  } = vtkDataSet$1;
  const {
    staticOffsetAPI,
    otherStaticMethods
  } = CoincidentTopologyHelper;
  const {
    ColorMode: ColorMode$1,
    ScalarMode: ScalarMode$4,
    GetArray: GetArray$1
  } = Constants$8;
  const {
    VectorMode: VectorMode$1
  } = vtkScalarsToColors$2;
  const {
    VtkDataTypes: VtkDataTypes$3
  } = vtkDataArray$1;

  // ----------------------------------------------------------------------------

  function notImplemented$2(method) {
    return () => macro.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);
  }

  // ----------------------------------------------------------------------------
  // vtkMapper methods
  // ----------------------------------------------------------------------------

  function vtkMapper(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkMapper');
    publicAPI.getBounds = () => {
      const input = publicAPI.getInputData();
      if (!input) {
        model.bounds = createUninitializedBounds();
      } else {
        if (!model.static) {
          publicAPI.update();
        }
        model.bounds = input.getBounds();
      }
      return model.bounds;
    };
    publicAPI.setForceCompileOnly = v => {
      model.forceCompileOnly = v;
      // make sure we do NOT call modified()
    };

    publicAPI.setSelectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds => {
      model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds;
      // make sure we do NOT call modified()
      // this attribute is only used when processing a selection made with the hardware selector
      // the mtime of the mapper doesn't need to be changed
    };

    publicAPI.createDefaultLookupTable = () => {
      model.lookupTable = vtkLookupTable$1.newInstance();
    };
    publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode$1, model.colorMode);
    publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
    publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
    publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);
    publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode$4, model.scalarMode);
    publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
    publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
    publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
    publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
    publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
    publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);
    publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {
      // make sure we have an input
      if (!input || !model.scalarVisibility) {
        return {
          scalars: null,
          cellFLag: false
        };
      }
      let scalars = null;
      let cellFlag = false;

      // get and scalar data according to scalar mode
      if (scalarMode === ScalarMode$4.DEFAULT) {
        scalars = input.getPointData().getScalars();
        if (!scalars) {
          scalars = input.getCellData().getScalars();
          cellFlag = true;
        }
      } else if (scalarMode === ScalarMode$4.USE_POINT_DATA) {
        scalars = input.getPointData().getScalars();
      } else if (scalarMode === ScalarMode$4.USE_CELL_DATA) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      } else if (scalarMode === ScalarMode$4.USE_POINT_FIELD_DATA) {
        const pd = input.getPointData();
        if (arrayAccessMode === GetArray$1.BY_ID) {
          scalars = pd.getArrayByIndex(arrayId);
        } else {
          scalars = pd.getArrayByName(arrayName);
        }
      } else if (scalarMode === ScalarMode$4.USE_CELL_FIELD_DATA) {
        const cd = input.getCellData();
        cellFlag = true;
        if (arrayAccessMode === GetArray$1.BY_ID) {
          scalars = cd.getArrayByIndex(arrayId);
        } else {
          scalars = cd.getArrayByName(arrayName);
        }
      } else if (scalarMode === ScalarMode$4.USE_FIELD_DATA) {
        const fd = input.getFieldData();
        if (arrayAccessMode === GetArray$1.BY_ID) {
          scalars = fd.getArrayByIndex(arrayId);
        } else {
          scalars = fd.getArrayByName(arrayName);
        }
      }
      return {
        scalars,
        cellFlag
      };
    };
    publicAPI.mapScalars = (input, alpha) => {
      const scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;
      if (!scalars) {
        model.colorCoordinates = null;
        model.colorTextureMap = null;
        model.colorMapColors = null;
        return;
      }

      // we want to only recompute when something has changed
      const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
      if (model.colorBuildString === toString) return;
      if (!model.useLookupTableScalarRange) {
        publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
      }

      // Decide between texture color or vertex color.
      // Cell data always uses vertex color.
      // Only point data can use both texture and vertex coloring.
      if (publicAPI.canUseTextureMapForColoring(input)) {
        publicAPI.mapScalarsToTexture(scalars, alpha);
      } else {
        model.colorCoordinates = null;
        model.colorTextureMap = null;
        const lut = publicAPI.getLookupTable();
        if (lut) {
          // Ensure that the lookup table is built
          lut.build();
          model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
        }
      }
      model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
    };

    //-----------------------------------------------------------------------------
    publicAPI.scalarToTextureCoordinate = (scalarValue,
    // Input scalar
    rangeMin,
    // range[0]
    invRangeWidth) => {
      // 1/(range[1]-range[0])
      let texCoordS = 0.5; // Scalar value is arbitrary when NaN
      let texCoordT = 1.0; // 1.0 in t coordinate means NaN
      if (!isNan(scalarValue)) {
        // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?
        // Because when you are mapping scalars and you have a NaN adjacent to
        // anything else, the interpolation everywhere should be NaN.  Thus, I
        // want the NaN color everywhere except right on the non-NaN neighbors.
        // To simulate this, I set the t coord for the real numbers close to
        // the threshold so that the interpolation almost immediately looks up
        // the NaN value.
        texCoordT = 0.49;
        texCoordS = (scalarValue - rangeMin) * invRangeWidth;

        // Some implementations apparently don't handle relatively large
        // numbers (compared to the range [0.0, 1.0]) very well. In fact,
        // values above 1122.0f appear to cause texture wrap-around on
        // some systems even when edge clamping is enabled. Why 1122.0f? I
        // don't know. For safety, we'll clamp at +/- 1000. This will
        // result in incorrect images when the texture value should be
        // above or below 1000, but I don't have a better solution.
        if (texCoordS > 1000.0) {
          texCoordS = 1000.0;
        } else if (texCoordS < -1000.0) {
          texCoordS = -1000.0;
        }
      }
      return {
        texCoordS,
        texCoordT
      };
    };

    //-----------------------------------------------------------------------------
    publicAPI.createColorTextureCoordinates = (input, output, numScalars, numComps, component, range, tableRange, tableNumberOfColors, useLogScale) => {
      // We have to change the range used for computing texture
      // coordinates slightly to accommodate the special above- and
      // below-range colors that are the first and last texels,
      // respectively.
      const scalarTexelWidth = (range[1] - range[0]) / tableNumberOfColors;
      const paddedRange = [];
      paddedRange[0] = range[0] - scalarTexelWidth;
      paddedRange[1] = range[1] + scalarTexelWidth;
      const invRangeWidth = 1.0 / (paddedRange[1] - paddedRange[0]);
      const outputV = output.getData();
      const inputV = input.getData();
      let count = 0;
      let outputCount = 0;
      if (component < 0 || component >= numComps) {
        for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
          let sum = 0;
          for (let compIdx = 0; compIdx < numComps; ++compIdx) {
            sum += inputV[count] * inputV[count];
            count++;
          }
          let magnitude = Math.sqrt(sum);
          if (useLogScale) {
            magnitude = vtkLookupTable$1.applyLogScale(magnitude, tableRange, range);
          }
          const outputs = publicAPI.scalarToTextureCoordinate(magnitude, paddedRange[0], invRangeWidth);
          outputV[outputCount] = outputs.texCoordS;
          outputV[outputCount + 1] = outputs.texCoordT;
          outputCount += 2;
        }
      } else {
        count += component;
        for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
          let inputValue = inputV[count];
          if (useLogScale) {
            inputValue = vtkLookupTable$1.applyLogScale(inputValue, tableRange, range);
          }
          const outputs = publicAPI.scalarToTextureCoordinate(inputValue, paddedRange[0], invRangeWidth);
          outputV[outputCount] = outputs.texCoordS;
          outputV[outputCount + 1] = outputs.texCoordT;
          outputCount += 2;
          count += numComps;
        }
      }
    };
    publicAPI.mapScalarsToTexture = (scalars, alpha) => {
      const range = model.lookupTable.getRange();
      const useLogScale = model.lookupTable.usingLogScale();
      if (useLogScale) {
        // convert range to log.
        vtkLookupTable$1.getLogRange(range, range);
      }
      const origAlpha = model.lookupTable.getAlpha();

      // Get rid of vertex color array.  Only texture or vertex coloring
      // can be active at one time.  The existence of the array is the
      // signal to use that technique.
      model.colorMapColors = null;

      // If the lookup table has changed, then recreate the color texture map.
      // Set a new lookup table changes this->MTime.
      if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {
        model.lookupTable.setAlpha(alpha);
        model.colorTextureMap = null;

        // Get the texture map from the lookup table.
        // Create a dummy ramp of scalars.
        // In the future, we could extend vtkScalarsToColors.
        model.lookupTable.build();
        let numberOfColors = model.lookupTable.getNumberOfAvailableColors();
        if (numberOfColors > 4094) {
          numberOfColors = 4094;
        }
        if (numberOfColors < 64) {
          numberOfColors = 64;
        }
        numberOfColors += 2;
        const k = (range[1] - range[0]) / (numberOfColors - 2);
        const newArray = new Float64Array(numberOfColors * 2);
        for (let i = 0; i < numberOfColors; ++i) {
          newArray[i] = range[0] + i * k - k / 2.0; // minus k / 2 to start at below range color
          if (useLogScale) {
            newArray[i] = 10.0 ** newArray[i];
          }
        }
        // Dimension on NaN.
        for (let i = 0; i < numberOfColors; ++i) {
          newArray[i + numberOfColors] = NaN;
        }
        model.colorTextureMap = vtkImageData$1.newInstance();
        model.colorTextureMap.setExtent(0, numberOfColors - 1, 0, 1, 0, 0);
        const tmp = vtkDataArray$1.newInstance({
          numberOfComponents: 1,
          values: newArray
        });
        model.colorTextureMap.getPointData().setScalars(model.lookupTable.mapScalars(tmp, model.colorMode, 0));
        model.lookupTable.setAlpha(origAlpha);
      }

      // Create new coordinates if necessary.
      // Need to compare lookup table in case the range has changed.
      if (!model.colorCoordinates || publicAPI.getMTime() > model.colorCoordinates.getMTime() || publicAPI.getInputData(0).getMTime() > model.colorCoordinates.getMTime() || model.lookupTable.getMTime() > model.colorCoordinates.getMTime()) {
        // Get rid of old colors
        model.colorCoordinates = null;

        // Now create the color texture coordinates.
        const numComps = scalars.getNumberOfComponents();
        const num = scalars.getNumberOfTuples();

        // const fArray = new FloatArray(num * 2);
        model.colorCoordinates = vtkDataArray$1.newInstance({
          numberOfComponents: 2,
          values: new Float32Array(num * 2)
        });
        let scalarComponent = model.lookupTable.getVectorComponent();
        // Although I like the feature of applying magnitude to single component
        // scalars, it is not how the old MapScalars for vertex coloring works.
        if (model.lookupTable.getVectorMode() === VectorMode$1.MAGNITUDE && scalars.getNumberOfComponents() > 1) {
          scalarComponent = -1;
        }
        publicAPI.createColorTextureCoordinates(scalars, model.colorCoordinates, num, numComps, scalarComponent, range, model.lookupTable.getRange(), model.colorTextureMap.getPointData().getScalars().getNumberOfTuples() / 2 - 2, useLogScale);
      }
    };
    publicAPI.getIsOpaque = () => {
      const input = publicAPI.getInputData();
      const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
      const scalars = gasResult.scalars;
      if (!model.scalarVisibility || scalars == null) {
        // No scalar colors.
        return true;
      }
      const lut = publicAPI.getLookupTable();
      if (lut) {
        // Ensure that the lookup table is built
        lut.build();
        return lut.areScalarsOpaque(scalars, model.colorMode, -1);
      }
      return true;
    };
    publicAPI.canUseTextureMapForColoring = input => {
      if (!model.interpolateScalarsBeforeMapping) {
        return false; // user doesn't want us to use texture maps at all.
      }

      // index color does not use textures
      if (model.lookupTable && model.lookupTable.getIndexedLookup()) {
        return false;
      }
      const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
      const scalars = gasResult.scalars;
      if (!scalars) {
        // no scalars on this dataset, we don't care if texture is used at all.
        return false;
      }
      if (gasResult.cellFlag) {
        return false; // cell data colors, don't use textures.
      }

      if (model.colorMode === ColorMode$1.DEFAULT && scalars.getDataType() === VtkDataTypes$3.UNSIGNED_CHAR || model.colorMode === ColorMode$1.DIRECT_SCALARS) {
        // Don't use texture is direct coloring using RGB unsigned chars is
        // requested.
        return false;
      }
      return true;
    };
    publicAPI.clearColorArrays = () => {
      model.colorMapColors = null;
      model.colorCoordinates = null;
      model.colorTextureMap = null;
    };
    publicAPI.getLookupTable = () => {
      if (!model.lookupTable) {
        publicAPI.createDefaultLookupTable();
      }
      return model.lookupTable;
    };
    publicAPI.getMTime = () => {
      let mt = model.mtime;
      if (model.lookupTable !== null) {
        const time = model.lookupTable.getMTime();
        mt = time > mt ? time : mt;
      }
      return mt;
    };
    publicAPI.getPrimitiveCount = () => {
      const input = publicAPI.getInputData();
      const pcount = {
        points: input.getPoints().getNumberOfValues() / 3,
        verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
        lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
        triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
      };
      return pcount;
    };
    publicAPI.acquireInvertibleLookupTable = notImplemented$2('AcquireInvertibleLookupTable');
    publicAPI.valueToColor = notImplemented$2('ValueToColor');
    publicAPI.colorToValue = notImplemented$2('ColorToValue');
    publicAPI.useInvertibleColorFor = notImplemented$2('UseInvertibleColorFor');
    publicAPI.clearInvertibleColor = notImplemented$2('ClearInvertibleColor');
    publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
      /* eslint-disable no-bitwise */
      if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {
        return;
      }
      const rawLowData = selector.getRawPixelBuffer(PassTypes$1.ID_LOW24);
      const rawHighData = selector.getRawPixelBuffer(PassTypes$1.ID_HIGH24);
      const currentPass = selector.getCurrentPass();
      const fieldAssociation = selector.getFieldAssociation();
      let idMap = null;
      if (fieldAssociation === FieldAssociations$4.FIELD_ASSOCIATION_POINTS) {
        idMap = model.selectionWebGLIdsToVTKIds.points;
      } else if (fieldAssociation === FieldAssociations$4.FIELD_ASSOCIATION_CELLS) {
        idMap = model.selectionWebGLIdsToVTKIds.cells;
      }
      if (!idMap) {
        return;
      }
      pixelOffsets.forEach(pos => {
        if (currentPass === PassTypes$1.ID_LOW24) {
          let inValue = 0;
          if (rawHighData) {
            inValue += rawHighData[pos];
            inValue *= 256;
          }
          inValue += rawLowData[pos + 2];
          inValue *= 256;
          inValue += rawLowData[pos + 1];
          inValue *= 256;
          inValue += rawLowData[pos];
          const outValue = idMap[inValue];
          const lowData = selector.getPixelBuffer(PassTypes$1.ID_LOW24);
          lowData[pos] = outValue & 0xff;
          lowData[pos + 1] = (outValue & 0xff00) >> 8;
          lowData[pos + 2] = (outValue & 0xff0000) >> 16;
        } else if (currentPass === PassTypes$1.ID_HIGH24 && rawHighData) {
          let inValue = 0;
          inValue += rawHighData[pos];
          inValue *= 256;
          inValue += rawLowData[pos];
          inValue *= 256;
          inValue += rawLowData[pos + 1];
          inValue *= 256;
          inValue += rawLowData[pos + 2];
          const outValue = idMap[inValue];
          const highData = selector.getPixelBuffer(PassTypes$1.ID_HIGH24);
          highData[pos] = (outValue & 0xff000000) >> 24;
        }
      });
      /* eslint-enable no-bitwise */
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1j = {
    colorMapColors: null,
    // Same as this->Colors

    static: false,
    lookupTable: null,
    scalarVisibility: true,
    scalarRange: [0, 1],
    useLookupTableScalarRange: false,
    colorMode: 0,
    scalarMode: 0,
    arrayAccessMode: 1,
    // By_NAME

    renderTime: 0,
    colorByArrayName: null,
    fieldDataTupleId: -1,
    populateSelectionSettings: true,
    selectionWebGLIdsToVTKIds: null,
    interpolateScalarsBeforeMapping: false,
    colorCoordinates: null,
    colorTextureMap: null,
    forceCompileOnly: 0,
    useInvertibleColors: false,
    invertibleScalars: null,
    customShaderAttributes: []
  };

  // ----------------------------------------------------------------------------

  function extend$1n(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1j, initialValues);

    // Inheritance
    vtkAbstractMapper3D$1.extend(publicAPI, model, initialValues);
    macro.get(publicAPI, model, ['colorCoordinates', 'colorMapColors', 'colorTextureMap', 'selectionWebGLIdsToVTKIds']);
    macro.setGet(publicAPI, model, ['colorByArrayName', 'arrayAccessMode', 'colorMode', 'fieldDataTupleId', 'interpolateScalarsBeforeMapping', 'lookupTable', 'populateSelectionSettings', 'renderTime', 'scalarMode', 'scalarVisibility', 'static', 'useLookupTableScalarRange', 'customShaderAttributes' // point data array names that will be transferred to the VBO
    ]);

    macro.setGetArray(publicAPI, model, ['scalarRange'], 2);
    CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);

    // Object methods
    vtkMapper(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1n = macro.newInstance(extend$1n, 'vtkMapper');

  // ----------------------------------------------------------------------------

  var vtkMapper$1 = {
    newInstance: newInstance$1n,
    extend: extend$1n,
    ...staticOffsetAPI,
    ...otherStaticMethods,
    ...Constants$8
  };

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  function extractCellSizes(cellArray) {
    let currentIdx = 0;
    return cellArray.filter((value, index) => {
      if (index === currentIdx) {
        currentIdx += value + 1;
        return true;
      }
      return false;
    });
  }
  function getNumberOfCells(cellArray) {
    let cellId = 0;
    for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length;) {
      cellArrayIndex += cellArray[cellArrayIndex] + 1;
      cellId++;
    }
    return cellId;
  }

  // ----------------------------------------------------------------------------
  // Static API
  // ----------------------------------------------------------------------------

  const STATIC$7 = {
    extractCellSizes,
    getNumberOfCells
  };

  // ----------------------------------------------------------------------------
  // vtkCellArray methods
  // ----------------------------------------------------------------------------

  function vtkCellArray(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkCellArray');
    const superClass = {
      ...publicAPI
    };
    publicAPI.getNumberOfCells = recompute => {
      if (model.numberOfCells !== undefined && !recompute) {
        return model.numberOfCells;
      }
      if (model.cellSizes) {
        model.numberOfCells = model.cellSizes.length;
      } else {
        model.numberOfCells = getNumberOfCells(publicAPI.getData());
      }
      return model.numberOfCells;
    };
    publicAPI.getCellSizes = recompute => {
      if (model.cellSizes !== undefined && !recompute) {
        return model.cellSizes;
      }
      model.cellSizes = extractCellSizes(publicAPI.getData());
      return model.cellSizes;
    };

    /**
     * When `resize()` is being used, you then MUST use `insertNextCell()`.
     */
    publicAPI.resize = requestedNumTuples => {
      const oldNumTuples = publicAPI.getNumberOfTuples();
      superClass.resize(requestedNumTuples);
      const newNumTuples = publicAPI.getNumberOfTuples();
      if (newNumTuples < oldNumTuples) {
        if (newNumTuples === 0) {
          model.numberOfCells = 0;
          model.cellSizes = [];
        } else {
          // We do not know how many cells are left.
          // Set to undefined to ensure insertNextCell works correctly.
          model.numberOfCells = undefined;
          model.cellSizes = undefined;
        }
      }
    };
    publicAPI.setData = typedArray => {
      superClass.setData(typedArray, 1);
      model.numberOfCells = undefined;
      model.cellSizes = undefined;
    };
    publicAPI.getCell = loc => {
      let cellLoc = loc;
      const numberOfPoints = model.values[cellLoc++];
      return model.values.subarray(cellLoc, cellLoc + numberOfPoints);
    };
    publicAPI.insertNextCell = cellPointIds => {
      const cellId = publicAPI.getNumberOfCells();
      publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);
      // By computing the number of cells earlier, we made sure that numberOfCells is defined
      ++model.numberOfCells;
      if (model.cellSizes != null) {
        model.cellSizes.push(cellPointIds.length);
      }
      return cellId;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  function defaultValues$3(initialValues) {
    return {
      empty: true,
      numberOfComponents: 1,
      dataType: VtkDataTypes$5.UNSIGNED_INT,
      ...initialValues
    };
  }

  // ----------------------------------------------------------------------------

  function extend$1m(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    vtkDataArray$1.extend(publicAPI, model, defaultValues$3(initialValues));
    vtkCellArray(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1m = macro.newInstance(extend$1m, 'vtkCellArray');

  // ----------------------------------------------------------------------------

  var vtkCellArray$1 = {
    newInstance: newInstance$1m,
    extend: extend$1m,
    ...STATIC$7
  };

  const {
    vtkErrorMacro: vtkErrorMacro$n
  } = macro;
  const INVALID_BOUNDS = [1, -1, 1, -1, 1, -1];

  // ----------------------------------------------------------------------------
  // vtkPoints methods
  // ----------------------------------------------------------------------------

  function vtkPoints(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkPoints');

    // Forwarding methods
    publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;
    publicAPI.setNumberOfPoints = function (nbPoints) {
      let dimension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
      if (publicAPI.getNumberOfPoints() !== nbPoints) {
        model.size = nbPoints * dimension;
        model.values = macro.newTypedArray(model.dataType, model.size);
        publicAPI.setNumberOfComponents(dimension);
        publicAPI.modified();
      }
    };
    publicAPI.setPoint = function (idx) {
      for (var _len = arguments.length, xyz = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        xyz[_key - 1] = arguments[_key];
      }
      publicAPI.setTuple(idx, xyz);
    };
    publicAPI.getPoint = publicAPI.getTuple;
    publicAPI.findPoint = publicAPI.findTuple;
    publicAPI.insertNextPoint = (x, y, z) => publicAPI.insertNextTuple([x, y, z]);
    publicAPI.getBounds = () => {
      if (publicAPI.getNumberOfComponents() === 3) {
        const xRange = publicAPI.getRange(0);
        model.bounds[0] = xRange[0];
        model.bounds[1] = xRange[1];
        const yRange = publicAPI.getRange(1);
        model.bounds[2] = yRange[0];
        model.bounds[3] = yRange[1];
        const zRange = publicAPI.getRange(2);
        model.bounds[4] = zRange[0];
        model.bounds[5] = zRange[1];
        return model.bounds;
      }
      if (publicAPI.getNumberOfComponents() !== 2) {
        vtkErrorMacro$n(`getBounds called on an array with components of
        ${publicAPI.getNumberOfComponents()}`);
        return INVALID_BOUNDS;
      }
      const xRange = publicAPI.getRange(0);
      model.bounds[0] = xRange[0];
      model.bounds[1] = xRange[1];
      const yRange = publicAPI.getRange(1);
      model.bounds[2] = yRange[0];
      model.bounds[3] = yRange[1];
      model.bounds[4] = 0;
      model.bounds[5] = 0;
      return model.bounds;
    };

    // Trigger the computation of bounds
    publicAPI.computeBounds = publicAPI.getBounds;

    // Initialize
    publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1i = {
    empty: true,
    numberOfComponents: 3,
    dataType: VtkDataTypes$5.FLOAT,
    bounds: [1, -1, 1, -1, 1, -1]
  };

  // ----------------------------------------------------------------------------

  function extend$1l(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1i, initialValues);
    vtkDataArray$1.extend(publicAPI, model, initialValues);
    vtkPoints(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1l = macro.newInstance(extend$1l, 'vtkPoints');

  // ----------------------------------------------------------------------------

  var vtkPoints$1 = {
    newInstance: newInstance$1l,
    extend: extend$1l
  };

  // ----------------------------------------------------------------------------
  // vtkCell methods
  // ----------------------------------------------------------------------------

  function vtkCell(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkCell');
    publicAPI.initialize = function (points) {
      let pointIdsList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (!pointIdsList) {
        model.points = points;
        model.pointsIds = new Array(points.getNumberOfPoints());
        for (let i = points.getNumberOfPoints() - 1; i >= 0; --i) {
          model.pointsIds[i] = i;
        }
      } else {
        model.pointsIds = pointIdsList;
        let triangleData = model.points.getData();
        if (triangleData.length !== 3 * model.pointsIds.length) {
          triangleData = macro.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);
        }
        const pointsData = points.getData();
        model.pointsIds.forEach((pointId, index) => {
          // const start = 3 * pointId;
          // pointsData.set(p.subarray(start, start + 3), 3 * index);
          let pointOffset = 3 * pointId;
          let trianglePointOffset = 3 * index;
          triangleData[trianglePointOffset] = pointsData[pointOffset];
          triangleData[++trianglePointOffset] = pointsData[++pointOffset];
          triangleData[++trianglePointOffset] = pointsData[++pointOffset];
        });
        model.points.setData(triangleData);
      }
    };
    publicAPI.getBounds = () => {
      const nbPoints = model.points.getNumberOfPoints();
      const x = [];
      if (nbPoints) {
        model.points.getPoint(0, x);
        model.bounds[0] = x[0];
        model.bounds[1] = x[0];
        model.bounds[2] = x[1];
        model.bounds[3] = x[1];
        model.bounds[4] = x[2];
        model.bounds[5] = x[2];
        for (let i = 1; i < nbPoints; i++) {
          model.points.getPoint(i, x);
          model.bounds[0] = x[0] < model.bounds[0] ? x[0] : model.bounds[0];
          model.bounds[1] = x[0] > model.bounds[1] ? x[0] : model.bounds[1];
          model.bounds[2] = x[1] < model.bounds[2] ? x[1] : model.bounds[2];
          model.bounds[3] = x[1] > model.bounds[3] ? x[1] : model.bounds[3];
          model.bounds[4] = x[2] < model.bounds[4] ? x[2] : model.bounds[4];
          model.bounds[5] = x[2] > model.bounds[5] ? x[2] : model.bounds[5];
        }
      } else {
        uninitializeBounds(model.bounds);
      }
      return model.bounds;
    };
    publicAPI.getLength2 = () => {
      publicAPI.getBounds();
      let length = 0.0;
      let diff = 0;
      for (let i = 0; i < 3; i++) {
        diff = model.bounds[2 * i + 1] - model.bounds[2 * i];
        length += diff * diff;
      }
      return length;
    };
    publicAPI.getParametricDistance = pcoords => {
      let pDist;
      let pDistMax = 0.0;
      for (let i = 0; i < 3; i++) {
        if (pcoords[i] < 0.0) {
          pDist = -pcoords[i];
        } else if (pcoords[i] > 1.0) {
          pDist = pcoords[i] - 1.0;
        } else {
          // inside the cell in the parametric direction
          pDist = 0.0;
        }
        if (pDist > pDistMax) {
          pDistMax = pDist;
        }
      }
      return pDistMax;
    };
    publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
    publicAPI.deepCopy = cell => {
      cell.initialize(model.points, model.pointsIds);
    };
    publicAPI.getCellDimension = () => {}; // virtual
    publicAPI.intersectWithLine = (p1, p2, tol, t, x, pcoords, subId) => {}; // virtual
    publicAPI.evaluatePosition = (x, closestPoint, subId, pcoords, dist2, weights) => {
      macro.vtkErrorMacro('vtkCell.evaluatePosition is not implemented.');
    }; // virtual
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1h = {
    bounds: [-1, -1, -1, -1, -1, -1],
    pointsIds: []
  };

  // ----------------------------------------------------------------------------

  function extend$1k(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1h, initialValues);
    macro.obj(publicAPI, model);
    if (!model.points) {
      model.points = vtkPoints$1.newInstance();
    }
    macro.get(publicAPI, model, ['points', 'pointsIds']);
    vtkCell(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1k = macro.newInstance(extend$1k, 'vtkCell');

  // ----------------------------------------------------------------------------

  var vtkCell$1 = {
    newInstance: newInstance$1k,
    extend: extend$1k
  };

  function resize(model, sz) {
    let newSize = sz;
    if (sz >= model.array.length) {
      newSize += model.array.length;
    }
    while (newSize > model.array.length) model.array.push({
      ncells: 0,
      cells: null
    });
    model.array.length = newSize;
  }

  // ----------------------------------------------------------------------------
  // vtkCellLinks methods
  // ----------------------------------------------------------------------------

  function vtkCellLinks(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkCellLinks');

    /**
     * Build the link list array. All subclasses of vtkAbstractCellLinks
     * must support this method.
     */
    publicAPI.buildLinks = data => {
      const numPts = data.getPoints().getNumberOfPoints();
      const numCells = data.getNumberOfCells();

      // fill out lists with number of references to cells
      const linkLoc = new Uint32Array(numPts);

      // Use fast path if polydata
      if (data.isA('vtkPolyData')) {
        // traverse data to determine number of uses of each point
        for (let cellId = 0; cellId < numCells; ++cellId) {
          const {
            cellPointIds
          } = data.getCellPoints(cellId);
          cellPointIds.forEach(cellPointId => {
            publicAPI.incrementLinkCount(cellPointId);
          });
        }

        // now allocate storage for the links
        publicAPI.allocateLinks(numPts);
        model.maxId = numPts - 1;
        for (let cellId = 0; cellId < numCells; ++cellId) {
          const {
            cellPointIds
          } = data.getCellPoints(cellId);
          cellPointIds.forEach(cellPointId => {
            publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
          });
        }
      } // any other type of dataset
      else {
        // traverse data to determine number of uses of each point
        for (let cellId = 0; cellId < numCells; cellId++) {
          // TODO: Currently not supported: const cell = data.getCell(cellId);
          const cell = vtkCell$1.newInstance();
          cell.getPointsIds().forEach(cellPointId => {
            publicAPI.incrementLinkCount(cellPointId);
          });
        }

        // now allocate storage for the links
        publicAPI.allocateLinks(numPts);
        model.maxId = numPts - 1;
        for (let cellId = 0; cellId < numCells; ++cellId) {
          // TODO: Currently not supported: const cell = data.getCell(cellId);
          const cell = vtkCell$1.newInstance();
          cell.getPointsIds().forEach(cellPointId => {
            publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
          });
        }
      } // end else
    };

    /**
     * Build the link list array with a provided connectivity array.
     */
    // publicAPI.buildLinks = (data, connectivity) => {};

    /**
     * Allocate the specified number of links (i.e., number of points) that
     * will be built.
     */
    publicAPI.allocate = function (numLinks) {
      let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
      model.array = Array(numLinks).fill().map(() => ({
        ncells: 0,
        cells: null
      }));
      model.extend = ext;
      model.maxId = -1;
    };
    publicAPI.initialize = () => {
      model.array = null;
    };

    /**
     * Get a link structure given a point id.
     */
    publicAPI.getLink = ptId => model.array[ptId];

    /**
     * Get the number of cells using the point specified by ptId.
     */
    publicAPI.getNcells = ptId => model.array[ptId].ncells;

    /**
     * Return a list of cell ids using the point.
     */
    publicAPI.getCells = ptId => model.array[ptId].cells;

    /**
     * Insert a new point into the cell-links data structure. The size parameter
     * is the initial size of the list.
     */
    publicAPI.insertNextPoint = numLinks => {
      model.array.push({
        ncells: numLinks,
        cells: Array(numLinks)
      });
      ++model.maxId;
    };

    /**
     * Insert a cell id into the list of cells (at the end) using the cell id
     * provided. (Make sure to extend the link list (if necessary) using the
     * method resizeCellList().)
     */
    publicAPI.insertNextCellReference = (ptId, cellId) => {
      model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
    };

    /**
     * Delete point (and storage) by destroying links to using cells.
     */
    publicAPI.deletePoint = ptId => {
      model.array[ptId].ncells = 0;
      model.array[ptId].cells = null;
    };

    /**
     * Delete the reference to the cell (cellId) from the point (ptId). This
     * removes the reference to the cellId from the cell list, but does not
     * resize the list (recover memory with resizeCellList(), if necessary).
     */
    publicAPI.removeCellReference = (cellId, ptId) => {
      model.array[ptId].cells = model.array[ptId].cells.filter(cell => cell !== cellId);
      model.array[ptId].ncells = model.array[ptId].cells.length;
    };

    /**
     * Add the reference to the cell (cellId) from the point (ptId). This
     * adds a reference to the cellId from the cell list, but does not resize
     * the list (extend memory with resizeCellList(), if necessary).
     */
    publicAPI.addCellReference = (cellId, ptId) => {
      model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
    };

    /**
     * Change the length of a point's link list (i.e., list of cells using a
     * point) by the size specified.
     */
    publicAPI.resizeCellList = (ptId, size) => {
      model.array[ptId].cells.length = size;
    };

    /**
     * Reclaim any unused memory.
     */
    publicAPI.squeeze = () => {
      resize(model, model.maxId + 1);
    };

    /**
     * Reset to a state of no entries without freeing the memory.
     */
    publicAPI.reset = () => {
      model.maxId = -1;
    };

    /**
     * Standard DeepCopy method.  Since this object contains no reference
     * to other objects, there is no ShallowCopy.
     */
    publicAPI.deepCopy = src => {
      model.array = [...src.array];
      model.extend = src.extend;
      model.maxId = src.maxId;
    };

    /**
     * Increment the count of the number of cells using the point.
     */
    publicAPI.incrementLinkCount = ptId => {
      ++model.array[ptId].ncells;
    };
    publicAPI.allocateLinks = n => {
      for (let i = 0; i < n; ++i) {
        model.array[i].cells = new Array(model.array[i].ncells);
      }
    };

    /**
     * Insert a cell id into the list of cells using the point.
     */
    publicAPI.insertCellReference = (ptId, pos, cellId) => {
      model.array[ptId].cells[pos] = cellId;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1g = {
    array: null,
    // pointer to data
    maxId: 0,
    // maximum index inserted thus far
    extend: 0 // grow array by this point
  };

  // ----------------------------------------------------------------------------

  function extend$1j(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1g, initialValues);
    macro.obj(publicAPI, model);
    vtkCellLinks(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1j = macro.newInstance(extend$1j, 'vtkCellLinks');

  // ----------------------------------------------------------------------------

  var vtkCellLinks$1 = {
    newInstance: newInstance$1j,
    extend: extend$1j
  };

  const CellType = {
    // Linear cells
    VTK_EMPTY_CELL: 0,
    VTK_VERTEX: 1,
    VTK_POLY_VERTEX: 2,
    VTK_LINE: 3,
    VTK_POLY_LINE: 4,
    VTK_TRIANGLE: 5,
    VTK_TRIANGLE_STRIP: 6,
    VTK_POLYGON: 7,
    VTK_PIXEL: 8,
    VTK_QUAD: 9,
    VTK_TETRA: 10,
    VTK_VOXEL: 11,
    VTK_HEXAHEDRON: 12,
    VTK_WEDGE: 13,
    VTK_PYRAMID: 14,
    VTK_PENTAGONAL_PRISM: 15,
    VTK_HEXAGONAL_PRISM: 16,
    // Quadratic, isoparametric cells
    VTK_QUADRATIC_EDGE: 21,
    VTK_QUADRATIC_TRIANGLE: 22,
    VTK_QUADRATIC_QUAD: 23,
    VTK_QUADRATIC_POLYGON: 36,
    VTK_QUADRATIC_TETRA: 24,
    VTK_QUADRATIC_HEXAHEDRON: 25,
    VTK_QUADRATIC_WEDGE: 26,
    VTK_QUADRATIC_PYRAMID: 27,
    VTK_BIQUADRATIC_QUAD: 28,
    VTK_TRIQUADRATIC_HEXAHEDRON: 29,
    VTK_QUADRATIC_LINEAR_QUAD: 30,
    VTK_QUADRATIC_LINEAR_WEDGE: 31,
    VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,
    VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,
    VTK_BIQUADRATIC_TRIANGLE: 34,
    // Cubic, isoparametric cell
    VTK_CUBIC_LINE: 35,
    // Special class of cells formed by convex group of points
    VTK_CONVEX_POINT_SET: 41,
    // Polyhedron cell (consisting of polygonal faces)
    VTK_POLYHEDRON: 42,
    // Higher order cells in parametric form
    VTK_PARAMETRIC_CURVE: 51,
    VTK_PARAMETRIC_SURFACE: 52,
    VTK_PARAMETRIC_TRI_SURFACE: 53,
    VTK_PARAMETRIC_QUAD_SURFACE: 54,
    VTK_PARAMETRIC_TETRA_REGION: 55,
    VTK_PARAMETRIC_HEX_REGION: 56,
    // Higher order cells
    VTK_HIGHER_ORDER_EDGE: 60,
    VTK_HIGHER_ORDER_TRIANGLE: 61,
    VTK_HIGHER_ORDER_QUAD: 62,
    VTK_HIGHER_ORDER_POLYGON: 63,
    VTK_HIGHER_ORDER_TETRAHEDRON: 64,
    VTK_HIGHER_ORDER_WEDGE: 65,
    VTK_HIGHER_ORDER_PYRAMID: 66,
    VTK_HIGHER_ORDER_HEXAHEDRON: 67,
    // Arbitrary order Lagrange elements (formulated separated from generic higher order cells)
    VTK_LAGRANGE_CURVE: 68,
    VTK_LAGRANGE_TRIANGLE: 69,
    VTK_LAGRANGE_QUADRILATERAL: 70,
    VTK_LAGRANGE_TETRAHEDRON: 71,
    VTK_LAGRANGE_HEXAHEDRON: 72,
    VTK_LAGRANGE_WEDGE: 73,
    VTK_LAGRANGE_PYRAMID: 74,
    VTK_NUMBER_OF_CELL_TYPES: 75
  };

  // This list should contain the cell class names in
  // the same order as in CellType.
  const CellTypesStrings = ['vtkEmptyCell', 'vtkVertex', 'vtkPolyVertex', 'vtkLine', 'vtkPolyLine', 'vtkTriangle', 'vtkTriangleStrip', 'vtkPolygon', 'vtkPixel', 'vtkQuad', 'vtkTetra', 'vtkVoxel', 'vtkHexahedron', 'vtkWedge', 'vtkPyramid', 'vtkPentagonalPrism', 'vtkHexagonalPrism', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkQuadraticEdge', 'vtkQuadraticTriangle', 'vtkQuadraticQuad', 'vtkQuadraticTetra', 'vtkQuadraticHexahedron', 'vtkQuadraticWedge', 'vtkQuadraticPyramid', 'vtkBiQuadraticQuad', 'vtkTriQuadraticHexahedron', 'vtkQuadraticLinearQuad', 'vtkQuadraticLinearWedge', 'vtkBiQuadraticQuadraticWedge', 'vtkBiQuadraticQuadraticHexahedron', 'vtkBiQuadraticTriangle', 'vtkCubicLine', 'vtkQuadraticPolygon', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkConvexPointSet', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkParametricCurve', 'vtkParametricSurface', 'vtkParametricTriSurface', 'vtkParametricQuadSurface', 'vtkParametricTetraRegion', 'vtkParametricHexRegion', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkHigherOrderEdge', 'vtkHigherOrderTriangle', 'vtkHigherOrderQuad', 'vtkHigherOrderPolygon', 'vtkHigherOrderTetrahedron', 'vtkHigherOrderWedge', 'vtkHigherOrderPyramid', 'vtkHigherOrderHexahedron'];

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  /**
   * Given an int (as defined in vtkCellType.h) identifier for a class
   * return it's classname.
   */
  function getClassNameFromTypeId(typeId) {
    return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : 'UnknownClass';
  }

  /**
   * Given a data object classname, return it's int identified (as
   * defined in vtkCellType.h)
   */
  function getTypeIdFromClassName(cellTypeString) {
    return CellTypesStrings.findIndex(cellTypeString);
  }

  /**
   * This convenience method is a fast check to determine if a cell type
   * represents a linear or nonlinear cell.  This is generally much more
   * efficient than getting the appropriate vtkCell and checking its IsLinear
   * method.
   */
  function isLinear(type) {
    return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;
  }
  function hasSubCells(cellType) {
    return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;
  }

  // ----------------------------------------------------------------------------
  // Static API
  // ----------------------------------------------------------------------------

  const STATIC$6 = {
    getClassNameFromTypeId,
    getTypeIdFromClassName,
    isLinear,
    hasSubCells
  };

  // ----------------------------------------------------------------------------
  // vtkCellTypes methods
  // ----------------------------------------------------------------------------

  function vtkCellTypes(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkCellTypes');

    /**
     * Allocate memory for this array. Delete old storage only if necessary.
     */
    publicAPI.allocate = function () {
      let sz = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 512;
      let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
      model.size = sz > 0 ? sz : 1;
      model.extend = ext > 0 ? ext : 1;
      model.maxId = -1;
      model.typeArray = new Uint8Array(sz);
      model.locationArray = new Uint32Array(sz);
    };

    /**
     * Add a cell at specified id.
     */
    publicAPI.insertCell = (cellId, type, loc) => {
      model.typeArray[cellId] = type;
      model.locationArray[cellId] = loc;
      if (cellId > model.maxId) {
        model.maxId = cellId;
      }
    };

    /**
     * Add a cell to the object in the next available slot.
     */
    publicAPI.insertNextCell = (type, loc) => {
      publicAPI.insertCell(++model.maxId, type, loc);
      return model.maxId;
    };

    /**
     * Specify a group of cell types. This version is provided to maintain
     * backwards compatibility and does a copy of the cellLocations
     */
    publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {
      model.size = ncells;
      model.typeArray = cellTypes;
      model.locationArray = cellLocations;
      model.maxId = ncells - 1;
    };

    /**
     * Return the location of the cell in the associated vtkCellArray.
     */
    publicAPI.getCellLocation = cellId => model.locationArray[cellId];

    /**
     * Delete cell by setting to nullptr cell type.
     */
    publicAPI.deleteCell = cellId => {
      model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;
    };

    /**
     * Return the number of types in the list.
     */
    publicAPI.getNumberOfTypes = () => model.maxId + 1;

    /**
     * Return true if type specified is contained in list; false otherwise.
     */
    publicAPI.isType = type => {
      const numTypes = publicAPI.getNumberOfTypes();
      for (let i = 0; i < numTypes; ++i) {
        if (type === publicAPI.getCellType(i)) {
          return true;
        }
      }
      return false;
    };

    /**
     * Add the type specified to the end of the list. Range checking is performed.
     */
    publicAPI.insertNextType = type => publicAPI.insertNextCell(type, -1);

    /**
     * Return the type of cell.
     */
    publicAPI.getCellType = cellId => model.typeArray[cellId];

    /**
     * Reclaim any extra memory.
     */
    // TODO: publicAPI.squeeze = () =>  {};

    /**
     * Initialize object without releasing memory.
     */
    publicAPI.reset = () => {
      model.maxId = -1;
    };

    /**
     * Standard DeepCopy method.  Since this object contains no reference
     * to other objects, there is no ShallowCopy.
     */
    publicAPI.deepCopy = src => {
      publicAPI.allocate(src.getSize(), src.getExtend());
      model.typeArray.set(src.getTypeArray());
      model.locationArray.set(src.getLocationArray());
      model.maxId = src.getMaxId();
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1f = {
    // typeArray: null, // pointer to types array
    // locationArray: null;   // pointer to array of offsets
    size: 0,
    // allocated size of data
    maxId: -1,
    // maximum index inserted thus far
    extend: 1000 // grow array by this point
  };

  // ----------------------------------------------------------------------------

  function extend$1i(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1f, initialValues);
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ['size', 'maxId', 'extend']);
    macro.getArray(publicAPI, model, ['typeArray', 'locationArray']);
    vtkCellTypes(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1i = macro.newInstance(extend$1i, 'vtkCellTypes');

  // ----------------------------------------------------------------------------

  var vtkCellTypes$1 = {
    newInstance: newInstance$1i,
    extend: extend$1i,
    ...STATIC$6
  };

  const IntersectionState$1 = {
    NO_INTERSECTION: 0,
    YES_INTERSECTION: 1,
    ON_LINE: 2
  };
  var Constants$6 = {
    IntersectionState: IntersectionState$1
  };

  const {
    IntersectionState
  } = Constants$6;

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------
  function distanceToLine(x, p1, p2) {
    let closestPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    const outObj = {
      t: Number.MIN_VALUE,
      distance: 0
    };
    const p21 = [];
    let closest;
    // Determine appropriate vector
    p21[0] = p2[0] - p1[0];
    p21[1] = p2[1] - p1[1];
    p21[2] = p2[2] - p1[2];

    // Get parametric location
    const num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);
    const denom = dot(p21, p21);

    // trying to avoid an expensive fabs
    let tolerance = 1e-5 * num;
    if (denom !== 0.0) {
      outObj.t = num / denom;
    }
    if (tolerance < 0.0) {
      tolerance = -tolerance;
    }
    if (-tolerance < denom && denom < tolerance) {
      closest = p1;
    } else if (denom <= 0.0 || outObj.t < 0.0) {
      // If parametric coordinate is within 0<=p<=1, then the point is closest to
      // the line.  Otherwise, it's closest to a point at the end of the line.
      closest = p1;
    } else if (outObj.t > 1.0) {
      closest = p2;
    } else {
      closest = p21;
      p21[0] = p1[0] + outObj.t * p21[0];
      p21[1] = p1[1] + outObj.t * p21[1];
      p21[2] = p1[2] + outObj.t * p21[2];
    }
    if (closestPoint) {
      closestPoint[0] = closest[0];
      closestPoint[1] = closest[1];
      closestPoint[2] = closest[2];
    }
    outObj.distance = distance2BetweenPoints(closest, x);
    return outObj;
  }
  function intersection(a1, a2, b1, b2, u, v) {
    const a21 = [];
    const b21 = [];
    const b1a1 = [];
    u[0] = 0.0;
    v[0] = 0.0;

    // Determine line vectors.
    subtract(a2, a1, a21);
    subtract(b2, b1, b21);
    subtract(b1, a1, b1a1);

    // Compute the system (least squares) matrix.
    const A = [dot(a21, a21), -dot(a21, b21), -dot(a21, b21), dot(b21, b21)];

    // Compute the least squares system constant term.
    const c = [];
    c[0] = dot(a21, b1a1);
    c[1] = -dot(b21, b1a1);
    // Solve the system of equations
    if (solveLinearSystem(A, c, 2) === 0) {
      // The lines are colinear. Therefore, one of the four endpoints is the
      // point of closest approach
      let minDist = Number.MAX_VALUE;
      const p = [a1, a2, b1, b2];
      const l1 = [b1, b1, a1, a1];
      const l2 = [b2, b2, a2, a2];
      [v[0], v[0], u[0], u[0]];
      [u[0], u[0], v[0], v[0]];
      let obj;
      for (let i = 0; i < 4; i++) {
        obj = distanceToLine(p[i], l1[i], l2[i]);
        if (obj.distance < minDist) {
          minDist = obj.distance;
        }
      }
      return IntersectionState.ON_LINE;
    }
    u[0] = c[0];
    v[0] = c[1];

    // Check parametric coordinates for intersection.
    if (u[0] >= 0.0 && u[0] <= 1.0 && v[0] >= 0.0 && v[0] <= 1.0) {
      return IntersectionState.YES_INTERSECTION;
    }
    return IntersectionState.NO_INTERSECTION;
  }

  // ----------------------------------------------------------------------------
  // Static API
  // ----------------------------------------------------------------------------

  const STATIC$5 = {
    distanceToLine,
    intersection
  };

  // ----------------------------------------------------------------------------
  // vtkLine methods
  // ----------------------------------------------------------------------------

  function vtkLine(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkLine');
    function isBetweenPoints(t) {
      return t >= 0.0 && t <= 1.0;
    }
    publicAPI.getCellDimension = () => 1;
    publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
      const outObj = {
        intersect: 0,
        t: Number.MAX_VALUE,
        subId: 0,
        betweenPoints: null
      };
      pcoords[1] = 0.0;
      pcoords[2] = 0.0;
      const projXYZ = [];
      const a1 = [];
      const a2 = [];
      model.points.getPoint(0, a1);
      model.points.getPoint(1, a2);
      const u = [];
      const v = [];
      const intersect = intersection(p1, p2, a1, a2, u, v);
      outObj.t = u[0];
      outObj.betweenPoints = isBetweenPoints(outObj.t);
      pcoords[0] = v[0];
      if (intersect === IntersectionState.YES_INTERSECTION) {
        // make sure we are within tolerance
        for (let i = 0; i < 3; i++) {
          x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
          projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);
        }
        if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
      } else {
        let outDistance;
        // check to see if it lies within tolerance
        // one of the parametric coords must be outside 0-1
        if (outObj.t < 0.0) {
          outDistance = distanceToLine(p1, a1, a2, x);
          if (outDistance.distance <= tol * tol) {
            outObj.t = 0.0;
            outObj.intersect = 1;
            outObj.betweenPoints = true; // Intersection is near p1
            return outObj;
          }
          return outObj;
        }
        if (outObj.t > 1.0) {
          outDistance = distanceToLine(p2, a1, a2, x);
          if (outDistance.distance <= tol * tol) {
            outObj.t = 1.0;
            outObj.intersect = 1;
            outObj.betweenPoints = true; // Intersection is near p2
            return outObj;
          }
          return outObj;
        }
        if (pcoords[0] < 0.0) {
          pcoords[0] = 0.0;
          outDistance = distanceToLine(a1, p1, p2, x);
          outObj.t = outDistance.t;
          if (outDistance.distance <= tol * tol) {
            outObj.intersect = 1;
            return outObj;
          }
          return outObj;
        }
        if (pcoords[0] > 1.0) {
          pcoords[0] = 1.0;
          outDistance = distanceToLine(a2, p1, p2, x);
          outObj.t = outDistance.t;
          if (outDistance.distance <= tol * tol) {
            outObj.intersect = 1;
            return outObj;
          }
          return outObj;
        }
      }
      return outObj;
    };
    publicAPI.evaluateLocation = (pcoords, x, weights) => {
      const a1 = [];
      const a2 = [];
      model.points.getPoint(0, a1);
      model.points.getPoint(1, a2);
      for (let i = 0; i < 3; i++) {
        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
      }
      weights[0] = 1.0 - pcoords[0];
      weights[1] = pcoords[0];
    };
    publicAPI.evaluateOrientation = (pcoords, q, weights) => {
      if (model.orientations) {
        slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);
        weights[0] = 1.0 - pcoords[0];
        weights[1] = pcoords[0];
        return true;
      }
      return false;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1e = {
    orientations: null // an array of two quat or null
  };

  // ----------------------------------------------------------------------------

  function extend$1h(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1e, initialValues);
    vtkCell$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ['orientations']);
    vtkLine(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1h = macro.newInstance(extend$1h, 'vtkLine');

  // ----------------------------------------------------------------------------

  var vtkLine$1 = {
    newInstance: newInstance$1h,
    extend: extend$1h,
    ...STATIC$5,
    ...Constants$6
  };

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  // ----------------------------------------------------------------------------
  // vtkPointSet methods
  // ----------------------------------------------------------------------------

  function vtkPointSet(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkPointSet');

    // Create empty points
    if (!model.points) {
      model.points = vtkPoints$1.newInstance();
    } else {
      model.points = vtk(model.points);
    }
    publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
    publicAPI.getBounds = () => model.points.getBounds();
    publicAPI.computeBounds = () => {
      publicAPI.getBounds();
    };
    const superShallowCopy = publicAPI.shallowCopy;
    publicAPI.shallowCopy = function (other) {
      let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      superShallowCopy(other, debug);
      model.points = vtkPoints$1.newInstance();
      model.points.shallowCopy(other.getPoints());
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1d = {
    // points: null,
  };

  // ----------------------------------------------------------------------------

  function extend$1g(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1d, initialValues);

    // Inheritance
    vtkDataSet$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ['points']);

    // Object specific methods
    vtkPointSet(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1g = macro.newInstance(extend$1g, 'vtkPointSet');

  // ----------------------------------------------------------------------------

  var vtkPointSet$1 = {
    newInstance: newInstance$1g,
    extend: extend$1g
  };

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  function computeNormalDirection(v1, v2, v3, n) {
    // order is important!!! maintain consistency with triangle vertex order
    const ax = v3[0] - v2[0];
    const ay = v3[1] - v2[1];
    const az = v3[2] - v2[2];
    const bx = v1[0] - v2[0];
    const by = v1[1] - v2[1];
    const bz = v1[2] - v2[2];
    n[0] = ay * bz - az * by;
    n[1] = az * bx - ax * bz;
    n[2] = ax * by - ay * bx;
  }
  function computeNormal(v1, v2, v3, n) {
    computeNormalDirection(v1, v2, v3, n);
    const length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
    if (length !== 0.0) {
      n[0] /= length;
      n[1] /= length;
      n[2] /= length;
    }
  }
  function intersectWithTriangle(p1, q1, r1, p2, q2, r2) {
    let tolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1e-6;
    let coplanar = false;
    const pt1 = [];
    const pt2 = [];
    const surfaceId = [];
    const n1 = [];
    const n2 = [];

    // Compute supporting plane normals.
    computeNormal(p1, q1, r1, n1);
    computeNormal(p2, q2, r2, n2);
    const s1 = -dot(n1, p1);
    const s2 = -dot(n2, p2);

    // Compute signed distances of points p1, q1, r1 from supporting
    // plane of second triangle.
    const dist1 = [dot(n2, p1) + s2, dot(n2, q1) + s2, dot(n2, r1) + s2];

    // If signs of all points are the same, all the points lie on the
    // same side of the supporting plane, and we can exit early.
    if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {
      // vtkDebugMacro(<<"Same side supporting plane 1!");
      return {
        intersect: false,
        coplanar,
        pt1,
        pt2,
        surfaceId
      };
    }
    // Do the same for p2, q2, r2 and supporting plane of first
    // triangle.
    const dist2 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1];

    // If signs of all points are the same, all the points lie on the
    // same side of the supporting plane, and we can exit early.
    if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {
      // vtkDebugMacro(<<"Same side supporting plane 2!");
      return {
        intersect: false,
        coplanar,
        pt1,
        pt2,
        surfaceId
      };
    }
    // Check for coplanarity of the supporting planes.
    if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {
      coplanar = true;
      // vtkDebugMacro(<<"Coplanar!");
      return {
        intersect: false,
        coplanar,
        pt1,
        pt2,
        surfaceId
      };
    }

    // There are more efficient ways to find the intersection line (if
    // it exists), but this is clear enough.
    const pts1 = [p1, q1, r1];
    const pts2 = [p2, q2, r2];

    // Find line of intersection (L = p + t*v) between two planes.
    const n1n2 = dot(n1, n2);
    const a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1.0);
    const b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1.0);
    const p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];
    const v = cross(n1, n2, []);
    normalize(v);
    let index1 = 0;
    let index2 = 0;
    const t1 = [];
    const t2 = [];
    let ts1 = 50;
    let ts2 = 50;
    for (let i = 0; i < 3; i++) {
      const id1 = i;
      const id2 = (i + 1) % 3;

      // Find t coordinate on line of intersection between two planes.
      const val1 = vtkPlane$1.intersectWithLine(pts1[id1], pts1[id2], p2, n2);
      if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {
        if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {
          ts1 = index1;
        }
        t1[index1++] = dot(val1.x, v) - dot(p, v);
      }
      const val2 = vtkPlane$1.intersectWithLine(pts2[id1], pts2[id2], p1, n1);
      if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {
        if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {
          ts2 = index2;
        }
        t2[index2++] = dot(val2.x, v) - dot(p, v);
      }
    }

    // If the value of the index is greater than 2, the intersecting point
    // actually is intersected by all three edges. In this case, set the two
    // edges to the two edges where the intersecting point is not the end point
    if (index1 > 2) {
      index1--;
      // swap
      const t12 = t1[2];
      t1[2] = t1[ts1];
      t1[ts1] = t12;
    }
    if (index2 > 2) {
      index2--;
      const t22 = t2[2];
      t2[2] = t2[ts2];
      t2[ts2] = t22;
    }
    // Check if only one edge or all edges intersect the supporting
    // planes intersection.
    if (index1 !== 2 || index2 !== 2) {
      // vtkDebugMacro(<<"Only one edge intersecting!");
      return {
        intersect: false,
        coplanar,
        pt1,
        pt2,
        surfaceId
      };
    }

    // Check for NaNs
    if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {
      // vtkWarningMacro(<<"NaNs!");
      return {
        intersect: false,
        coplanar,
        pt1,
        pt2,
        surfaceId
      };
    }
    if (t1[0] > t1[1]) {
      // swap
      const t11 = t1[1];
      t1[1] = t1[0];
      t1[0] = t11;
    }
    if (t2[0] > t2[1]) {
      // swap
      const t21 = t2[1];
      t2[1] = t2[0];
      t2[0] = t21;
    }
    // Handle the different interval configuration cases.
    let tt1;
    let tt2;
    if (t1[1] < t2[0] || t2[1] < t1[0]) {
      // vtkDebugMacro(<<"No Overlap!");
      return {
        intersect: false,
        coplanar,
        pt1,
        pt2,
        surfaceId
      }; // No overlap
    }

    if (t1[0] < t2[0]) {
      if (t1[1] < t2[1]) {
        // First point on surface 2, second point on surface 1
        surfaceId[0] = 2;
        surfaceId[1] = 1;
        tt1 = t2[0];
        tt2 = t1[1];
      } else {
        // Both points belong to lines on surface 2
        surfaceId[0] = 2;
        surfaceId[1] = 2;
        tt1 = t2[0];
        tt2 = t2[1];
      }
    } // t1[0] >= t2[0]
    else if (t1[1] < t2[1]) {
      // Both points belong to lines on surface 1
      surfaceId[0] = 1;
      surfaceId[1] = 1;
      tt1 = t1[0];
      tt2 = t1[1];
    } else {
      // First point on surface 1, second point on surface 2
      surfaceId[0] = 1;
      surfaceId[1] = 2;
      tt1 = t1[0];
      tt2 = t2[1];
    }

    // Create actual intersection points.
    multiplyAccumulate(p, v, tt1, pt1);
    multiplyAccumulate(p, v, tt2, pt2);
    return {
      intersect: true,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }

  // ----------------------------------------------------------------------------
  // Static API
  // ----------------------------------------------------------------------------

  const STATIC$4 = {
    computeNormalDirection,
    computeNormal,
    intersectWithTriangle
  };

  // ----------------------------------------------------------------------------
  // vtkTriangle methods
  // ----------------------------------------------------------------------------

  function vtkTriangle(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkTriangle');
    publicAPI.getCellDimension = () => 2;
    publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
      const outObj = {
        subId: 0,
        t: Number.MAX_VALUE,
        intersect: 0,
        betweenPoints: false
      };
      pcoords[2] = 0.0;
      const closestPoint = [];
      const tol2 = tol * tol;

      // Get normal for triangle
      const pt1 = [];
      const pt2 = [];
      const pt3 = [];
      model.points.getPoint(0, pt1);
      model.points.getPoint(1, pt2);
      model.points.getPoint(2, pt3);
      const n = [];
      const weights = [];
      computeNormal(pt1, pt2, pt3, n);
      if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {
        // Intersect plane of triangle with line
        const plane = vtkPlane$1.intersectWithLine(p1, p2, pt1, n);
        outObj.betweenPoints = plane.betweenPoints;
        outObj.t = plane.t;
        x[0] = plane.x[0];
        x[1] = plane.x[1];
        x[2] = plane.x[2];
        if (!plane.intersection) {
          pcoords[0] = 0.0;
          pcoords[1] = 0.0;
          outObj.intersect = 0;
          return outObj;
        }

        // Evaluate position
        const inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);
        if (inside.evaluation >= 0) {
          if (inside.dist2 <= tol2) {
            outObj.intersect = 1;
            return outObj;
          }
          outObj.intersect = inside.evaluation;
          return outObj;
        }
      }

      // Normals are null, so the triangle is degenerated and
      // we still need to check intersection between line and
      // the longest edge.
      const dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);
      const dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);
      const dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);
      if (!model.line) {
        model.line = vtkLine$1.newInstance();
      }
      if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {
        model.line.getPoints().setPoint(0, pt1);
        model.line.getPoints().setPoint(1, pt2);
      } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {
        model.line.getPoints().setPoint(0, pt2);
        model.line.getPoints().setPoint(1, pt3);
      } else {
        model.line.getPoints().setPoint(0, pt3);
        model.line.getPoints().setPoint(1, pt1);
      }
      const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);
      outObj.betweenPoints = intersectLine.betweenPoints;
      outObj.t = intersectLine.t;
      if (intersectLine.intersect) {
        const pt3Pt1 = [];
        const pt3Pt2 = [];
        const pt3X = [];
        // Compute r and s manually, using dot and norm.
        for (let i = 0; i < 3; i++) {
          pt3Pt1[i] = pt1[i] - pt3[i];
          pt3Pt2[i] = pt2[i] - pt3[i];
          pt3X[i] = x[i] - pt3[i];
        }
        pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;
        pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;
        outObj.intersect = 1;
        return outObj;
      }
      pcoords[0] = 0.0;
      pcoords[1] = 0.0;
      outObj.intersect = 0;
      return outObj;
    };
    publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {
      // will return obj
      const outObj = {
        subId: 0,
        dist2: 0,
        evaluation: -1
      };
      let i;
      let j;
      const pt1 = [];
      const pt2 = [];
      const pt3 = [];
      const n = [];
      let fabsn;
      const rhs = [];
      const c1 = [];
      const c2 = [];
      let det = 0;
      let idx = 0;
      const indices = [];
      let dist2Point;
      let dist2Line1;
      let dist2Line2;
      let closest = [];
      const closestPoint1 = [];
      const closestPoint2 = [];
      const cp = [];
      outObj.subId = 0;
      pcoords[2] = 0.0;

      // Get normal for triangle, only the normal direction is needed, i.e. the
      // normal need not be normalized (unit length)
      //
      model.points.getPoint(1, pt1);
      model.points.getPoint(2, pt2);
      model.points.getPoint(0, pt3);
      computeNormalDirection(pt1, pt2, pt3, n);

      // Project point to plane
      vtkPlane$1.generalizedProjectPoint(x, pt1, n, cp);

      // Construct matrices.  Since we have over determined system, need to find
      // which 2 out of 3 equations to use to develop equations. (Any 2 should
      // work since we've projected point to plane.)
      let maxComponent = 0.0;
      for (i = 0; i < 3; i++) {
        // trying to avoid an expensive call to fabs()
        if (n[i] < 0) {
          fabsn = -n[i];
        } else {
          fabsn = n[i];
        }
        if (fabsn > maxComponent) {
          maxComponent = fabsn;
          idx = i;
        }
      }
      for (j = 0, i = 0; i < 3; i++) {
        if (i !== idx) {
          indices[j++] = i;
        }
      }
      for (i = 0; i < 2; i++) {
        rhs[i] = cp[indices[i]] - pt3[indices[i]];
        c1[i] = pt1[indices[i]] - pt3[indices[i]];
        c2[i] = pt2[indices[i]] - pt3[indices[i]];
      }
      det = determinant2x2(c1, c2);
      if (det === 0.0) {
        pcoords[0] = 0.0;
        pcoords[1] = 0.0;
        outObj.evaluation = -1;
        return outObj;
      }
      pcoords[0] = determinant2x2(rhs, c2) / det;
      pcoords[1] = determinant2x2(c1, rhs) / det;

      // Okay, now find closest point to element
      weights[0] = 1 - (pcoords[0] + pcoords[1]);
      weights[1] = pcoords[0];
      weights[2] = pcoords[1];
      if (weights[0] >= 0.0 && weights[0] <= 1.0 && weights[1] >= 0.0 && weights[1] <= 1.0 && weights[2] >= 0.0 && weights[2] <= 1.0) {
        // projection distance
        if (closestPoint) {
          outObj.dist2 = distance2BetweenPoints(cp, x);
          closestPoint[0] = cp[0];
          closestPoint[1] = cp[1];
          closestPoint[2] = cp[2];
        }
        outObj.evaluation = 1;
      } else {
        let t;
        if (closestPoint) {
          if (weights[1] < 0.0 && weights[2] < 0.0) {
            dist2Point = distance2BetweenPoints(x, pt3);
            dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
            dist2Line2 = vtkLine$1.distanceToLine(x, pt3, pt2, t, closestPoint2);
            if (dist2Point < dist2Line1) {
              outObj.dist2 = dist2Point;
              closest = pt3;
            } else {
              outObj.dist2 = dist2Line1;
              closest = closestPoint1;
            }
            if (dist2Line2 < outObj.dist2) {
              outObj.dist2 = dist2Line2;
              closest = closestPoint2;
            }
            for (i = 0; i < 3; i++) {
              closestPoint[i] = closest[i];
            }
          } else if (weights[2] < 0.0 && weights[0] < 0.0) {
            dist2Point = distance2BetweenPoints(x, pt1);
            dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
            dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
            if (dist2Point < dist2Line1) {
              outObj.dist2 = dist2Point;
              closest = pt1;
            } else {
              outObj.dist2 = dist2Line1;
              closest = closestPoint1;
            }
            if (dist2Line2 < outObj.dist2) {
              outObj.dist2 = dist2Line2;
              closest = closestPoint2;
            }
            for (i = 0; i < 3; i++) {
              closestPoint[i] = closest[i];
            }
          } else if (weights[1] < 0.0 && weights[0] < 0.0) {
            dist2Point = distance2BetweenPoints(x, pt2);
            dist2Line1 = vtkLine$1.distanceToLine(x, pt2, pt3, t, closestPoint1);
            dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
            if (dist2Point < dist2Line1) {
              outObj.dist2 = dist2Point;
              closest = pt2;
            } else {
              outObj.dist2 = dist2Line1;
              closest = closestPoint1;
            }
            if (dist2Line2 < outObj.dist2) {
              outObj.dist2 = dist2Line2;
              closest = closestPoint2;
            }
            for (i = 0; i < 3; i++) {
              closestPoint[i] = closest[i];
            }
          } else if (weights[0] < 0.0) {
            const lineDistance = vtkLine$1.distanceToLine(x, pt1, pt2, closestPoint);
            outObj.dist2 = lineDistance.distance;
          } else if (weights[1] < 0.0) {
            const lineDistance = vtkLine$1.distanceToLine(x, pt2, pt3, closestPoint);
            outObj.dist2 = lineDistance.distance;
          } else if (weights[2] < 0.0) {
            const lineDistance = vtkLine$1.distanceToLine(x, pt1, pt3, closestPoint);
            outObj.dist2 = lineDistance.distance;
          }
        }
        outObj.evaluation = 0;
      }
      return outObj;
    };
    publicAPI.evaluateLocation = (pcoords, x, weights) => {
      const p0 = [];
      const p1 = [];
      const p2 = [];
      model.points.getPoint(0, p0);
      model.points.getPoint(1, p1);
      model.points.getPoint(2, p2);
      const u3 = 1.0 - pcoords[0] - pcoords[1];
      for (let i = 0; i < 3; i++) {
        x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];
      }
      weights[0] = u3;
      weights[1] = pcoords[0];
      weights[2] = pcoords[1];
    };
    publicAPI.getParametricDistance = pcoords => {
      let pDist;
      let pDistMax = 0.0;
      const pc = [];
      pc[0] = pcoords[0];
      pc[1] = pcoords[1];
      pc[2] = 1.0 - pcoords[0] - pcoords[1];
      for (let i = 0; i < 3; i++) {
        if (pc[i] < 0.0) {
          pDist = -pc[i];
        } else if (pc[i] > 1.0) {
          pDist = pc[i] - 1.0;
        } else {
          // inside the cell in the parametric direction
          pDist = 0.0;
        }
        if (pDist > pDistMax) {
          pDistMax = pDist;
        }
      }
      return pDistMax;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1c = {};

  // ----------------------------------------------------------------------------

  function extend$1f(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1c, initialValues);
    vtkCell$1.extend(publicAPI, model, initialValues);
    vtkTriangle(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1f = macro.newInstance(extend$1f, 'vtkTriangle');

  // ----------------------------------------------------------------------------

  var vtkTriangle$1 = {
    newInstance: newInstance$1f,
    extend: extend$1f,
    ...STATIC$4
  };

  const POLYDATA_FIELDS = ['verts', 'lines', 'polys', 'strips'];

  const {
    vtkWarningMacro: vtkWarningMacro$3
  } = macro;
  const CELL_FACTORY = {
    [CellType.VTK_LINE]: vtkLine$1,
    [CellType.VTK_POLY_LINE]: vtkLine$1,
    [CellType.VTK_TRIANGLE]: vtkTriangle$1
  };

  // ----------------------------------------------------------------------------
  // vtkPolyData methods
  // ----------------------------------------------------------------------------

  function vtkPolyData(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkPolyData');
    function camelize(str) {
      return str.replace(/(?:^\w|[A-Z]|\b\w)/g, letter => letter.toUpperCase()).replace(/\s+/g, '');
    }

    // build empty cell arrays and set methods
    POLYDATA_FIELDS.forEach(type => {
      publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();
      if (!model[type]) {
        model[type] = vtkCellArray$1.newInstance();
      } else {
        model[type] = vtk(model[type]);
      }
    });
    publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);
    const superShallowCopy = publicAPI.shallowCopy;
    publicAPI.shallowCopy = function (other) {
      let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      superShallowCopy(other, debug);
      POLYDATA_FIELDS.forEach(type => {
        model[type] = vtkCellArray$1.newInstance();
        model[type].shallowCopy(other.getReferenceByName(type));
      });
    };
    publicAPI.buildCells = () => {
      // here are the number of cells we have
      const nVerts = publicAPI.getNumberOfVerts();
      const nLines = publicAPI.getNumberOfLines();
      const nPolys = publicAPI.getNumberOfPolys();
      const nStrips = publicAPI.getNumberOfStrips();

      // pre-allocate the space we need
      const nCells = nVerts + nLines + nPolys + nStrips;
      const types = new Uint8Array(nCells);
      let pTypes = types;
      const locs = new Uint32Array(nCells);
      let pLocs = locs;

      // record locations and type of each cell.
      // verts
      if (nVerts) {
        let nextCellPts = 0;
        model.verts.getCellSizes().forEach((numCellPts, index) => {
          pLocs[index] = nextCellPts;
          pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;
          nextCellPts += numCellPts + 1;
        });
        pLocs = pLocs.subarray(nVerts);
        pTypes = pTypes.subarray(nVerts);
      }

      // lines
      if (nLines) {
        let nextCellPts = 0;
        model.lines.getCellSizes().forEach((numCellPts, index) => {
          pLocs[index] = nextCellPts;
          pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;
          if (numCellPts === 1) {
            vtkWarningMacro$3('Building VTK_LINE ', index, ' with only one point, but VTK_LINE needs at least two points. Check the input.');
          }
          nextCellPts += numCellPts + 1;
        });
        pLocs = pLocs.subarray(nLines);
        pTypes = pTypes.subarray(nLines);
      }

      // polys
      if (nPolys) {
        let nextCellPts = 0;
        model.polys.getCellSizes().forEach((numCellPts, index) => {
          pLocs[index] = nextCellPts;
          switch (numCellPts) {
            case 3:
              pTypes[index] = CellType.VTK_TRIANGLE;
              break;
            case 4:
              pTypes[index] = CellType.VTK_QUAD;
              break;
            default:
              pTypes[index] = CellType.VTK_POLYGON;
              break;
          }
          if (numCellPts < 3) {
            vtkWarningMacro$3('Building VTK_TRIANGLE ', index, ' with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.');
          }
          nextCellPts += numCellPts + 1;
        });
        pLocs += pLocs.subarray(nPolys);
        pTypes += pTypes.subarray(nPolys);
      }

      // strips
      if (nStrips) {
        let nextCellPts = 0;
        pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);
        model.strips.getCellSizes().forEach((numCellPts, index) => {
          pLocs[index] = nextCellPts;
          nextCellPts += numCellPts + 1;
        });
      }

      // set up the cell types data structure
      model.cells = vtkCellTypes$1.newInstance();
      model.cells.setCellTypes(nCells, types, locs);
    };

    /**
     * Create upward links from points to cells that use each point. Enables
     * topologically complex queries.
     */
    publicAPI.buildLinks = function () {
      let initialSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      if (model.cells === undefined) {
        publicAPI.buildCells();
      }
      model.links = vtkCellLinks$1.newInstance();
      if (initialSize > 0) {
        model.links.allocate(initialSize);
      } else {
        model.links.allocate(publicAPI.getPoints().getNumberOfPoints());
      }
      model.links.buildLinks(publicAPI);
    };
    publicAPI.getCellType = cellId => model.cells.getCellType(cellId);
    publicAPI.getCellPoints = cellId => {
      const cellType = publicAPI.getCellType(cellId);
      let cells = null;
      switch (cellType) {
        case CellType.VTK_VERTEX:
        case CellType.VTK_POLY_VERTEX:
          cells = model.verts;
          break;
        case CellType.VTK_LINE:
        case CellType.VTK_POLY_LINE:
          cells = model.lines;
          break;
        case CellType.VTK_TRIANGLE:
        case CellType.VTK_QUAD:
        case CellType.VTK_POLYGON:
          cells = model.polys;
          break;
        case CellType.VTK_TRIANGLE_STRIP:
          cells = model.strips;
          break;
        default:
          cells = null;
          return {
            type: 0,
            cellPointIds: null
          };
      }
      const loc = model.cells.getCellLocation(cellId);
      const cellPointIds = cells.getCell(loc);
      return {
        cellType,
        cellPointIds
      };
    };
    publicAPI.getPointCells = ptId => model.links.getCells(ptId);
    publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {
      const link1 = model.links.getLink(point1);
      const link2 = model.links.getLink(point2);
      return link1.cells.filter(cell => cell !== cellId && link2.cells.indexOf(cell) !== -1);
    };

    /**
     * If you know the type of cell, you may provide it to improve performances.
     */
    publicAPI.getCell = function (cellId) {
      let cellHint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      const cellInfo = publicAPI.getCellPoints(cellId);
      const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();
      cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);
      return cell;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1b = {
    // verts: null,
    // lines: null,
    // polys: null,
    // strips: null,
    // cells: null,
    // links: null,
  };

  // ----------------------------------------------------------------------------

  function extend$1e(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1b, initialValues);

    // Inheritance
    vtkPointSet$1.extend(publicAPI, model, initialValues);
    macro.get(publicAPI, model, ['cells', 'links']);
    macro.setGet(publicAPI, model, ['verts', 'lines', 'polys', 'strips']);

    // Object specific methods
    vtkPolyData(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1e = macro.newInstance(extend$1e, 'vtkPolyData');

  // ----------------------------------------------------------------------------

  var vtkPolyData$1 = {
    newInstance: newInstance$1e,
    extend: extend$1e
  };

  // ----------------------------------------------------------------------------
  // vtkTexture methods
  // ----------------------------------------------------------------------------

  function vtkTexture(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkTexture');
    publicAPI.imageLoaded = () => {
      model.image.removeEventListener('load', publicAPI.imageLoaded);
      model.imageLoaded = true;
      publicAPI.modified();
    };
    publicAPI.setJsImageData = imageData => {
      if (model.jsImageData === imageData) {
        return;
      }

      // clear other entries
      if (imageData !== null) {
        publicAPI.setInputData(null);
        publicAPI.setInputConnection(null);
        model.image = null;
        model.canvas = null;
      }
      model.jsImageData = imageData;
      model.imageLoaded = true;
      publicAPI.modified();
    };
    publicAPI.setCanvas = canvas => {
      if (model.canvas === canvas) {
        return;
      }

      // clear other entries
      if (canvas !== null) {
        publicAPI.setInputData(null);
        publicAPI.setInputConnection(null);
        model.image = null;
        model.jsImageData = null;
      }
      model.canvas = canvas;
      publicAPI.modified();
    };
    publicAPI.setImage = image => {
      if (model.image === image) {
        return;
      }

      // clear other entries
      if (image !== null) {
        publicAPI.setInputData(null);
        publicAPI.setInputConnection(null);
        model.canvas = null;
        model.jsImageData = null;
      }
      model.image = image;
      model.imageLoaded = false;
      if (image.complete) {
        publicAPI.imageLoaded();
      } else {
        image.addEventListener('load', publicAPI.imageLoaded);
      }
      publicAPI.modified();
    };
    publicAPI.getDimensionality = () => {
      let width = 0;
      let height = 0;
      let depth = 1;
      if (publicAPI.getInputData()) {
        const data = publicAPI.getInputData();
        width = data.getDimensions()[0];
        height = data.getDimensions()[1];
        depth = data.getDimensions()[2];
      }
      if (model.jsImageData) {
        width = model.jsImageData.width;
        height = model.jsImageData.height;
      }
      if (model.canvas) {
        width = model.canvas.width;
        height = model.canvas.height;
      }
      if (model.image) {
        width = model.image.width;
        height = model.image.height;
      }
      const dimensionality = (width > 1) + (height > 1) + (depth > 1);
      return dimensionality;
    };
    publicAPI.getInputAsJsImageData = () => {
      if (!model.imageLoaded || publicAPI.getInputData()) return null;
      if (model.jsImageData) {
        return model.jsImageData();
      }
      if (model.canvas) {
        const context = model.canvas.getContext('2d');
        const imageData = context.getImageData(0, 0, model.canvas.width, model.canvas.height);
        return imageData;
      }
      if (model.image) {
        const canvas = document.createElement('canvas');
        canvas.width = model.image.width;
        canvas.height = model.image.height;
        const context = canvas.getContext('2d');
        context.translate(0, canvas.height);
        context.scale(1, -1);
        context.drawImage(model.image, 0, 0, model.image.width, model.image.height);
        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        return imageData;
      }
      return null;
    };
  }

  // Use nativeArray instead of self
  const generateMipmaps = (nativeArray, width, height, level) => {
    // TODO: FIX UNEVEN TEXTURE MIP GENERATION:
    // When textures don't have standard ratios, higher mip levels
    // result in their color chanels getting messed up and shifting
    // 3x3 gaussian kernel
    const g3m = [1, 2, 1]; // eslint-disable-line
    const g3w = 4; // eslint-disable-line

    const kernel = g3m;
    const kernelWeight = g3w;
    const hs = nativeArray.length / (width * height); // TODO: support for textures with depth more than 1
    let currentWidth = width;
    let currentHeight = height;
    let imageData = nativeArray;
    const maps = [imageData];
    for (let i = 0; i < level; i++) {
      const oldData = [...imageData];
      currentWidth /= 2;
      currentHeight /= 2;
      imageData = new Uint8ClampedArray(currentWidth * currentHeight * hs);
      const vs = hs * currentWidth;

      // Scale down
      let shift = 0;
      for (let p = 0; p < imageData.length; p += hs) {
        if (p % vs === 0) {
          shift += 2 * hs * currentWidth;
        }
        for (let c = 0; c < hs; c++) {
          let sample = oldData[shift + c];
          sample += oldData[shift + hs + c];
          sample += oldData[shift - 2 * vs + c];
          sample += oldData[shift - 2 * vs + hs + c];
          sample /= 4;
          imageData[p + c] = sample;
        }
        shift += 2 * hs;
      }

      // Horizontal Pass
      let dataCopy = [...imageData];
      for (let p = 0; p < imageData.length; p += hs) {
        for (let c = 0; c < hs; c++) {
          let x = -(kernel.length - 1) / 2;
          let kw = kernelWeight;
          let value = 0.0;
          for (let k = 0; k < kernel.length; k++) {
            let index = p + c + x * hs;
            const lineShift = index % vs - (p + c) % vs;
            if (lineShift > hs) index += vs;
            if (lineShift < -hs) index -= vs;
            if (dataCopy[index]) {
              value += dataCopy[index] * kernel[k];
            } else {
              kw -= kernel[k];
            }
            x += 1;
          }
          imageData[p + c] = value / kw;
        }
      }
      // Vertical Pass
      dataCopy = [...imageData];
      for (let p = 0; p < imageData.length; p += hs) {
        for (let c = 0; c < hs; c++) {
          let x = -(kernel.length - 1) / 2;
          let kw = kernelWeight;
          let value = 0.0;
          for (let k = 0; k < kernel.length; k++) {
            const index = p + c + x * vs;
            if (dataCopy[index]) {
              value += dataCopy[index] * kernel[k];
            } else {
              kw -= kernel[k];
            }
            x += 1;
          }
          imageData[p + c] = value / kw;
        }
      }
      maps.push(imageData);
    }
    return maps;
  };

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1a = {
    image: null,
    canvas: null,
    jsImageData: null,
    imageLoaded: false,
    repeat: false,
    interpolate: false,
    edgeClamp: false,
    mipLevel: 0,
    resizable: false // must be set at construction time if the texture can be resizable
  };

  // ----------------------------------------------------------------------------

  function extend$1d(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1a, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.algo(publicAPI, model, 6, 0);
    macro.get(publicAPI, model, ['canvas', 'image', 'jsImageData', 'imageLoaded', 'resizable']);
    macro.setGet(publicAPI, model, ['repeat', 'edgeClamp', 'interpolate', 'mipLevel']);
    vtkTexture(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1d = macro.newInstance(extend$1d, 'vtkTexture');
  const STATIC$3 = {
    generateMipmaps
  };

  // ----------------------------------------------------------------------------

  var vtkTexture$1 = {
    newInstance: newInstance$1d,
    extend: extend$1d,
    ...STATIC$3
  };

  // ----------------------------------------------------------------------------
  // vtkCubeAxesActor
  // ----------------------------------------------------------------------------
  // faces are -x x -y y -z z
  // point 0 is 0,0,0 and then +x fastest changing, +y then +z
  const faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];
  const faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];
  const edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];
  const edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];
  const faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]];

  //
  // Developer note: This class is broken into the main class and a helper
  // class. The main class holds view independent properties (those properties
  // that do not change as the view's resolution/aspect ratio change). The
  // helper class is instantiated one per view and holds properties that can
  // depend on view specific values such as resolution. The helper class code
  // could have been left to the View specific implementation (such as
  // vtkWebGPUCubeAxesActor) but is instead placed here to it can be shared by
  // multiple rendering backends.
  //

  // some shared temp variables to reduce heap allocs
  const ptv3 = new Float64Array(3);
  const pt2v3 = new Float64Array(3);
  const tmpv3 = new Float64Array(3);
  const tmp2v3 = new Float64Array(3);
  const xDir = new Float64Array(3);
  const yDir = new Float64Array(3);
  const invmat = new Float64Array(16);
  function applyTextStyle$1(ctx, style) {
    ctx.strokeStyle = style.strokeColor;
    ctx.lineWidth = style.strokeSize;
    ctx.fillStyle = style.fontColor;
    ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;
  }

  // many properties of this actor depend on the API specific view The main
  // dependency being the resolution as that drives what font sizes to use.
  // Bacause of this we need to do some of the calculations in a API specific
  // subclass. But... we don't want a lot of duplicated code between WebGL and
  // WebGPU for example so we have this helper class, that is designed to be
  // fairly API independent so that API specific views can call this to do
  // most of the work.
  function vtkCubeAxesActorHelper(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkCubeAxesActorHelper');
    publicAPI.setRenderable = renderable => {
      if (model.renderable === renderable) {
        return;
      }
      model.renderable = renderable;
      model.tmActor.addTexture(model.renderable.getTmTexture());
      model.tmActor.setProperty(renderable.getProperty());
      model.tmActor.setParentProp(renderable);
      publicAPI.modified();
    };

    // called by updateTexturePolyData
    publicAPI.createPolyDataForOneLabel = (text, pos, cmat, imat, dir, offset, results) => {
      const value = model.renderable.get_tmAtlas().get(text);
      if (!value) {
        return;
      }
      const coords = model.renderable.getTextPolyData().getPoints().getData();

      // compute pixel to distance factors
      const size = model.lastSize;
      ptv3[0] = coords[pos * 3];
      ptv3[1] = coords[pos * 3 + 1];
      ptv3[2] = coords[pos * 3 + 2];
      transformMat4$1(tmpv3, ptv3, cmat);
      // moving 0.1 in NDC
      tmpv3[0] += 0.1;
      transformMat4$1(pt2v3, tmpv3, imat);
      // results in WC move of
      subtract$1(xDir, pt2v3, ptv3);
      tmpv3[0] -= 0.1;
      tmpv3[1] += 0.1;
      transformMat4$1(pt2v3, tmpv3, imat);
      // results in WC move of
      subtract$1(yDir, pt2v3, ptv3);
      for (let i = 0; i < 3; i++) {
        xDir[i] /= 0.5 * 0.1 * size[0];
        yDir[i] /= 0.5 * 0.1 * size[1];
      }

      // have to find the four corners of the texture polygon for this label
      // convert anchor point to View Coords
      let ptIdx = results.ptIdx;
      let cellIdx = results.cellIdx;
      ptv3[0] = coords[pos * 3];
      ptv3[1] = coords[pos * 3 + 1];
      ptv3[2] = coords[pos * 3 + 2];
      // horizontal left, right, or middle alignment based on dir[0]
      if (dir[0] < -0.5) {
        scale$1(tmpv3, xDir, dir[0] * offset - value.width);
      } else if (dir[0] > 0.5) {
        scale$1(tmpv3, xDir, dir[0] * offset);
      } else {
        scale$1(tmpv3, xDir, dir[0] * offset - value.width / 2.0);
      }
      add$1(ptv3, ptv3, tmpv3);
      scale$1(tmpv3, yDir, dir[1] * offset - value.height / 2.0);
      add$1(ptv3, ptv3, tmpv3);
      results.points[ptIdx * 3] = ptv3[0];
      results.points[ptIdx * 3 + 1] = ptv3[1];
      results.points[ptIdx * 3 + 2] = ptv3[2];
      results.tcoords[ptIdx * 2] = value.tcoords[0];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];
      ptIdx++;
      scale$1(tmpv3, xDir, value.width);
      add$1(ptv3, ptv3, tmpv3);
      results.points[ptIdx * 3] = ptv3[0];
      results.points[ptIdx * 3 + 1] = ptv3[1];
      results.points[ptIdx * 3 + 2] = ptv3[2];
      results.tcoords[ptIdx * 2] = value.tcoords[2];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];
      ptIdx++;
      scale$1(tmpv3, yDir, value.height);
      add$1(ptv3, ptv3, tmpv3);
      results.points[ptIdx * 3] = ptv3[0];
      results.points[ptIdx * 3 + 1] = ptv3[1];
      results.points[ptIdx * 3 + 2] = ptv3[2];
      results.tcoords[ptIdx * 2] = value.tcoords[4];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];
      ptIdx++;
      scale$1(tmpv3, xDir, value.width);
      subtract$1(ptv3, ptv3, tmpv3);
      results.points[ptIdx * 3] = ptv3[0];
      results.points[ptIdx * 3 + 1] = ptv3[1];
      results.points[ptIdx * 3 + 2] = ptv3[2];
      results.tcoords[ptIdx * 2] = value.tcoords[6];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];
      ptIdx++;

      // add the two triangles to represent the quad
      results.polys[cellIdx * 4] = 3;
      results.polys[cellIdx * 4 + 1] = ptIdx - 4;
      results.polys[cellIdx * 4 + 2] = ptIdx - 3;
      results.polys[cellIdx * 4 + 3] = ptIdx - 2;
      cellIdx++;
      results.polys[cellIdx * 4] = 3;
      results.polys[cellIdx * 4 + 1] = ptIdx - 4;
      results.polys[cellIdx * 4 + 2] = ptIdx - 2;
      results.polys[cellIdx * 4 + 3] = ptIdx - 1;
      results.ptIdx += 4;
      results.cellIdx += 2;
    };

    // update the polydata associated with drawing the text labels
    // specifically the quads used for each label and their associated tcoords
    // etc. This changes every time the camera viewpoint changes
    publicAPI.updateTexturePolyData = () => {
      const cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);
      transpose(cmat, cmat);

      // update the polydata
      const numLabels = model.renderable.getTextValues().length;
      const numPts = numLabels * 4;
      const numTris = numLabels * 2;
      const points = new Float64Array(numPts * 3);
      const polys = new Uint16Array(numTris * 4);
      const tcoords = new Float32Array(numPts * 2);
      invert(invmat, cmat);
      const results = {
        ptIdx: 0,
        cellIdx: 0,
        polys,
        points,
        tcoords
      };
      let ptIdx = 0;
      let textIdx = 0;
      let axisIdx = 0;
      const coords = model.renderable.getTextPolyData().getPoints().getData();
      const textValues = model.renderable.getTextValues();
      while (ptIdx < coords.length / 3) {
        // compute the direction to move out
        ptv3[0] = coords[ptIdx * 3];
        ptv3[1] = coords[ptIdx * 3 + 1];
        ptv3[2] = coords[ptIdx * 3 + 2];
        transformMat4$1(tmpv3, ptv3, cmat);
        ptv3[0] = coords[ptIdx * 3 + 3];
        ptv3[1] = coords[ptIdx * 3 + 4];
        ptv3[2] = coords[ptIdx * 3 + 5];
        transformMat4$1(tmp2v3, ptv3, cmat);
        subtract$1(tmpv3, tmpv3, tmp2v3);
        const dir = [tmpv3[0], tmpv3[1]];
        normalize2D(dir);

        // write the axis label
        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);
        ptIdx += 2;
        textIdx++;

        // write the tick labels
        for (let t = 0; t < model.renderable.getTickCounts()[axisIdx]; t++) {
          publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);
          ptIdx++;
          textIdx++;
        }
        axisIdx++;
      }
      const tcoordDA = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcoords,
        name: 'TextureCoordinates'
      });
      model.tmPolyData.getPointData().setTCoords(tcoordDA);
      model.tmPolyData.getPoints().setData(points, 3);
      model.tmPolyData.getPoints().modified();
      model.tmPolyData.getPolys().setData(polys, 1);
      model.tmPolyData.getPolys().modified();
      model.tmPolyData.modified();
    };
    publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {
      // has the size changed?
      if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {
        model.lastSize[0] = size[0];
        model.lastSize[1] = size[1];
        model.lastAspectRatio = size[0] / size[1];
        model.forceUpdate = true;
      }
      model.camera = camera;

      // compute bounds for label quads whenever the camera changes
      publicAPI.updateTexturePolyData();
    };
  }
  const newCubeAxesActorHelper = macro.newInstance(function (publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      renderable: null
    };
    Object.assign(model, {}, initialValues);

    // Inheritance
    macro.obj(publicAPI, model);
    model.tmPolyData = vtkPolyData$1.newInstance();
    model.tmMapper = vtkMapper$1.newInstance();
    model.tmMapper.setInputData(model.tmPolyData);
    model.tmActor = vtkActor$1.newInstance({
      parentProp: publicAPI
    });
    model.tmActor.setMapper(model.tmMapper);
    macro.setGet(publicAPI, model, ['renderable']);
    macro.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'axisTextStyle', 'tickTextStyle', 'tmActor', 'ticks']);
    model.forceUpdate = false;
    model.lastRedrawTime = {};
    macro.obj(model.lastRedrawTime, {
      mtime: 0
    });
    model.lastRebuildTime = {};
    macro.obj(model.lastRebuildTime, {
      mtime: 0
    });
    model.lastSize = [-1, -1];

    // internal variables
    model.lastTickBounds = [];
    vtkCubeAxesActorHelper(publicAPI, model);
  }, 'vtkCubeAxesActorHelper');
  function vtkCubeAxesActor(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkCubeAxesActor');
    publicAPI.setCamera = cam => {
      if (model.camera === cam) {
        return;
      }
      if (model.cameraModifiedSub) {
        model.cameraModifiedSub.unsubscribe();
        model.cameraModifiedSub = null;
      }
      model.camera = cam;
      if (cam) {
        model.cameraModifiedSub = cam.onModified(publicAPI.update);
      }
      publicAPI.update();
      publicAPI.modified();
    };

    // estimate from a camera model what faces to draw
    // return true if the list of faces to draw has changed
    publicAPI.computeFacesToDraw = () => {
      const cmat = model.camera.getViewMatrix();
      transpose(cmat, cmat);
      let changed = false;
      const length = vtkBoundingBox.getDiagonalLength(model.dataBounds);
      const faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180.0);
      for (let f = 0; f < 6; f++) {
        let drawit = false;
        const faceAxis = Math.floor(f / 2);
        const otherAxis1 = (faceAxis + 1) % 3;
        const otherAxis2 = (faceAxis + 2) % 3;
        // only for non degenerate axes
        if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {
          // for each face transform the center and off center to get a direction vector
          ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length * faceNormals[f][faceAxis];
          ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);
          ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);
          transformMat4$1(tmpv3, ptv3, cmat);
          ptv3[faceAxis] = model.dataBounds[f];
          transformMat4$1(tmp2v3, ptv3, cmat);
          subtract$1(tmpv3, tmp2v3, tmpv3);
          normalize$4(tmpv3, tmpv3);
          // tmpv3 now holds the face normal vector
          drawit = tmpv3[2] > faceDot;
          // for perspctive we need the view direction to the plane
          if (!model.camera.getParallelProjection()) {
            normalize$4(tmp2v3, tmp2v3);
            drawit = dot$1(tmp2v3, tmpv3) > faceDot;
          }
        }
        if (drawit !== model.lastFacesToDraw[f]) {
          model.lastFacesToDraw[f] = drawit;
          changed = true;
        }
      }
      return changed;
    };

    // update the polydata that represents the boundingd edges and gridlines
    publicAPI.updatePolyData = (facesToDraw, edgesToDraw, ticks) => {
      // compute the number of points and lines required
      let numPts = 0;
      let numLines = 0;
      numPts += 8; // always start with the 8 cube points

      // count edgesToDraw
      let numEdgesToDraw = 0;
      for (let e = 0; e < 12; e++) {
        if (edgesToDraw[e] > 0) {
          numEdgesToDraw++;
        }
      }
      numLines += numEdgesToDraw;

      // add values for gridlines
      if (model.gridLines) {
        for (let f = 0; f < 6; f++) {
          if (facesToDraw[f]) {
            numPts += ticks[faceAxes[f][0]].length * 2 + ticks[faceAxes[f][1]].length * 2;
            numLines += ticks[faceAxes[f][0]].length + ticks[faceAxes[f][1]].length;
          }
        }
      }

      // now allocate the memory
      const points = new Float64Array(numPts * 3);
      const lines = new Uint32Array(numLines * 3);
      let ptIdx = 0;
      let lineIdx = 0;

      // add the 8 corner points
      for (let z = 0; z < 2; z++) {
        for (let y = 0; y < 2; y++) {
          for (let x = 0; x < 2; x++) {
            points[ptIdx * 3] = model.dataBounds[x];
            points[ptIdx * 3 + 1] = model.dataBounds[2 + y];
            points[ptIdx * 3 + 2] = model.dataBounds[4 + z];
            ptIdx++;
          }
        }
      }

      // draw the edges
      for (let e = 0; e < 12; e++) {
        if (edgesToDraw[e] > 0) {
          lines[lineIdx * 3] = 2;
          lines[lineIdx * 3 + 1] = edgePoints[e][0];
          lines[lineIdx * 3 + 2] = edgePoints[e][1];
          lineIdx++;
        }
      }

      // now handle gridlines
      // grid lines are tick[axis1] + ticks[axes2] lines each having two points
      // for simplicity we don;t worry about duplicating points, this is tiny

      if (model.gridLines) {
        // for each visible face
        // add the points
        for (let f = 0; f < 6; f++) {
          if (facesToDraw[f]) {
            const faceIdx = Math.floor(f / 2);
            let aticks = ticks[faceAxes[f][0]];
            for (let t = 0; t < aticks.length; t++) {
              points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
              points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
              points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2];
              ptIdx++;
              points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
              points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
              points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2 + 1];
              ptIdx++;
              lines[lineIdx * 3] = 2;
              lines[lineIdx * 3 + 1] = ptIdx - 2;
              lines[lineIdx * 3 + 2] = ptIdx - 1;
              lineIdx++;
            }
            aticks = ticks[faceAxes[f][1]];
            for (let t = 0; t < aticks.length; t++) {
              points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
              points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
              points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2];
              ptIdx++;
              points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
              points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
              points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2 + 1];
              ptIdx++;
              lines[lineIdx * 3] = 2;
              lines[lineIdx * 3 + 1] = ptIdx - 2;
              lines[lineIdx * 3 + 2] = ptIdx - 1;
              lineIdx++;
            }
          }
        }
      }
      model.polyData.getPoints().setData(points, 3);
      model.polyData.getPoints().modified();
      model.polyData.getLines().setData(lines, 1);
      model.polyData.getLines().modified();
      model.polyData.modified();
    };

    // update the data that represents where to put the labels
    // in world coordinates. This only changes when faces to draw changes
    // of dataBounds changes
    publicAPI.updateTextData = (facesToDraw, edgesToDraw, ticks, tickStrings) => {
      // count outside edgesToDraw
      let textPointCount = 0;
      for (let e = 0; e < 12; e++) {
        if (edgesToDraw[e] === 1) {
          textPointCount += 2;
          textPointCount += ticks[edgeAxes[e]].length;
        }
      }
      const points = model.polyData.getPoints().getData();
      const textPoints = new Float64Array(textPointCount * 3);
      let ptIdx = 0;
      let textIdx = 0;
      let axisCount = 0;
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          for (let e = 0; e < 4; e++) {
            const edgeIdx = faceEdges[f][e];
            if (edgesToDraw[edgeIdx] === 1) {
              const edgeAxis = edgeAxes[edgeIdx];
              // add a middle point on the edge
              const ptIdx1 = edgePoints[edgeIdx][0] * 3;
              const ptIdx2 = edgePoints[edgeIdx][1] * 3;
              textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);
              textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);
              textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);
              ptIdx++;
              // add a middle face point, we use this to
              // move the labels away from the edge in the right direction
              const faceIdx = Math.floor(f / 2);
              textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];
              textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);
              textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);
              ptIdx++;
              // set the text
              model.textValues[textIdx] = model.axisLabels[edgeAxis];
              textIdx++;

              // now add the tick marks along the edgeAxis
              const otherAxis1 = (edgeAxis + 1) % 3;
              const otherAxis2 = (edgeAxis + 2) % 3;
              const aticks = ticks[edgeAxis];
              const atickStrings = tickStrings[edgeAxis];
              model.tickCounts[axisCount] = aticks.length;
              for (let t = 0; t < aticks.length; t++) {
                textPoints[ptIdx * 3 + edgeAxis] = aticks[t];
                textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];
                textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];
                ptIdx++;
                // set the text
                model.textValues[textIdx] = atickStrings[t];
                textIdx++;
              }
              axisCount++;
            }
          }
        }
      }
      model.textPolyData.getPoints().setData(textPoints, 3);
      model.textPolyData.modified();
    };

    // main method to rebuild the cube axes, gets called on camera modify
    // and changes to key members
    publicAPI.update = () => {
      // Can't do anything if we don't have a camera...
      if (!model.camera) {
        return;
      }

      // compute what faces to draw
      const facesChanged = publicAPI.computeFacesToDraw();
      const facesToDraw = model.lastFacesToDraw;

      // have the bounds changed?
      let boundsChanged = false;
      for (let i = 0; i < 6; i++) {
        if (model.dataBounds[i] !== model.lastTickBounds[i]) {
          boundsChanged = true;
          model.lastTickBounds[i] = model.dataBounds[i];
        }
      }

      // did something significant change? If so rebuild a lot of things
      if (facesChanged || boundsChanged || model.forceUpdate) {
        // compute the edges to draw
        // for each drawn face, mark edges, all single mark edges we draw
        const edgesToDraw = new Array(12).fill(0);
        for (let f = 0; f < 6; f++) {
          if (facesToDraw[f]) {
            for (let e = 0; e < 4; e++) {
              edgesToDraw[faceEdges[f][e]]++;
            }
          }
        }

        // compute tick marks for axes
        const ticks = [];
        const tickStrings = [];
        for (let i = 0; i < 3; i++) {
          const scale = linear().domain([model.dataBounds[i * 2], model.dataBounds[i * 2 + 1]]);
          ticks[i] = scale.ticks(5);
          const format = scale.tickFormat(5);
          tickStrings[i] = ticks[i].map(format);
        }

        // update gridlines / edge lines
        publicAPI.updatePolyData(facesToDraw, edgesToDraw, ticks);

        // compute label world coords and text
        publicAPI.updateTextData(facesToDraw, edgesToDraw, ticks, tickStrings);

        // rebuild the texture only when force or changed bounds, face
        // visibility changes do to change the atlas
        if (boundsChanged || model.forceUpdate) {
          publicAPI.updateTextureAtlas(tickStrings);
        }
      }
      model.forceUpdate = false;
    };

    // create the texture map atlas that contains the rendering of
    // all the text strings. Only needs to be called when the text strings
    // have changed (labels and ticks)
    publicAPI.updateTextureAtlas = tickStrings => {
      // compute the width and height we need

      // set the text properties
      model.tmContext.textBaseline = 'bottom';
      model.tmContext.textAlign = 'left';

      // first the three labels
      model._tmAtlas.clear();
      let maxWidth = 0;
      let totalHeight = 1; // start one pixel in so we have a border
      for (let i = 0; i < 3; i++) {
        if (!model._tmAtlas.has(model.axisLabels[i])) {
          applyTextStyle$1(model.tmContext, model.axisTextStyle);
          const metrics = model.tmContext.measureText(model.axisLabels[i]);
          const entry = {
            height: metrics.actualBoundingBoxAscent + 2,
            startingHeight: totalHeight,
            width: metrics.width + 2,
            textStyle: model.axisTextStyle
          };
          model._tmAtlas.set(model.axisLabels[i], entry);
          totalHeight += entry.height;
          if (maxWidth < entry.width) {
            maxWidth = entry.width;
          }
        }
        // and the ticks
        applyTextStyle$1(model.tmContext, model.tickTextStyle);
        for (let t = 0; t < tickStrings[i].length; t++) {
          if (!model._tmAtlas.has(tickStrings[i][t])) {
            const metrics = model.tmContext.measureText(tickStrings[i][t]);
            const entry = {
              height: metrics.actualBoundingBoxAscent + 2,
              startingHeight: totalHeight,
              width: metrics.width + 2,
              textStyle: model.tickTextStyle
            };
            model._tmAtlas.set(tickStrings[i][t], entry);
            totalHeight += entry.height;
            if (maxWidth < entry.width) {
              maxWidth = entry.width;
            }
          }
        }
      }

      // always use power of two to avoid interpolation
      // in cases where PO2 is required
      maxWidth = nearestPowerOfTwo(maxWidth);
      totalHeight = nearestPowerOfTwo(totalHeight);

      // set the tcoord values
      model._tmAtlas.forEach(value => {
        value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];
      });

      // make sure we have power of two dimensions
      model.tmCanvas.width = maxWidth;
      model.tmCanvas.height = totalHeight;
      model.tmContext.textBaseline = 'bottom';
      model.tmContext.textAlign = 'left';
      model.tmContext.clearRect(0, 0, maxWidth, totalHeight);

      // draw the text onto the texture
      model._tmAtlas.forEach((value, key) => {
        applyTextStyle$1(model.tmContext, value.textStyle);
        model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);
      });
      model.tmTexture.setCanvas(model.tmCanvas);
      model.tmTexture.modified();
    };

    // Make sure the data is correct
    publicAPI.onModified(() => {
      model.forceUpdate = true;
      publicAPI.update();
    });
    publicAPI.setTickTextStyle = tickStyle => {
      model.tickTextStyle = {
        ...model.tickTextStyle,
        ...tickStyle
      };
      publicAPI.modified();
    };
    publicAPI.setAxisTextStyle = axisStyle => {
      model.axisTextStyle = {
        ...model.axisTextStyle,
        ...axisStyle
      };
      publicAPI.modified();
    };
    publicAPI.get_tmAtlas = () => model._tmAtlas;

    // try to get the bounds for the annotation. This is complicated
    // as it relies on the pixel size of the window. Every time the camera
    // changes the bounds change. This method simplifies by just expanding
    // the grid bounds by a user specified factor.
    publicAPI.getBounds = () => {
      publicAPI.update();
      vtkBoundingBox.setBounds(model.bounds, model.gridActor.getBounds());
      vtkBoundingBox.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);
      return model.bounds;
    };

    // Make sure the grid share the actor property
    const _setProp = macro.chain(publicAPI.setProperty, model.gridActor.setProperty);
    publicAPI.setProperty = p => _setProp(p)[0];
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  function defaultValues$2(initialValues) {
    return {
      boundsScaleFactor: 1.3,
      camera: null,
      dataBounds: [...vtkBoundingBox.INIT_BOUNDS],
      faceVisibilityAngle: 8,
      gridLines: true,
      axisLabels: null,
      axisTitlePixelOffset: 35.0,
      axisTextStyle: {
        fontColor: 'white',
        fontStyle: 'normal',
        fontSize: 18,
        fontFamily: 'serif'
      },
      tickLabelPixelOffset: 12.0,
      tickTextStyle: {
        fontColor: 'white',
        fontStyle: 'normal',
        fontSize: 14,
        fontFamily: 'serif'
      },
      ...initialValues
    };
  }

  // ----------------------------------------------------------------------------

  function extend$1c(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, defaultValues$2(initialValues));

    // Inheritance
    vtkActor$1.extend(publicAPI, model, initialValues);

    // internal variables
    model.lastFacesToDraw = [false, false, false, false, false, false];
    model.axisLabels = ['X-Axis', 'Y-Axis', 'Z-Axis'];
    model.tickCounts = [];
    model.textValues = [];
    model.lastTickBounds = [];
    model.tmCanvas = document.createElement('canvas');
    model.tmContext = model.tmCanvas.getContext('2d');
    model._tmAtlas = new Map();

    // for texture atlas
    model.tmTexture = vtkTexture$1.newInstance();
    model.tmTexture.setInterpolate(false);
    publicAPI.getProperty().setDiffuse(0.0);
    publicAPI.getProperty().setAmbient(1.0);
    model.gridMapper = vtkMapper$1.newInstance();
    model.polyData = vtkPolyData$1.newInstance();
    model.gridMapper.setInputData(model.polyData);
    model.gridActor = vtkActor$1.newInstance();
    model.gridActor.setMapper(model.gridMapper);
    model.gridActor.setProperty(publicAPI.getProperty());
    model.gridActor.setParentProp(publicAPI);
    model.textPolyData = vtkPolyData$1.newInstance();
    macro.setGet(publicAPI, model, ['axisTitlePixelOffset', 'boundsScaleFactor', 'faceVisibilityAngle', 'gridLines', 'tickLabelPixelOffset']);
    macro.setGetArray(publicAPI, model, ['dataBounds'], 6);
    macro.setGetArray(publicAPI, model, ['axisLabels'], 3);
    macro.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle', 'camera', 'tmTexture', 'textValues', 'textPolyData', 'tickCounts', 'gridActor']);

    // Object methods
    vtkCubeAxesActor(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1c = macro.newInstance(extend$1c, 'vtkCubeAxesActor');

  // ----------------------------------------------------------------------------

  var vtkCubeAxesActor$1 = {
    newInstance: newInstance$1c,
    extend: extend$1c,
    newCubeAxesActorHelper
  };

  // ----------------------------------------------------------------------------
  // vtkOpenGLCubeAxesActor methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLCubeAxesActor(publicAPI, model) {
    model.classHierarchy.push('vtkOpenGLCubeAxesActor');

    // Builds myself.
    publicAPI.buildPass = prepass => {
      if (prepass) {
        model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
        model._openGLRenderWindow = model._openGLRenderer.getParent();
        if (!model.CubeAxesActorHelper.getRenderable()) {
          model.CubeAxesActorHelper.setRenderable(model.renderable);
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
        publicAPI.addMissingNode(model.renderable.getGridActor());
        publicAPI.removeUnusedNodes();
      }
    };
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass) {
        const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
        const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
        model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$19 = {};

  // ----------------------------------------------------------------------------

  function extend$1b(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$19, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();

    // Object methods
    vtkOpenGLCubeAxesActor(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1b = newInstance$1I(extend$1b, 'vtkOpenGLCubeAxesActor');

  // Register ourself to OpenGL backend if imported
  registerOverride$1('vtkCubeAxesActor', newInstance$1b);

  const ObjectType$1 = {
    ARRAY_BUFFER: 0,
    ELEMENT_ARRAY_BUFFER: 1,
    TEXTURE_BUFFER: 2
  };
  var Constants$5 = {
    ObjectType: ObjectType$1
  };

  const {
    ObjectType
  } = Constants$5;

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  // ----------------------------------------------------------------------------
  // Static API
  // ----------------------------------------------------------------------------

  const STATIC$2 = {};

  // ----------------------------------------------------------------------------
  // vtkOpenGLBufferObject methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLBufferObject(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLBufferObject');

    // Class-specific private functions
    function convertType(type) {
      switch (type) {
        case ObjectType.ELEMENT_ARRAY_BUFFER:
          return model.context.ELEMENT_ARRAY_BUFFER;
        case ObjectType.TEXTURE_BUFFER:
          if ('TEXTURE_BUFFER' in model.context) {
            return model.context.TEXTURE_BUFFER;
          }
        /* eslint-disable no-fallthrough */
        // Intentional fallthrough in case there is no TEXTURE_BUFFER in WebGL
        case ObjectType.ARRAY_BUFFER:
        default:
          return model.context.ARRAY_BUFFER;
        /* eslint-enable no-fallthrough */
      }
    }

    let internalType = null;
    let internalHandle = null;
    let dirty = true;
    let error = '';

    // Public API methods
    publicAPI.getType = () => internalType;
    publicAPI.setType = value => {
      internalType = value;
    };
    publicAPI.getHandle = () => internalHandle;
    publicAPI.isReady = () => dirty === false;
    publicAPI.generateBuffer = type => {
      const objectTypeGL = convertType(type);
      if (internalHandle === null) {
        internalHandle = model.context.createBuffer();
        internalType = type;
      }
      return convertType(internalType) === objectTypeGL;
    };
    publicAPI.upload = (data, type) => {
      // buffer, size, type
      const alreadyGenerated = publicAPI.generateBuffer(type);
      if (!alreadyGenerated) {
        error = 'Trying to upload array buffer to incompatible buffer.';
        return false;
      }
      model.context.bindBuffer(convertType(internalType), internalHandle);
      model.context.bufferData(convertType(internalType), data, model.context.STATIC_DRAW);
      model.allocatedGPUMemoryInBytes = data.length * data.BYTES_PER_ELEMENT;
      dirty = false;
      return true;
    };
    publicAPI.bind = () => {
      if (!internalHandle) {
        return false;
      }
      model.context.bindBuffer(convertType(internalType), internalHandle);
      return true;
    };
    publicAPI.release = () => {
      if (!internalHandle) {
        return false;
      }
      model.context.bindBuffer(convertType(internalType), null);
      return true;
    };
    publicAPI.releaseGraphicsResources = () => {
      if (internalHandle !== null) {
        model.context.bindBuffer(convertType(internalType), null);
        model.context.deleteBuffer(internalHandle);
        internalHandle = null;
        model.allocatedGPUMemoryInBytes = 0;
      }
    };
    publicAPI.setOpenGLRenderWindow = rw => {
      if (model._openGLRenderWindow === rw) {
        return;
      }
      publicAPI.releaseGraphicsResources();
      model._openGLRenderWindow = rw;
      model.context = null;
      if (rw) {
        model.context = model._openGLRenderWindow.getContext();
      }
    };
    publicAPI.getError = () => error;
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$18 = {
    objectType: ObjectType.ARRAY_BUFFER,
    // _openGLRenderWindow: null,
    context: null,
    allocatedGPUMemoryInBytes: 0
  };

  // ----------------------------------------------------------------------------

  function extend$1a(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$18, initialValues);

    // Object methods
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ['_openGLRenderWindow', 'allocatedGPUMemoryInBytes']);
    macro.moveToProtected(publicAPI, model, ['openGLRenderWindow']);
    vtkOpenGLBufferObject(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1a = macro.newInstance(extend$1a);

  // ----------------------------------------------------------------------------

  var vtkBufferObject = {
    newInstance: newInstance$1a,
    extend: extend$1a,
    ...STATIC$2,
    ...Constants$5
  };

  const {
    vtkErrorMacro: vtkErrorMacro$m
  } = macro;

  // ----------------------------------------------------------------------------
  // Static functions
  // ----------------------------------------------------------------------------

  function computeInverseShiftAndScaleMatrix(coordShift, coordScale) {
    const inverseScale = new Float64Array(3);
    inverse(inverseScale, coordScale);
    const matrix = new Float64Array(16);
    fromRotationTranslationScale(matrix, create(), coordShift, inverseScale);
    return matrix;
  }
  function shouldApplyCoordShiftAndScale(coordShift, coordScale) {
    if (coordShift === null || coordScale === null) {
      return false;
    }
    return !(exactEquals(coordShift, [0, 0, 0]) && exactEquals(coordScale, [1, 1, 1]));
  }

  // ----------------------------------------------------------------------------
  // vtkOpenGLCellArrayBufferObject methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLCellArrayBufferObject(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');
    publicAPI.setType(ObjectType$1.ARRAY_BUFFER);
    publicAPI.createVBO = function (cellArray, inRep, outRep, options) {
      let selectionMaps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      if (!cellArray.getData() || !cellArray.getData().length) {
        model.elementCount = 0;
        return 0;
      }

      // Figure out how big each block will be, currently 6 or 7 floats.
      model.blockSize = 3;
      model.vertexOffset = 0;
      model.normalOffset = 0;
      model.tCoordOffset = 0;
      model.tCoordComponents = 0;
      model.colorComponents = 0;
      model.colorOffset = 0;
      model.customData = [];
      const pointData = options.points.getData();
      let normalData = null;
      let tcoordData = null;
      let colorData = null;
      const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;
      const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;

      // the values of 4 below are because floats are 4 bytes

      if (options.normals) {
        model.normalOffset = 4 * model.blockSize;
        model.blockSize += 3;
        normalData = options.normals.getData();
      }
      if (options.customAttributes) {
        options.customAttributes.forEach(a => {
          if (a) {
            model.customData.push({
              data: a.getData(),
              offset: 4 * model.blockSize,
              components: a.getNumberOfComponents(),
              name: a.getName()
            });
            model.blockSize += a.getNumberOfComponents();
          }
        });
      }
      if (options.tcoords) {
        model.tCoordOffset = 4 * model.blockSize;
        model.tCoordComponents = textureComponents;
        model.blockSize += textureComponents;
        tcoordData = options.tcoords.getData();
      }
      if (options.colors) {
        model.colorComponents = options.colors.getNumberOfComponents();
        model.colorOffset = 0;
        colorData = options.colors.getData();
        if (!model.colorBO) {
          model.colorBO = vtkBufferObject.newInstance();
        }
        model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);
      } else {
        model.colorBO = null;
      }
      model.stride = 4 * model.blockSize;
      let pointIdx = 0;
      let normalIdx = 0;
      let tcoordIdx = 0;
      let colorIdx = 0;
      let custIdx = 0;
      let cellCount = 0;
      let addAPoint;
      const cellBuilders = {
        // easy, every input point becomes an output point
        anythingToPoints(numPoints, cellPts, offset) {
          for (let i = 0; i < numPoints; ++i) {
            addAPoint(cellPts[offset + i]);
          }
        },
        linesToWireframe(numPoints, cellPts, offset) {
          // for lines we add a bunch of segments
          for (let i = 0; i < numPoints - 1; ++i) {
            addAPoint(cellPts[offset + i]);
            addAPoint(cellPts[offset + i + 1]);
          }
        },
        polysToWireframe(numPoints, cellPts, offset) {
          // for polys we add a bunch of segments and close it
          if (numPoints > 2) {
            for (let i = 0; i < numPoints; ++i) {
              addAPoint(cellPts[offset + i]);
              addAPoint(cellPts[offset + (i + 1) % numPoints]);
            }
          }
        },
        stripsToWireframe(numPoints, cellPts, offset) {
          if (numPoints > 2) {
            // for strips we add a bunch of segments and close it
            for (let i = 0; i < numPoints - 1; ++i) {
              addAPoint(cellPts[offset + i]);
              addAPoint(cellPts[offset + i + 1]);
            }
            for (let i = 0; i < numPoints - 2; i++) {
              addAPoint(cellPts[offset + i]);
              addAPoint(cellPts[offset + i + 2]);
            }
          }
        },
        polysToSurface(npts, cellPts, offset) {
          for (let i = 0; i < npts - 2; i++) {
            addAPoint(cellPts[offset + 0]);
            addAPoint(cellPts[offset + i + 1]);
            addAPoint(cellPts[offset + i + 2]);
          }
        },
        stripsToSurface(npts, cellPts, offset) {
          for (let i = 0; i < npts - 2; i++) {
            addAPoint(cellPts[offset + i]);
            addAPoint(cellPts[offset + i + 1 + i % 2]);
            addAPoint(cellPts[offset + i + 1 + (i + 1) % 2]);
          }
        }
      };
      const cellCounters = {
        // easy, every input point becomes an output point
        anythingToPoints(numPoints, cellPts) {
          return numPoints;
        },
        linesToWireframe(numPoints, cellPts) {
          if (numPoints > 1) {
            return (numPoints - 1) * 2;
          }
          return 0;
        },
        polysToWireframe(numPoints, cellPts) {
          if (numPoints > 2) {
            return numPoints * 2;
          }
          return 0;
        },
        stripsToWireframe(numPoints, cellPts) {
          if (numPoints > 2) {
            return numPoints * 4 - 6;
          }
          return 0;
        },
        polysToSurface(npts, cellPts) {
          if (npts > 2) {
            return (npts - 2) * 3;
          }
          return 0;
        },
        stripsToSurface(npts, cellPts, offset) {
          if (npts > 2) {
            return (npts - 2) * 3;
          }
          return 0;
        }
      };
      let func = null;
      let countFunc = null;
      if (outRep === Representation$6.POINTS || inRep === 'verts') {
        func = cellBuilders.anythingToPoints;
        countFunc = cellCounters.anythingToPoints;
      } else if (outRep === Representation$6.WIREFRAME || inRep === 'lines') {
        func = cellBuilders[`${inRep}ToWireframe`];
        countFunc = cellCounters[`${inRep}ToWireframe`];
      } else {
        func = cellBuilders[`${inRep}ToSurface`];
        countFunc = cellCounters[`${inRep}ToSurface`];
      }
      const array = cellArray.getData();
      const size = array.length;
      let caboCount = 0;
      for (let index = 0; index < size;) {
        caboCount += countFunc(array[index], array);
        index += array[index] + 1;
      }
      let packedUCVBO = null;
      const packedVBO = new Float32Array(caboCount * model.blockSize);
      if (colorData) {
        packedUCVBO = new Uint8Array(caboCount * 4);
      }
      let vboidx = 0;
      let ucidx = 0;

      // Find out if shift scale should be used
      // Compute squares of diagonal size and distance from the origin
      let diagSq = 0.0;
      let distSq = 0.0;
      for (let i = 0; i < 3; ++i) {
        const range = options.points.getRange(i);
        const delta = range[1] - range[0];
        diagSq += delta * delta;
        const distShift = 0.5 * (range[1] + range[0]);
        distSq += distShift * distShift;
      }
      const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1.0e6 ||
      // If data is far from the origin relative to its size
      Math.abs(Math.log10(diagSq)) > 3.0 ||
      // If the size is huge when not far from the origin
      diagSq === 0 && distSq > 1.0e6); // If data is a point, but far from the origin

      if (useShiftAndScale) {
        // Compute shift and scale vectors
        const coordShift = new Float64Array(3);
        const coordScale = new Float64Array(3);
        for (let i = 0; i < 3; ++i) {
          const range = options.points.getRange(i);
          const delta = range[1] - range[0];
          coordShift[i] = 0.5 * (range[1] + range[0]);
          coordScale[i] = delta > 0 ? 1.0 / delta : 1.0;
        }
        publicAPI.setCoordShiftAndScale(coordShift, coordScale);
      } else if (model.coordShiftAndScaleEnabled === true) {
        // Make sure to reset
        publicAPI.setCoordShiftAndScale(null, null);
      }

      // Initialize the structures used to keep track of point ids and cell ids for selectors
      if (selectionMaps) {
        if (!selectionMaps.points && !selectionMaps.cells) {
          selectionMaps.points = new Int32Array(caboCount);
          selectionMaps.cells = new Int32Array(caboCount);
        } else {
          const newPoints = new Int32Array(caboCount + selectionMaps.points.length);
          newPoints.set(selectionMaps.points);
          selectionMaps.points = newPoints;
          const newCells = new Int32Array(caboCount + selectionMaps.cells.length);
          newCells.set(selectionMaps.cells);
          selectionMaps.cells = newCells;
        }
      }
      let pointCount = options.vertexOffset;
      addAPoint = function addAPointFunc(i) {
        // Keep track of original point and cell ids, for selection
        if (selectionMaps) {
          selectionMaps.points[pointCount] = i;
          selectionMaps.cells[pointCount] = cellCount + options.cellOffset;
        }
        ++pointCount;

        // Vertices
        pointIdx = i * 3;
        if (!model.coordShiftAndScaleEnabled) {
          packedVBO[vboidx++] = pointData[pointIdx++];
          packedVBO[vboidx++] = pointData[pointIdx++];
          packedVBO[vboidx++] = pointData[pointIdx++];
        } else {
          // Apply shift and scale
          packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];
          packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];
          packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];
        }
        if (normalData !== null) {
          if (options.haveCellNormals) {
            normalIdx = (cellCount + options.cellOffset) * 3;
          } else {
            normalIdx = i * 3;
          }
          packedVBO[vboidx++] = normalData[normalIdx++];
          packedVBO[vboidx++] = normalData[normalIdx++];
          packedVBO[vboidx++] = normalData[normalIdx++];
        }
        model.customData.forEach(attr => {
          custIdx = i * attr.components;
          for (let j = 0; j < attr.components; ++j) {
            packedVBO[vboidx++] = attr.data[custIdx++];
          }
        });
        if (tcoordData !== null) {
          tcoordIdx = i * textureComponents;
          for (let j = 0; j < textureComponents; ++j) {
            packedVBO[vboidx++] = tcoordData[tcoordIdx++];
          }
        }
        if (colorData !== null) {
          if (options.haveCellScalars) {
            colorIdx = (cellCount + options.cellOffset) * colorComponents;
          } else {
            colorIdx = i * colorComponents;
          }
          packedUCVBO[ucidx++] = colorData[colorIdx++];
          packedUCVBO[ucidx++] = colorData[colorIdx++];
          packedUCVBO[ucidx++] = colorData[colorIdx++];
          packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;
        }
      };
      for (let index = 0; index < size;) {
        func(array[index], array, index + 1);
        index += array[index] + 1;
        cellCount++;
      }
      model.elementCount = caboCount;
      publicAPI.upload(packedVBO, ObjectType$1.ARRAY_BUFFER);
      if (model.colorBO) {
        model.colorBOStride = 4;
        model.colorBO.upload(packedUCVBO, ObjectType$1.ARRAY_BUFFER);
      }
      return cellCount;
    };
    publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {
      if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {
        vtkErrorMacro$m('Wrong type for coordShift, expected vec3 or null');
        return;
      }
      if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {
        vtkErrorMacro$m('Wrong type for coordScale, expected vec3 or null');
        return;
      }
      if (model.coordShift === null || coordShift === null || !equals$1(coordShift, model.coordShift)) {
        model.coordShift = coordShift;
      }
      if (model.coordScale === null || coordScale === null || !equals$1(coordScale, model.coordScale)) {
        model.coordScale = coordScale;
      }
      model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);
      if (model.coordShiftAndScaleEnabled) {
        model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);
      } else {
        model.inverseShiftAndScaleMatrix = null;
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$17 = {
    elementCount: 0,
    stride: 0,
    colorBOStride: 0,
    vertexOffset: 0,
    normalOffset: 0,
    tCoordOffset: 0,
    tCoordComponents: 0,
    colorOffset: 0,
    colorComponents: 0,
    tcoordBO: null,
    customData: [],
    coordShift: null,
    coordScale: null,
    coordShiftAndScaleEnabled: false,
    inverseShiftAndScaleMatrix: null
  };

  // ----------------------------------------------------------------------------

  function extend$19(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$17, initialValues);

    // Inheritance
    vtkBufferObject.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ['colorBO', 'elementCount', 'stride', 'colorBOStride', 'vertexOffset', 'normalOffset', 'tCoordOffset', 'tCoordComponents', 'colorOffset', 'colorComponents', 'customData']);
    macro.get(publicAPI, model, ['coordShift', 'coordScale', 'coordShiftAndScaleEnabled', 'inverseShiftAndScaleMatrix']);

    // Object specific methods
    vtkOpenGLCellArrayBufferObject(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$19 = macro.newInstance(extend$19);

  // ----------------------------------------------------------------------------

  var vtkCellArrayBufferObject = {
    newInstance: newInstance$19,
    extend: extend$19
  };

  const {
    vtkErrorMacro: vtkErrorMacro$l
  } = macro;

  // export const SHADER_TYPES = ['Vertex', 'Fragment', 'Geometry', 'Unknown'];

  // ----------------------------------------------------------------------------
  // vtkShader methods
  // ----------------------------------------------------------------------------

  function vtkShader(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkShader');
    publicAPI.compile = () => {
      let stype = model.context.VERTEX_SHADER;
      if (!model.source || !model.source.length || model.shaderType === 'Unknown') {
        return false;
      }

      // Ensure we delete the previous shader if necessary.
      if (model.handle !== 0) {
        model.context.deleteShader(model.handle);
        model.handle = 0;
      }
      switch (model.shaderType) {
        // case vtkShader::Geometry:
        //   type = GL_GEOMETRY_SHADER;
        //   break;
        case 'Fragment':
          stype = model.context.FRAGMENT_SHADER;
          break;
        case 'Vertex':
        default:
          stype = model.context.VERTEX_SHADER;
          break;
      }
      model.handle = model.context.createShader(stype);
      model.context.shaderSource(model.handle, model.source);
      model.context.compileShader(model.handle);
      const isCompiled = model.context.getShaderParameter(model.handle, model.context.COMPILE_STATUS);
      if (!isCompiled) {
        const lastError = model.context.getShaderInfoLog(model.handle);
        vtkErrorMacro$l(`Error compiling shader '${model.source}': ${lastError}`);
        model.context.deleteShader(model.handle);
        model.handle = 0;
        return false;
      }

      // The shader compiled, store its handle and return success.
      return true;
    };
    publicAPI.cleanup = () => {
      if (model.shaderType === 'Unknown' || model.handle === 0) {
        return;
      }
      model.context.deleteShader(model.handle);
      model.handle = 0;
      model.dirty = true;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$16 = {
    shaderType: 'Unknown',
    source: '',
    error: '',
    handle: 0,
    dirty: false,
    context: null
  };

  // ----------------------------------------------------------------------------

  function extend$18(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$16, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ['shaderType', 'source', 'error', 'handle', 'context']);

    // Object methods
    vtkShader(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$18 = macro.newInstance(extend$18, 'vtkShader');

  // ----------------------------------------------------------------------------

  var vtkShader$1 = {
    newInstance: newInstance$18,
    extend: extend$18
  };

  const {
    vtkErrorMacro: vtkErrorMacro$k
  } = macro;

  // perform in place string substitutions, indicate if a substitution was done
  // this is useful for building up shader strings which typically involve
  // lots of string substitutions. Return true if a substitution was done.
  function substitute$1(source, search, replace, all) {
    // We only accept strings or array of strings, typeof is faster than Array.isArray
    const replaceStr = typeof replace === 'string' ? replace : replace.join('\n');

    // We don't need to instantiate a RegExp if we don't want a global substitution.
    // In all other cases, we need to take the provided string or RegExp and
    // instantiate a new one to add the `g` flag.
    // Argument defaults are transpiled to slow `arguments`-based operations
    // better assume undefined as flag to know if the value is set or not
    const replaceSearch = all === false ? search : new RegExp(search, 'g');
    const resultstr = source.replace(replaceSearch, replaceStr);
    return {
      // If the result is different than the input, we did perform a replacement
      replace: resultstr !== replaceStr,
      result: resultstr
    };
  }

  // ----------------------------------------------------------------------------
  // vtkShaderProgram methods
  // ----------------------------------------------------------------------------

  function vtkShaderProgram(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkShaderProgram');
    publicAPI.compileShader = () => {
      if (!model.vertexShader.compile()) {
        vtkErrorMacro$k(model.vertexShader.getSource().split('\n').map((line, index) => `${index}: ${line}`).join('\n'));
        vtkErrorMacro$k(model.vertexShader.getError());
        return 0;
      }
      if (!model.fragmentShader.compile()) {
        vtkErrorMacro$k(model.fragmentShader.getSource().split('\n').map((line, index) => `${index}: ${line}`).join('\n'));
        vtkErrorMacro$k(model.fragmentShader.getError());
        return 0;
      }
      // skip geometry for now
      if (!publicAPI.attachShader(model.vertexShader)) {
        vtkErrorMacro$k(model.error);
        return 0;
      }
      if (!publicAPI.attachShader(model.fragmentShader)) {
        vtkErrorMacro$k(model.error);
        return 0;
      }
      if (!publicAPI.link()) {
        vtkErrorMacro$k(`Links failed: ${model.error}`);
        return 0;
      }
      publicAPI.setCompiled(true);
      return 1;
    };
    publicAPI.cleanup = () => {
      if (model.shaderType === 'Unknown' || model.handle === 0) {
        return;
      }
      publicAPI.release();
      if (model.vertexShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.vertexShaderHandle);
        model.vertexShaderHandle = 0;
      }
      if (model.fragmentShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.fragmentShaderHandle);
        model.fragmentShaderHandle = 0;
      }
      model.context.deleteProgram(model.handle);
      model.handle = 0;
      publicAPI.setCompiled(false);
    };
    publicAPI.bind = () => {
      if (!model.linked && !publicAPI.link()) {
        return false;
      }
      model.context.useProgram(model.handle);
      publicAPI.setBound(true);
      return true;
    };
    publicAPI.isBound = () => !!model.bound;
    publicAPI.release = () => {
      model.context.useProgram(null);
      publicAPI.setBound(false);
    };
    publicAPI.setContext = ctx => {
      model.vertexShader.setContext(ctx);
      model.fragmentShader.setContext(ctx);
      model.geometryShader.setContext(ctx);
    };
    publicAPI.link = () => {
      if (model.linked) {
        return true;
      }
      if (model.handle === 0) {
        model.error = 'Program has not been initialized, and/or does not have shaders.';
        return false;
      }

      // clear out the list of uniforms used
      model.uniformLocs = {};
      model.context.linkProgram(model.handle);
      const isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);
      if (!isCompiled) {
        const lastError = model.context.getProgramInfoLog(model.handle);
        vtkErrorMacro$k(`Error linking shader ${lastError}`);
        model.handle = 0;
        return false;
      }
      publicAPI.setLinked(true);
      model.attributeLocs = {};
      return true;
    };
    publicAPI.setUniformMatrix = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      const f32 = new Float32Array(v);
      model.context.uniformMatrix4fv(location, false, f32);
      return true;
    };
    publicAPI.setUniformMatrix3x3 = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      const f32 = new Float32Array(v);
      model.context.uniformMatrix3fv(location, false, f32);
      return true;
    };
    publicAPI.setUniformf = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform1f(location, v);
      return true;
    };
    publicAPI.setUniformfv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform1fv(location, v);
      return true;
    };
    publicAPI.setUniformi = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform1i(location, v);
      return true;
    };
    publicAPI.setUniformiv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform1iv(location, v);
      return true;
    };
    publicAPI.setUniform2f = (name, v1, v2) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      if (v2 === undefined) {
        throw new RangeError('Invalid number of values for array');
      }
      model.context.uniform2f(location, v1, v2);
      return true;
    };
    publicAPI.setUniform2fv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform2fv(location, v);
      return true;
    };
    publicAPI.setUniform2i = (name, v1, v2) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      if (v2 === undefined) {
        throw new RangeError('Invalid number of values for array');
      }
      model.context.uniform2i(location, v1, v2);
      return true;
    };
    publicAPI.setUniform2iv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform2iv(location, v);
      return true;
    };
    publicAPI.setUniform3f = (name, a1, a2, a3) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      if (a3 === undefined) {
        throw new RangeError('Invalid number of values for array');
      }
      model.context.uniform3f(location, a1, a2, a3);
      return true;
    };
    publicAPI.setUniform3fArray = (name, a) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      if (!Array.isArray(a) || a.length !== 3) {
        throw new RangeError('Invalid number of values for array');
      }
      model.context.uniform3f(location, a[0], a[1], a[2]);
      return true;
    };
    publicAPI.setUniform3fv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform3fv(location, v);
      return true;
    };
    publicAPI.setUniform3i = function (name) {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      let array = args;
      // allow an array passed as a single argument
      if (array.length === 1 && Array.isArray(array[0])) {
        array = array[0];
      }
      if (array.length !== 3) {
        throw new RangeError('Invalid number of values for array');
      }
      model.context.uniform3i(location, array[0], array[1], array[2]);
      return true;
    };
    publicAPI.setUniform3iv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform3iv(location, v);
      return true;
    };
    publicAPI.setUniform4f = function (name) {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      let array = args;
      // allow an array passed as a single argument
      if (array.length === 1 && Array.isArray(array[0])) {
        array = array[0];
      }
      if (array.length !== 4) {
        throw new RangeError('Invalid number of values for array');
      }
      model.context.uniform4f(location, array[0], array[1], array[2], array[3]);
      return true;
    };
    publicAPI.setUniform4fv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform4fv(location, v);
      return true;
    };
    publicAPI.setUniform4i = function (name) {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      let array = args;
      // allow an array passed as a single argument
      if (array.length === 1 && Array.isArray(array[0])) {
        array = array[0];
      }
      if (array.length !== 4) {
        throw new RangeError('Invalid number of values for array');
      }
      model.context.uniform4i(location, array[0], array[1], array[2], array[3]);
      return true;
    };
    publicAPI.setUniform4iv = (name, v) => {
      const location = publicAPI.findUniform(name);
      if (location === -1) {
        model.error = `Could not set uniform ${name} . No such uniform.`;
        return false;
      }
      model.context.uniform4iv(location, v);
      return true;
    };
    publicAPI.findUniform = name => {
      if (!name || !model.linked) {
        return -1;
      }

      // see if we have cached the result
      let loc = model.uniformLocs[name];
      if (loc !== undefined) {
        return loc;
      }
      loc = model.context.getUniformLocation(model.handle, name);
      if (loc === null) {
        model.error = `Uniform ${name} not found in current shader program.`;
        model.uniformLocs[name] = -1;
        return -1;
      }
      model.uniformLocs[name] = loc;
      return loc;
    };
    publicAPI.isUniformUsed = name => {
      if (!name) {
        return false;
      }

      // see if we have cached the result
      let loc = model.uniformLocs[name];
      if (loc !== undefined) {
        return loc !== null;
      }
      if (!model.linked) {
        vtkErrorMacro$k('attempt to find uniform when the shader program is not linked');
        return false;
      }
      loc = model.context.getUniformLocation(model.handle, name);
      model.uniformLocs[name] = loc;
      if (loc === null) {
        return false;
      }
      return true;
    };
    publicAPI.isAttributeUsed = name => {
      if (!name) {
        return false;
      }

      // see if we have cached the result
      if (name in model.attributeLocs) {
        return true;
      }
      if (!model.linked) {
        vtkErrorMacro$k('attempt to find uniform when the shader program is not linked');
        return false;
      }
      const loc = model.context.getAttribLocation(model.handle, name);
      if (loc === -1) {
        return false;
      }
      model.attributeLocs[name] = loc;
      return true;
    };
    publicAPI.attachShader = shader => {
      if (shader.getHandle() === 0) {
        model.error = 'Shader object was not initialized, cannot attach it.';
        return false;
      }
      if (shader.getShaderType() === 'Unknown') {
        model.error = 'Shader object is of type Unknown and cannot be used.';
        return false;
      }
      if (model.handle === 0) {
        const thandle = model.context.createProgram();
        if (thandle === 0) {
          model.error = 'Could not create shader program.';
          return false;
        }
        model.handle = thandle;
        model.linked = false;
      }
      if (shader.getShaderType() === 'Vertex') {
        if (model.vertexShaderHandle !== 0) {
          model.context.detachShader(model.handle, model.vertexShaderHandle);
        }
        model.vertexShaderHandle = shader.getHandle();
      }
      if (shader.getShaderType() === 'Fragment') {
        if (model.fragmentShaderHandle !== 0) {
          model.context.detachShader(model.handle, model.fragmentShaderHandle);
        }
        model.fragmentShaderHandle = shader.getHandle();
      }
      model.context.attachShader(model.handle, shader.getHandle());
      publicAPI.setLinked(false);
      return true;
    };
    publicAPI.detachShader = shader => {
      if (shader.getHandle() === 0) {
        model.error = 'shader object was not initialized, cannot attach it.';
        return false;
      }
      if (shader.getShaderType() === 'Unknown') {
        model.error = 'Shader object is of type Unknown and cannot be used.';
        return false;
      }
      if (model.handle === 0) {
        model.error = 'This shader program has not been initialized yet.';
      }
      switch (shader.getShaderType()) {
        case 'Vertex':
          if (model.vertexShaderHandle !== shader.getHandle()) {
            model.error = 'The supplied shader was not attached to this program.';
            return false;
          }
          model.context.detachShader(model.handle, shader.getHandle());
          model.vertexShaderHandle = 0;
          model.linked = false;
          return true;
        case 'Fragment':
          if (model.fragmentShaderHandle !== shader.getHandle()) {
            model.error = 'The supplied shader was not attached to this program.';
            return false;
          }
          model.context.detachShader(model.handle, shader.getHandle());
          model.fragmentShaderHandle = 0;
          model.linked = false;
          return true;
        default:
          return false;
      }
    };
    publicAPI.setContext = ctx => {
      model.context = ctx;
      model.vertexShader.setContext(ctx);
      model.fragmentShader.setContext(ctx);
      model.geometryShader.setContext(ctx);
    };
    publicAPI.setLastCameraMTime = mtime => {
      model.lastCameraMTime = mtime;
    };

    // publicAPI.enableAttributeArray = (name) => {
    //   const location = publicAPI.findAttributeArray(name);
    //   if (location === -1) {
    //     model.error = `Could not enable attribute ${name} No such attribute.`;
    //     return false;
    //   }
    //   model.context.enableVertexAttribArray(location);
    //   return true;
    // };

    // publicAPI.disableAttributeArray = (name) => {
    //   const location = publicAPI.findAttributeArray(name);
    //   if (location === -1) {
    //     model.error = `Could not enable attribute ${name} No such attribute.`;
    //     return false;
    //   }
    //   model.context.disableVertexAttribArray(location);
    //   return true;
    // };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$15 = {
    vertexShaderHandle: 0,
    fragmentShaderHandle: 0,
    geometryShaderHandle: 0,
    vertexShader: null,
    fragmentShader: null,
    geometryShader: null,
    linked: false,
    bound: false,
    compiled: false,
    error: '',
    handle: 0,
    numberOfOutputs: 0,
    attributesLocs: null,
    uniformLocs: null,
    md5Hash: 0,
    context: null,
    lastCameraMTime: null
  };

  // ----------------------------------------------------------------------------

  function extend$17(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$15, initialValues);

    // Instantiate internal objects
    model.attributesLocs = {};
    model.uniformLocs = {};
    model.vertexShader = vtkShader$1.newInstance();
    model.vertexShader.setShaderType('Vertex');
    model.fragmentShader = vtkShader$1.newInstance();
    model.fragmentShader.setShaderType('Fragment');
    model.geometryShader = vtkShader$1.newInstance();
    model.geometryShader.setShaderType('Geometry');

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ['lastCameraMTime']);
    macro.setGet(publicAPI, model, ['error', 'handle', 'compiled', 'bound', 'md5Hash', 'vertexShader', 'fragmentShader', 'geometryShader', 'linked']);

    // Object methods
    vtkShaderProgram(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$17 = macro.newInstance(extend$17, 'vtkShaderProgram');

  // ----------------------------------------------------------------------------

  var vtkShaderProgram$1 = {
    newInstance: newInstance$17,
    extend: extend$17,
    substitute: substitute$1
  };

  // ----------------------------------------------------------------------------
  // vtkOpenGLVertexArrayObject methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLVertexArrayObject(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLVertexArrayObject');

    // Public API methods
    publicAPI.exposedMethod = () => {
      // This is a publicly exposed method of this object
    };
    publicAPI.initialize = () => {
      model.instancingExtension = null;
      if (!model._openGLRenderWindow.getWebgl2()) {
        model.instancingExtension = model.context.getExtension('ANGLE_instanced_arrays');
      }
      if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {
        model.extension = null;
        model.supported = true;
        model.handleVAO = model.context.createVertexArray();
      } else {
        model.extension = model.context.getExtension('OES_vertex_array_object');
        // Start setting up VAO
        if (!model.forceEmulation && model.extension) {
          model.supported = true;
          model.handleVAO = model.extension.createVertexArrayOES();
        } else {
          model.supported = false;
        }
      }
    };
    publicAPI.isReady = () =>
    // We either probed and allocated a VAO, or are falling back as the current
    // hardware does not support VAOs.
    model.handleVAO !== 0 || model.supported === false;
    publicAPI.bind = () => {
      // Either simply bind the VAO, or emulate behavior by binding all attributes.
      if (!publicAPI.isReady()) {
        publicAPI.initialize();
      }
      if (publicAPI.isReady() && model.supported) {
        if (model.extension) {
          model.extension.bindVertexArrayOES(model.handleVAO);
        } else {
          model.context.bindVertexArray(model.handleVAO);
        }
      } else if (publicAPI.isReady()) {
        const gl = model.context;
        for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
          const buff = model.buffers[ibuff];
          model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
            const attrIt = buff.attributes[iatt];
            const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
            for (let i = 0; i < matrixCount; ++i) {
              gl.enableVertexAttribArray(attrIt.index + i);
              gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
              if (attrIt.divisor > 0) {
                if (model.instancingExtension) {
                  model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);
                } else {
                  gl.vertexAttribDivisor(attrIt.index + i, 1);
                }
              }
            }
          }
        }
      }
    };
    publicAPI.release = () => {
      // Either simply release the VAO, or emulate behavior by releasing all attributes.
      if (publicAPI.isReady() && model.supported) {
        if (model.extension) {
          model.extension.bindVertexArrayOES(null);
        } else {
          model.context.bindVertexArray(null);
        }
      } else if (publicAPI.isReady()) {
        const gl = model.context;
        for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
          const buff = model.buffers[ibuff];
          model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
            const attrIt = buff.attributes[iatt];
            const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
            for (let i = 0; i < matrixCount; ++i) {
              gl.enableVertexAttribArray(attrIt.index + i);
              gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
              if (attrIt.divisor > 0) {
                if (model.instancingExtension) {
                  model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);
                } else {
                  gl.vertexAttribDivisor(attrIt.index + i, 0);
                }
              }
              gl.disableVertexAttribArray(attrIt.index + i);
            }
          }
        }
      }
    };
    publicAPI.shaderProgramChanged = () => {
      publicAPI.release();
      if (model.handleVAO) {
        if (model.extension) {
          model.extension.deleteVertexArrayOES(model.handleVAO);
        } else {
          model.context.deleteVertexArray(model.handleVAO);
        }
      }
      model.handleVAO = 0;
      model.handleProgram = 0;
    };
    publicAPI.releaseGraphicsResources = () => {
      publicAPI.shaderProgramChanged();
      if (model.handleVAO) {
        if (model.extension) {
          model.extension.deleteVertexArrayOES(model.handleVAO);
        } else {
          model.context.deleteVertexArray(model.handleVAO);
        }
      }
      model.handleVAO = 0;
      model.supported = true;
      model.handleProgram = 0;
    };
    publicAPI.addAttributeArray = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize) => publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, 0, false);
    publicAPI.addAttributeArrayWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, isMatrix) => {
      if (!program) {
        return false;
      }

      // Check the program is bound, and the buffer is valid.
      if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType$1.ARRAY_BUFFER) {
        return false;
      }

      // Perform initialization if necessary, ensure program matches VAOs.
      if (model.handleProgram === 0) {
        model.handleProgram = program.getHandle();
      }
      if (!publicAPI.isReady()) {
        publicAPI.initialize();
      }
      if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {
        return false;
      }
      const gl = model.context;
      const attribs = {};
      attribs.name = name;
      attribs.index = gl.getAttribLocation(model.handleProgram, name);
      attribs.offset = offset;
      attribs.stride = stride;
      attribs.type = elementType;
      attribs.size = elementTupleSize;
      attribs.normalize = normalize;
      attribs.isMatrix = isMatrix;
      attribs.divisor = divisor;
      if (attribs.Index === -1) {
        return false;
      }

      // Always make the call as even the first use wants the attrib pointer setting
      // up when we are emulating.
      buffer.bind();
      gl.enableVertexAttribArray(attribs.index);
      gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);
      if (divisor > 0) {
        if (model.instancingExtension) {
          model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);
        } else {
          gl.vertexAttribDivisor(attribs.index, 1);
        }
      }
      attribs.buffer = buffer.getHandle();

      // If vertex array objects are not supported then build up our list.
      if (!model.supported) {
        // find the buffer
        let buffFound = false;
        for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
          const buff = model.buffers[ibuff];
          if (buff.buffer === attribs.buffer) {
            buffFound = true;
            let found = false;
            for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
              const attrIt = buff.attributes[iatt];
              if (attrIt.name === name) {
                found = true;
                buff.attributes[iatt] = attribs;
              }
            }
            if (!found) {
              buff.attributes.push(attribs);
            }
          }
        }
        if (!buffFound) {
          model.buffers.push({
            buffer: attribs.buffer,
            attributes: [attribs]
          });
        }
      }
      return true;
    };
    publicAPI.addAttributeMatrixWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor) => {
      // bind the first row of values
      const result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, true);
      if (!result) {
        return result;
      }
      const gl = model.context;
      const index = gl.getAttribLocation(model.handleProgram, name);
      for (let i = 1; i < elementTupleSize; i++) {
        gl.enableVertexAttribArray(index + i);
        gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize, stride, offset + stride * i / elementTupleSize);
        if (divisor > 0) {
          if (model.instancingExtension) {
            model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);
          } else {
            gl.vertexAttribDivisor(index + i, 1);
          }
        }
      }
      return true;
    };
    publicAPI.removeAttributeArray = name => {
      if (!publicAPI.isReady() || model.handleProgram === 0) {
        return false;
      }

      // If we don't have real VAOs find the entry and remove it too.
      if (!model.supported) {
        for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
          const buff = model.buffers[ibuff];
          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
            const attrIt = buff.attributes[iatt];
            if (attrIt.name === name) {
              buff.attributes.splice(iatt, 1);
              if (!buff.attributes.length) {
                model.buffers.splice(ibuff, 1);
              }
              return true;
            }
          }
        }
      }
      return true;
    };
    publicAPI.setOpenGLRenderWindow = rw => {
      if (model._openGLRenderWindow === rw) {
        return;
      }
      publicAPI.releaseGraphicsResources();
      model._openGLRenderWindow = rw;
      model.context = null;
      if (rw) {
        model.context = model._openGLRenderWindow.getContext();
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$14 = {
    forceEmulation: false,
    handleVAO: 0,
    handleProgram: 0,
    supported: true,
    buffers: null,
    context: null
    // _openGLRenderWindow: null,
  };

  // ----------------------------------------------------------------------------

  function extend$16(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$14, initialValues);

    // Internal objects initialization
    model.buffers = [];

    // Object methods
    macro.obj(publicAPI, model);

    // Create get-only macros
    macro.get(publicAPI, model, ['supported']);

    // Create get-set macros
    macro.setGet(publicAPI, model, ['forceEmulation']);

    // For more macro methods, see "Sources/macros.js"

    // Object specific methods
    vtkOpenGLVertexArrayObject(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$16 = macro.newInstance(extend$16, 'vtkOpenGLVertexArrayObject');

  // ----------------------------------------------------------------------------

  var vtkVertexArrayObject = {
    newInstance: newInstance$16,
    extend: extend$16
  };

  const primTypes$2 = {
    Start: 0,
    Points: 0,
    Lines: 1,
    Tris: 2,
    TriStrips: 3,
    TrisEdges: 4,
    TriStripsEdges: 5,
    End: 6
  };

  // ----------------------------------------------------------------------------
  // vtkOpenGLHelper methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLHelper(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLHelper');
    publicAPI.setOpenGLRenderWindow = win => {
      model.context = win.getContext();
      model.program.setContext(model.context);
      model.VAO.setOpenGLRenderWindow(win);
      model.CABO.setOpenGLRenderWindow(win);
    };
    publicAPI.releaseGraphicsResources = oglwin => {
      model.VAO.releaseGraphicsResources();
      model.CABO.releaseGraphicsResources();
      model.CABO.setElementCount(0);
    };
    publicAPI.drawArrays = (ren, actor, rep, oglMapper) => {
      // Are there any entries
      if (model.CABO.getElementCount()) {
        // are we drawing edges
        const mode = publicAPI.getOpenGLMode(rep);
        const wideLines = publicAPI.haveWideLines(ren, actor);
        const gl = model.context;
        const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
        if (model.pointPicking) {
          gl.depthMask(false);
        }
        const drawingLines = mode === gl.LINES;
        if (drawingLines && wideLines) {
          publicAPI.updateShaders(ren, actor, oglMapper);
          gl.drawArraysInstanced(mode, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));
        } else {
          gl.lineWidth(actor.getProperty().getLineWidth());
          publicAPI.updateShaders(ren, actor, oglMapper);
          gl.drawArrays(mode, 0, model.CABO.getElementCount());
          // reset the line width
          gl.lineWidth(1);
        }
        const stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);
        if (model.pointPicking) {
          gl.depthMask(depthMask);
        }
        return model.CABO.getElementCount() / stride;
      }
      return 0;
    };
    publicAPI.getOpenGLMode = rep => {
      if (model.pointPicking) {
        return model.context.POINTS;
      }
      const type = model.primitiveType;
      if (rep === Representation$6.POINTS || type === primTypes$2.Points) {
        return model.context.POINTS;
      }
      if (rep === Representation$6.WIREFRAME || type === primTypes$2.Lines || type === primTypes$2.TrisEdges || type === primTypes$2.TriStripsEdges) {
        return model.context.LINES;
      }
      return model.context.TRIANGLES;
    };
    publicAPI.haveWideLines = (ren, actor) => {
      if (actor.getProperty().getLineWidth() > 1.0) {
        // we have wide lines, but the OpenGL implementation may
        // actually support them, check the range to see if we
        // really need have to implement our own wide lines
        if (model.CABO.getOpenGLRenderWindow()) {
          if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {
            return false;
          }
        }
        return true;
      }
      return false;
    };
    publicAPI.getNeedToRebuildShaders = (ren, actor, oglMapper) => {
      // has something changed that would require us to recreate the shader?
      // candidates are
      // property modified (representation interpolation and lighting)
      // input modified
      // mapper modified (lighting complexity)
      if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {
        return true;
      }
      return false;
    };
    publicAPI.updateShaders = (ren, actor, oglMapper) => {
      // has something changed that would require us to recreate the shader?
      if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {
        const shaders = {
          Vertex: null,
          Fragment: null,
          Geometry: null
        };
        oglMapper.buildShaders(shaders, ren, actor);

        // compile and bind the program if needed
        const newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);

        // if the shader changed reinitialize the VAO
        if (newShader !== publicAPI.getProgram()) {
          publicAPI.setProgram(newShader);
          // reset the VAO as the shader has changed
          publicAPI.getVAO().releaseGraphicsResources();
        }
        publicAPI.getShaderSourceTime().modified();
      } else {
        model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());
      }
      publicAPI.getVAO().bind();
      oglMapper.setMapperShaderParameters(publicAPI, ren, actor);
      oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);
      oglMapper.setCameraShaderParameters(publicAPI, ren, actor);
      oglMapper.setLightingShaderParameters(publicAPI, ren, actor);
      oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);
    };
    publicAPI.setMapperShaderParameters = (ren, actor, size) => {
      if (publicAPI.haveWideLines(ren, actor)) {
        publicAPI.getProgram().setUniform2f('viewportSize', size.usize, size.vsize);
        const lineWidth = parseFloat(actor.getProperty().getLineWidth());
        const halfLineWidth = lineWidth / 2.0;
        publicAPI.getProgram().setUniformf('lineWidthStepSize', lineWidth / Math.ceil(lineWidth));
        publicAPI.getProgram().setUniformf('halfLineWidth', halfLineWidth);
      }
      if (model.primitiveType === primTypes$2.Points || actor.getProperty().getRepresentation() === Representation$6.POINTS) {
        publicAPI.getProgram().setUniformf('pointSize', actor.getProperty().getPointSize());
      } else if (model.pointPicking) {
        publicAPI.getProgram().setUniformf('pointSize', publicAPI.getPointPickingPrimitiveSize());
      }
    };
    publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
      let VSSource = shaders.Vertex;

      // Always set point size in case we need picking
      VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform float pointSize;']).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', '  gl_PointSize = pointSize;'], false).result;

      // for lines, make sure we add the width code
      if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform vec2 viewportSize;', 'uniform float lineWidthStepSize;', 'uniform float halfLineWidth;']).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', ' if (halfLineWidth > 0.0)', '   {', '   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;', '   vec4 tmpPos = gl_Position;', '   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;', '   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];', '   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];', '   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '   }']).result;
      }
      shaders.Vertex = VSSource;
    };
    publicAPI.getPointPickingPrimitiveSize = () => {
      if (model.primitiveType === primTypes$2.Points) {
        return 2;
      }
      if (model.primitiveType === primTypes$2.Lines) {
        return 4;
      }
      return 6;
    };
    publicAPI.getAllocatedGPUMemoryInBytes = () => publicAPI.getCABO().getAllocatedGPUMemoryInBytes();
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$13 = {
    context: null,
    program: null,
    shaderSourceTime: null,
    VAO: null,
    attributeUpdateTime: null,
    CABO: null,
    primitiveType: 0,
    pointPicking: false
  };

  // ----------------------------------------------------------------------------

  function extend$15(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$13, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    model.shaderSourceTime = {};
    macro.obj(model.shaderSourceTime);
    model.attributeUpdateTime = {};
    macro.obj(model.attributeUpdateTime);
    macro.setGet(publicAPI, model, ['program', 'shaderSourceTime', 'VAO', 'attributeUpdateTime', 'CABO', 'primitiveType', 'pointPicking']);
    model.program = vtkShaderProgram$1.newInstance();
    model.VAO = vtkVertexArrayObject.newInstance();
    model.CABO = vtkCellArrayBufferObject.newInstance();

    // Object methods
    vtkOpenGLHelper(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$15 = macro.newInstance(extend$15);

  // ----------------------------------------------------------------------------

  var vtkHelper = {
    newInstance: newInstance$15,
    extend: extend$15,
    primTypes: primTypes$2
  };

  const Wrap$2 = {
    CLAMP_TO_EDGE: 0,
    REPEAT: 1,
    MIRRORED_REPEAT: 2
  };
  const Filter$2 = {
    NEAREST: 0,
    LINEAR: 1,
    NEAREST_MIPMAP_NEAREST: 2,
    NEAREST_MIPMAP_LINEAR: 3,
    LINEAR_MIPMAP_NEAREST: 4,
    LINEAR_MIPMAP_LINEAR: 5
  };
  var Constants$4 = {
    Wrap: Wrap$2,
    Filter: Filter$2
  };

  /* eslint-disable no-bitwise */

  const floatView = new Float32Array(1);
  const int32View = new Int32Array(floatView.buffer);

  /* eslint-disable no-bitwise */
  /* This method is faster than the OpenEXR implementation (very often
   * used, eg. in Ogre), with the additional benefit of rounding, inspired
   * by James Tursa?s half-precision code. */
  function toHalf$1(val) {
    floatView[0] = val;
    const x = int32View[0];
    let bits = x >> 16 & 0x8000; /* Get the sign */
    let m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */
    const e = x >> 23 & 0xff; /* Using int is faster here */

    /* If zero, or denormal, or exponent underflows too much for a denormal
     * half, return signed zero. */
    if (e < 103) {
      return bits;
    }

    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
    if (e > 142) {
      bits |= 0x7c00;
      /* If exponent was 0xff and one mantissa bit was set, it means NaN,
       * not Inf, so make sure we set one mantissa bit too. */
      bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;
      return bits;
    }

    /* If exponent underflows but not too much, return a denormal */
    if (e < 113) {
      m |= 0x0800;
      /* Extra rounding may overflow and set mantissa to 0 and exponent
       * to 1, which is OK. */
      bits |= (m >> 114 - e) + (m >> 113 - e & 1);
      return bits;
    }
    bits |= e - 112 << 10 | m >> 1;
    /* Extra rounding. An overflow will set mantissa to 0 and increment
     * the exponent, which is OK. */
    bits += m & 1;
    return bits;
  }
  function fromHalf(h) {
    const s = (h & 0x8000) >> 15;
    const e = (h & 0x7c00) >> 10;
    const f = h & 0x03ff;
    if (e === 0) {
      return (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);
    }
    if (e === 0x1f) {
      return f ? NaN : (s ? -1 : 1) * Infinity;
    }
    return (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);
  }
  var HalfFloat = {
    fromHalf,
    toHalf: toHalf$1
  };

  const {
    Wrap: Wrap$1,
    Filter: Filter$1
  } = Constants$4;
  const {
    VtkDataTypes: VtkDataTypes$2
  } = vtkDataArray$1;
  const {
    vtkDebugMacro: vtkDebugMacro$6,
    vtkErrorMacro: vtkErrorMacro$j,
    vtkWarningMacro: vtkWarningMacro$2
  } = macro$1;
  const {
    toHalf
  } = HalfFloat;

  // ----------------------------------------------------------------------------
  // vtkOpenGLTexture methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLTexture(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLTexture');
    // Renders myself
    publicAPI.render = function () {
      let renWin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (renWin) {
        model._openGLRenderWindow = renWin;
      } else {
        model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
        // sync renderable properties
        model._openGLRenderWindow = model._openGLRenderer.getParent();
      }
      model.context = model._openGLRenderWindow.getContext();
      if (model.renderable.getInterpolate()) {
        if (model.generateMipmap) {
          publicAPI.setMinificationFilter(Filter$1.LINEAR_MIPMAP_LINEAR);
        } else {
          publicAPI.setMinificationFilter(Filter$1.LINEAR);
        }
        publicAPI.setMagnificationFilter(Filter$1.LINEAR);
      } else {
        publicAPI.setMinificationFilter(Filter$1.NEAREST);
        publicAPI.setMagnificationFilter(Filter$1.NEAREST);
      }
      if (model.renderable.getRepeat()) {
        publicAPI.setWrapR(Wrap$1.REPEAT);
        publicAPI.setWrapS(Wrap$1.REPEAT);
        publicAPI.setWrapT(Wrap$1.REPEAT);
      }
      // clear image if input data is set
      if (model.renderable.getInputData()) {
        model.renderable.setImage(null);
      }
      // create the texture if it is not done already
      if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {
        // if we have an Image
        if (model.renderable.getImage() !== null) {
          if (model.renderable.getInterpolate()) {
            model.generateMipmap = true;
            publicAPI.setMinificationFilter(Filter$1.LINEAR_MIPMAP_LINEAR);
          }
          // Have an Image which may not be complete
          if (model.renderable.getImage() && model.renderable.getImageLoaded()) {
            publicAPI.create2DFromImage(model.renderable.getImage());
            publicAPI.activate();
            publicAPI.sendParameters();
            model.textureBuildTime.modified();
          }
        }
        // if we have a canvas
        if (model.renderable.getCanvas() !== null) {
          if (model.renderable.getInterpolate()) {
            model.generateMipmap = true;
            publicAPI.setMinificationFilter(Filter$1.LINEAR_MIPMAP_LINEAR);
          }
          const canvas = model.renderable.getCanvas();
          publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes$2.UNSIGNED_CHAR, canvas, true);
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
        // if we have jsImageData
        if (model.renderable.getJsImageData() !== null) {
          const jsid = model.renderable.getJsImageData();
          if (model.renderable.getInterpolate()) {
            model.generateMipmap = true;
            publicAPI.setMinificationFilter(Filter$1.LINEAR_MIPMAP_LINEAR);
          }
          publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes$2.UNSIGNED_CHAR, jsid.data, true);
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
        // if we have InputData
        const input = model.renderable.getInputData(0);
        if (input && input.getPointData().getScalars()) {
          const ext = input.getExtent();
          const inScalars = input.getPointData().getScalars();

          // do we have a cube map? Six inputs
          const data = [];
          for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {
            const indata = model.renderable.getInputData(i);
            const scalars = indata ? indata.getPointData().getScalars().getData() : null;
            if (scalars) {
              data.push(scalars);
            }
          }
          if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {
            model.generateMipmap = true;
            publicAPI.setMinificationFilter(Filter$1.LINEAR_MIPMAP_LINEAR);
          }
          if (data.length % 6 === 0) {
            publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);
          } else {
            publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());
          }
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
      }
      if (model.handle) {
        publicAPI.activate();
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.destroyTexture = () => {
      // deactivate it first
      publicAPI.deactivate();
      if (model.context && model.handle) {
        model.context.deleteTexture(model.handle);
      }
      model.handle = 0;
      model.numberOfDimensions = 0;
      model.target = 0;
      model.components = 0;
      model.width = 0;
      model.height = 0;
      model.depth = 0;
      publicAPI.resetFormatAndType();
    };

    //----------------------------------------------------------------------------
    publicAPI.createTexture = () => {
      // reuse the existing handle if we have one
      if (!model.handle) {
        model.handle = model.context.createTexture();
        if (model.target) {
          model.context.bindTexture(model.target, model.handle);

          // See: http://www.openmodel.context..org/wiki/Common_Mistakes#Creating_a_complete_texture
          // turn off mip map filter or set the base and max level correctly. here
          // both are done.
          model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
          model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
          if (model._openGLRenderWindow.getWebgl2()) {
            model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
          }
          model.context.bindTexture(model.target, null);
        }
      }
    };

    //---------------------------------------------------------------------------
    publicAPI.getTextureUnit = () => {
      if (model._openGLRenderWindow) {
        return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);
      }
      return -1;
    };

    //---------------------------------------------------------------------------
    publicAPI.activate = () => {
      // activate a free texture unit for this texture
      model._openGLRenderWindow.activateTexture(publicAPI);
      publicAPI.bind();
    };

    //---------------------------------------------------------------------------
    publicAPI.deactivate = () => {
      if (model._openGLRenderWindow) {
        model._openGLRenderWindow.deactivateTexture(publicAPI);
      }
    };

    //---------------------------------------------------------------------------
    publicAPI.releaseGraphicsResources = rwin => {
      if (rwin && model.handle) {
        rwin.activateTexture(publicAPI);
        rwin.deactivateTexture(publicAPI);
        model.context.deleteTexture(model.handle);
        model.handle = 0;
        model.numberOfDimensions = 0;
        model.target = 0;
        model.internalFormat = 0;
        model.format = 0;
        model.openGLDataType = 0;
        model.components = 0;
        model.width = 0;
        model.height = 0;
        model.depth = 0;
        model.allocatedGPUMemoryInBytes = 0;
      }
      if (model.shaderProgram) {
        model.shaderProgram.releaseGraphicsResources(rwin);
        model.shaderProgram = null;
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.bind = () => {
      model.context.bindTexture(model.target, model.handle);
      if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {
        publicAPI.sendParameters();
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.isBound = () => {
      let result = false;
      if (model.context && model.handle) {
        let target = 0;
        switch (model.target) {
          case model.context.TEXTURE_2D:
            target = model.context.TEXTURE_BINDING_2D;
            break;
          default:
            vtkWarningMacro$2('impossible case');
            break;
        }
        const oid = model.context.getIntegerv(target);
        result = oid === model.handle;
      }
      return result;
    };

    //----------------------------------------------------------------------------
    publicAPI.sendParameters = () => {
      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
      if (model._openGLRenderWindow.getWebgl2()) {
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
      }
      model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
      model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
      if (model._openGLRenderWindow.getWebgl2()) {
        model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);
        model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);
      }

      // model.context.texParameterf(model.target, model.context.TEXTURE_MIN_LOD, model.minLOD);
      // model.context.texParameterf(model.target, model.context.TEXTURE_MAX_LOD, model.maxLOD);

      model.sendParametersTime.modified();
    };

    //----------------------------------------------------------------------------
    publicAPI.getInternalFormat = (vtktype, numComps) => {
      if (!model._forceInternalFormat) {
        model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);
      }
      if (!model.internalFormat) {
        vtkDebugMacro$6(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
      }
      if ([model.context.R32F, model.context.RG32F, model.context.RGB32F, model.context.RGBA32F].includes(model.internalFormat) && !model.context.getExtension('OES_texture_float_linear')) {
        vtkWarningMacro$2('Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats.');
      }
      return model.internalFormat;
    };

    //----------------------------------------------------------------------------
    publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {
      let result = 0;
      // try default next
      result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, model.oglNorm16Ext, model.useHalfFloat);
      if (result) {
        return result;
      }
      if (!result) {
        vtkDebugMacro$6('Unsupported internal texture type!');
        vtkDebugMacro$6(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
      }
      return result;
    };

    //----------------------------------------------------------------------------
    publicAPI.setInternalFormat = iFormat => {
      model._forceInternalFormat = true;
      if (iFormat !== model.internalFormat) {
        model.internalFormat = iFormat;
        publicAPI.modified();
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.getFormat = (vtktype, numComps) => {
      model.format = publicAPI.getDefaultFormat(vtktype, numComps);
      return model.format;
    };

    //----------------------------------------------------------------------------
    publicAPI.getDefaultFormat = (vtktype, numComps) => {
      if (model._openGLRenderWindow.getWebgl2()) {
        switch (numComps) {
          case 1:
            return model.context.RED;
          case 2:
            return model.context.RG;
          case 3:
            return model.context.RGB;
          case 4:
            return model.context.RGBA;
          default:
            return model.context.RGB;
        }
      } else {
        // webgl1
        switch (numComps) {
          case 1:
            return model.context.LUMINANCE;
          case 2:
            return model.context.LUMINANCE_ALPHA;
          case 3:
            return model.context.RGB;
          case 4:
            return model.context.RGBA;
          default:
            return model.context.RGB;
        }
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.resetFormatAndType = () => {
      model.format = 0;
      model.internalFormat = 0;
      model._forceInternalFormat = false;
      model.openGLDataType = 0;
    };

    //----------------------------------------------------------------------------
    publicAPI.getDefaultDataType = vtkScalarType => {
      // DON'T DEAL with VTK_CHAR as this is platform dependent.
      if (model._openGLRenderWindow.getWebgl2()) {
        switch (vtkScalarType) {
          // case VtkDataTypes.SIGNED_CHAR:
          //   return model.context.BYTE;
          case VtkDataTypes$2.UNSIGNED_CHAR:
            return model.context.UNSIGNED_BYTE;
          // prefer norm16 since that is accurate compared to
          // half float which is not
          case model.oglNorm16Ext && !model.useHalfFloat && VtkDataTypes$2.SHORT:
            return model.context.SHORT;
          case model.oglNorm16Ext && !model.useHalfFloat && VtkDataTypes$2.UNSIGNED_SHORT:
            return model.context.UNSIGNED_SHORT;
          // use half float type
          case model.useHalfFloat && VtkDataTypes$2.SHORT:
            return model.context.HALF_FLOAT;
          case model.useHalfFloat && VtkDataTypes$2.UNSIGNED_SHORT:
            return model.context.HALF_FLOAT;
          // case VtkDataTypes.INT:
          //   return model.context.INT;
          // case VtkDataTypes.UNSIGNED_INT:
          //   return model.context.UNSIGNED_INT;
          case VtkDataTypes$2.FLOAT:
          case VtkDataTypes$2.VOID: // used for depth component textures.
          default:
            return model.context.FLOAT;
        }
      }
      switch (vtkScalarType) {
        // case VtkDataTypes.SIGNED_CHAR:
        //   return model.context.BYTE;
        case VtkDataTypes$2.UNSIGNED_CHAR:
          return model.context.UNSIGNED_BYTE;
        // case VtkDataTypes.SHORT:
        //   return model.context.SHORT;
        // case VtkDataTypes.UNSIGNED_SHORT:
        //   return model.context.UNSIGNED_SHORT;
        // case VtkDataTypes.INT:
        //   return model.context.INT;
        // case VtkDataTypes.UNSIGNED_INT:
        //   return model.context.UNSIGNED_INT;
        case VtkDataTypes$2.FLOAT:
        case VtkDataTypes$2.VOID: // used for depth component textures.
        default:
          if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {
            return model.context.FLOAT;
          }
          {
            const halfFloat = model.context.getExtension('OES_texture_half_float');
            if (halfFloat && model.context.getExtension('OES_texture_half_float_linear')) {
              return halfFloat.HALF_FLOAT_OES;
            }
          }
          return model.context.UNSIGNED_BYTE;
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.getOpenGLDataType = function (vtkScalarType) {
      let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (!model.openGLDataType || forceUpdate) {
        model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);
      }
      return model.openGLDataType;
    };
    publicAPI.getShiftAndScale = () => {
      let shift = 0.0;
      let scale = 1.0;

      // for all float type internal formats
      switch (model.openGLDataType) {
        case model.context.BYTE:
          scale = 127.5;
          shift = scale - 128.0;
          break;
        case model.context.UNSIGNED_BYTE:
          scale = 255.0;
          shift = 0.0;
          break;
        case model.context.SHORT:
          scale = 32767.5;
          shift = scale - 32768.0;
          break;
        case model.context.UNSIGNED_SHORT:
          scale = 65536.0;
          shift = 0.0;
          break;
        case model.context.INT:
          scale = 2147483647.5;
          shift = scale - 2147483648.0;
          break;
        case model.context.UNSIGNED_INT:
          scale = 4294967295.0;
          shift = 0.0;
          break;
        case model.context.FLOAT:
      }
      return {
        shift,
        scale
      };
    };

    //----------------------------------------------------------------------------
    publicAPI.getOpenGLFilterMode = emode => {
      switch (emode) {
        case Filter$1.NEAREST:
          return model.context.NEAREST;
        case Filter$1.LINEAR:
          return model.context.LINEAR;
        case Filter$1.NEAREST_MIPMAP_NEAREST:
          return model.context.NEAREST_MIPMAP_NEAREST;
        case Filter$1.NEAREST_MIPMAP_LINEAR:
          return model.context.NEAREST_MIPMAP_LINEAR;
        case Filter$1.LINEAR_MIPMAP_NEAREST:
          return model.context.LINEAR_MIPMAP_NEAREST;
        case Filter$1.LINEAR_MIPMAP_LINEAR:
          return model.context.LINEAR_MIPMAP_LINEAR;
        default:
          return model.context.NEAREST;
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.getOpenGLWrapMode = vtktype => {
      switch (vtktype) {
        case Wrap$1.CLAMP_TO_EDGE:
          return model.context.CLAMP_TO_EDGE;
        case Wrap$1.REPEAT:
          return model.context.REPEAT;
        case Wrap$1.MIRRORED_REPEAT:
          return model.context.MIRRORED_REPEAT;
        default:
          return model.context.CLAMP_TO_EDGE;
      }
    };

    //----------------------------------------------------------------------------
    function updateArrayDataType(dataType, data) {
      let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      const pixData = [];
      let pixCount = model.width * model.height * model.components;
      if (depth) {
        pixCount *= model.depth;
      }

      // if the opengl data type is float
      // then the data array must be float
      if (dataType !== VtkDataTypes$2.FLOAT && model.openGLDataType === model.context.FLOAT) {
        for (let idx = 0; idx < data.length; idx++) {
          if (data[idx]) {
            const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
            pixData.push(new Float32Array(dataArrayToCopy));
          } else {
            pixData.push(null);
          }
        }
      }

      // if the opengl data type is ubyte
      // then the data array must be u8, we currently simply truncate the data
      if (dataType !== VtkDataTypes$2.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {
        for (let idx = 0; idx < data.length; idx++) {
          if (data[idx]) {
            const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
            pixData.push(new Uint8Array(dataArrayToCopy));
          } else {
            pixData.push(null);
          }
        }
      }

      // if the opengl data type is half float
      // then the data array must be u16
      let halfFloat = false;
      if (model._openGLRenderWindow.getWebgl2()) {
        halfFloat = model.openGLDataType === model.context.HALF_FLOAT;
      } else {
        const halfFloatExt = model.context.getExtension('OES_texture_half_float');
        halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
      }
      if (halfFloat) {
        for (let idx = 0; idx < data.length; idx++) {
          if (data[idx]) {
            const newArray = new Uint16Array(pixCount);
            const src = data[idx];
            for (let i = 0; i < pixCount; i++) {
              newArray[i] = toHalf(src[i]);
            }
            pixData.push(newArray);
          } else {
            pixData.push(null);
          }
        }
      }

      // The output has to be filled
      if (pixData.length === 0) {
        for (let i = 0; i < data.length; i++) {
          pixData.push(data[i]);
        }
      }
      return pixData;
    }

    //----------------------------------------------------------------------------
    function scaleTextureToHighestPowerOfTwo(data) {
      if (model._openGLRenderWindow.getWebgl2()) {
        // No need if webGL2
        return data;
      }
      const pixData = [];
      const width = model.width;
      const height = model.height;
      const numComps = model.components;
      if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {
        // Scale up the texture to the next highest power of two dimensions.
        const halfFloat = model.context.getExtension('OES_texture_half_float');
        const newWidth = nearestPowerOfTwo(width);
        const newHeight = nearestPowerOfTwo(height);
        const pixCount = newWidth * newHeight * model.components;
        for (let idx = 0; idx < data.length; idx++) {
          if (data[idx] !== null) {
            let newArray = null;
            const jFactor = height / newHeight;
            const iFactor = width / newWidth;
            let usingHalf = false;
            if (model.openGLDataType === model.context.FLOAT) {
              newArray = new Float32Array(pixCount);
            } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {
              newArray = new Uint16Array(pixCount);
              usingHalf = true;
            } else {
              newArray = new Uint8Array(pixCount);
            }
            for (let j = 0; j < newHeight; j++) {
              const joff = j * newWidth * numComps;
              const jidx = j * jFactor;
              let jlow = Math.floor(jidx);
              let jhi = Math.ceil(jidx);
              if (jhi >= height) {
                jhi = height - 1;
              }
              const jmix = jidx - jlow;
              const jmix1 = 1.0 - jmix;
              jlow = jlow * width * numComps;
              jhi = jhi * width * numComps;
              for (let i = 0; i < newWidth; i++) {
                const ioff = i * numComps;
                const iidx = i * iFactor;
                let ilow = Math.floor(iidx);
                let ihi = Math.ceil(iidx);
                if (ihi >= width) {
                  ihi = width - 1;
                }
                const imix = iidx - ilow;
                ilow *= numComps;
                ihi *= numComps;
                for (let c = 0; c < numComps; c++) {
                  if (usingHalf) {
                    newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);
                  } else {
                    newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1.0 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1.0 - imix) + data[idx][jhi + ihi + c] * jmix * imix;
                  }
                }
              }
            }
            pixData.push(newArray);
            model.width = newWidth;
            model.height = newHeight;
          } else {
            pixData.push(null);
          }
        }
      }

      // The output has to be filled
      if (pixData.length === 0) {
        for (let i = 0; i < data.length; i++) {
          pixData.push(data[i]);
        }
      }
      return pixData;
    }

    //----------------------------------------------------------------------------
    function useTexStorage(dataType) {
      if (model._openGLRenderWindow) {
        if (model.resizable || model.renderable?.getResizable()) {
          // Cannot use texStorage if the texture is supposed to be resizable.
          return false;
        }
        if (model._openGLRenderWindow.getWebgl2()) {
          const webGLInfo = model._openGLRenderWindow.getGLInformations();
          if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && model.oglNorm16Ext && (dataType === VtkDataTypes$2.UNSIGNED_SHORT || dataType === VtkDataTypes$2.SHORT)) {
            // Cannot use texStorage with EXT_texture_norm16 textures on Mac M1 GPU.
            // No errors reported but the texture is unusable.
            return false;
          }
          // Use texStorage for WebGL2
          return true;
        }
        return false;
      }
      return false;
    }

    //----------------------------------------------------------------------------
    publicAPI.create2DFromRaw = function (width, height, numComps, dataType, data) {
      let flip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      // Now determine the texture parameters using the arguments.
      publicAPI.getOpenGLDataType(dataType, true);
      publicAPI.getInternalFormat(dataType, numComps);
      publicAPI.getFormat(dataType, numComps);
      if (!model.internalFormat || !model.format || !model.openGLDataType) {
        vtkErrorMacro$j('Failed to determine texture parameters.');
        return false;
      }
      model.target = model.context.TEXTURE_2D;
      model.components = numComps;
      model.width = width;
      model.height = height;
      model.depth = 1;
      model.numberOfDimensions = 2;
      model._openGLRenderWindow.activateTexture(publicAPI);
      publicAPI.createTexture();
      publicAPI.bind();

      // Create an array of texture with one texture
      const dataArray = [data];
      const pixData = updateArrayDataType(dataType, dataArray);
      const scaledData = scaleTextureToHighestPowerOfTwo(pixData);

      // Source texture data from the PBO.
      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);
      model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
      if (useTexStorage(dataType)) {
        model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
        if (scaledData[0] != null) {
          model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);
        }
      } else {
        model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);
      }
      if (model.generateMipmap) {
        model.context.generateMipmap(model.target);
      }

      // always reset the flip
      if (flip) {
        model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);
      }
      model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);
      publicAPI.deactivate();
      return true;
    };

    //----------------------------------------------------------------------------
    publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {
      // Now determine the texture parameters using the arguments.
      publicAPI.getOpenGLDataType(dataType);
      publicAPI.getInternalFormat(dataType, numComps);
      publicAPI.getFormat(dataType, numComps);
      if (!model.internalFormat || !model.format || !model.openGLDataType) {
        vtkErrorMacro$j('Failed to determine texture parameters.');
        return false;
      }
      model.target = model.context.TEXTURE_CUBE_MAP;
      model.components = numComps;
      model.width = width;
      model.height = height;
      model.depth = 1;
      model.numberOfDimensions = 2;
      model._openGLRenderWindow.activateTexture(publicAPI);
      model.maxLevel = data.length / 6 - 1;
      publicAPI.createTexture();
      publicAPI.bind();
      const pixData = updateArrayDataType(dataType, data);
      const scaledData = scaleTextureToHighestPowerOfTwo(pixData);

      // invert the data because opengl is messed up with cube maps
      // and uses the old renderman standard with Y going down
      // even though it is completely at odds with OpenGL standards
      const invertedData = [];
      let widthLevel = model.width;
      let heightLevel = model.height;
      for (let i = 0; i < scaledData.length; i++) {
        if (i % 6 === 0 && i !== 0) {
          widthLevel /= 2;
          heightLevel /= 2;
        }
        invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);
        for (let y = 0; y < heightLevel; ++y) {
          const row1 = y * widthLevel * model.components;
          const row2 = (heightLevel - y - 1) * widthLevel * model.components;
          invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);
        }
      }

      // Source texture data from the PBO.
      model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
      if (useTexStorage(dataType)) {
        model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);
      }
      // We get the 6 images
      for (let i = 0; i < 6; i++) {
        // For each mipmap level
        let j = 0;
        let w = model.width;
        let h = model.height;
        while (w >= 1 && h >= 1) {
          // In webgl 1, all levels need to be defined. So if the latest level size is
          // 8x8, we have to add 3 more null textures (4x4, 2x2, 1x1)
          // In webgl 2, the attribute maxLevel will be use.
          let tempData = null;
          if (j <= model.maxLevel) {
            tempData = invertedData[6 * j + i];
          }
          if (useTexStorage(dataType)) {
            if (tempData != null) {
              model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, w, h, model.format, model.openGLDataType, tempData);
            }
          } else {
            model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);
          }
          j++;
          w /= 2;
          h /= 2;
        }
      }
      model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);
      // generateMipmap must not be called here because we manually upload all levels
      // if it is called, all levels will be overwritten

      publicAPI.deactivate();
      return true;
    };

    //----------------------------------------------------------------------------
    publicAPI.createDepthFromRaw = (width, height, dataType, data) => {
      // Now determine the texture parameters using the arguments.
      publicAPI.getOpenGLDataType(dataType);
      model.format = model.context.DEPTH_COMPONENT;
      if (model._openGLRenderWindow.getWebgl2()) {
        if (dataType === VtkDataTypes$2.FLOAT) {
          model.internalFormat = model.context.DEPTH_COMPONENT32F;
        } else {
          model.internalFormat = model.context.DEPTH_COMPONENT16;
        }
      } else {
        model.internalFormat = model.context.DEPTH_COMPONENT;
      }
      if (!model.internalFormat || !model.format || !model.openGLDataType) {
        vtkErrorMacro$j('Failed to determine texture parameters.');
        return false;
      }
      model.target = model.context.TEXTURE_2D;
      model.components = 1;
      model.width = width;
      model.height = height;
      model.depth = 1;
      model.numberOfDimensions = 2;
      model._openGLRenderWindow.activateTexture(publicAPI);
      publicAPI.createTexture();
      publicAPI.bind();

      // Source texture data from the PBO.
      // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
      if (useTexStorage(dataType)) {
        model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
        if (data != null) {
          model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);
        }
      } else {
        model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);
      }
      if (model.generateMipmap) {
        model.context.generateMipmap(model.target);
      }
      model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);
      publicAPI.deactivate();
      return true;
    };

    //----------------------------------------------------------------------------
    publicAPI.create2DFromImage = image => {
      // Now determine the texture parameters using the arguments.
      publicAPI.getOpenGLDataType(VtkDataTypes$2.UNSIGNED_CHAR);
      publicAPI.getInternalFormat(VtkDataTypes$2.UNSIGNED_CHAR, 4);
      publicAPI.getFormat(VtkDataTypes$2.UNSIGNED_CHAR, 4);
      if (!model.internalFormat || !model.format || !model.openGLDataType) {
        vtkErrorMacro$j('Failed to determine texture parameters.');
        return false;
      }
      model.target = model.context.TEXTURE_2D;
      model.components = 4;
      model.depth = 1;
      model.numberOfDimensions = 2;
      model._openGLRenderWindow.activateTexture(publicAPI);
      publicAPI.createTexture();
      publicAPI.bind();

      // Source texture data from the PBO.
      // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);

      // Scale up the texture to the next highest power of two dimensions (if needed) and flip y.
      const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height));
      const canvas = document.createElement('canvas');
      canvas.width = needNearestPowerOfTwo ? nearestPowerOfTwo(image.width) : image.width;
      canvas.height = needNearestPowerOfTwo ? nearestPowerOfTwo(image.height) : image.height;
      model.width = canvas.width;
      model.height = canvas.height;
      const ctx = canvas.getContext('2d');
      ctx.translate(0, canvas.height);
      ctx.scale(1, -1);
      ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
      const safeImage = canvas;
      if (useTexStorage(VtkDataTypes$2.UNSIGNED_CHAR)) {
        model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
        if (safeImage != null) {
          model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, safeImage);
        }
      } else {
        model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, safeImage);
      }
      if (model.generateMipmap) {
        model.context.generateMipmap(model.target);
      }
      model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes$2.UNSIGNED_CHAR, model.oglNorm16Ext, model.useHalfFloat);
      publicAPI.deactivate();
      return true;
    };

    // Compute scale and offset per component from min and max per component
    function computeScaleOffsets(min, max, numComps) {
      const offset = new Array(numComps);
      const scale = new Array(numComps);
      for (let c = 0; c < numComps; ++c) {
        offset[c] = min[c];
        scale[c] = max[c] - min[c] || 1.0;
      }
      return {
        scale,
        offset
      };
    }

    // HalfFloat only represents numbers between [-2048, 2048] exactly accurate,
    // for numbers outside of this range there is a precision limitation
    function hasExactHalfFloat(offset, scale) {
      // Per Component
      for (let c = 0; c < offset.length; c++) {
        const min = offset[c];
        const max = scale[c] + min;
        if (min < -2048 || min > 2048 || max < -2048 || max > 2048) {
          return false;
        }
      }
      return true;
    }
    function setUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {
      publicAPI.getOpenGLDataType(dataType);
      let useHalfFloat = false;
      if (model._openGLRenderWindow.getWebgl2()) {
        useHalfFloat = model.openGLDataType === model.context.HALF_FLOAT;
      } else {
        const halfFloatExt = model.context.getExtension('OES_texture_half_float');
        useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
      }

      // Don't consider halfFloat and convert back to Float when the range of data does not generate an accurate halfFloat
      // AND it is not preferable to have a smaller texture than an exact texture.
      const isHalfFloat = useHalfFloat && (hasExactHalfFloat(offset, scale) || preferSizeOverAccuracy);
      model.useHalfFloat = isHalfFloat;
    }
    function processDataArray(dataArray, preferSizeOverAccuracy) {
      const numComps = dataArray.getNumberOfComponents();
      const dataType = dataArray.getDataType();
      const data = dataArray.getData();

      // Compute min max from array
      // Using the vtkDataArray.getRange() enables caching
      const minArray = new Array(numComps);
      const maxArray = new Array(numComps);
      for (let c = 0; c < numComps; ++c) {
        const [min, max] = dataArray.getRange(c);
        minArray[c] = min;
        maxArray[c] = max;
      }
      const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);

      // preferSizeOverAccuracy will override norm16 due to bug with norm16 implementation
      // https://bugs.chromium.org/p/chromium/issues/detail?id=1408247
      setUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);

      // since our default is to use half float, in case that we can't use it
      // we need to use another type
      if (!model.useHalfFloat) {
        publicAPI.getOpenGLDataType(dataType, true);
      }
      return {
        numComps,
        dataType,
        data,
        scaleOffsets
      };
    }
    publicAPI.create2DFilterableFromRaw = function (width, height, numberOfComponents, dataType, values) {
      let preferSizeOverAccuracy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      return publicAPI.create2DFilterableFromDataArray(width, height, vtkDataArray$1.newInstance({
        numberOfComponents,
        dataType,
        values
      }), preferSizeOverAccuracy);
    };
    publicAPI.create2DFilterableFromDataArray = function (width, height, dataArray) {
      let preferSizeOverAccuracy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      const {
        numComps,
        dataType,
        data
      } = processDataArray(dataArray, preferSizeOverAccuracy);
      publicAPI.create2DFromRaw(width, height, numComps, dataType, data);
    };
    //----------------------------------------------------------------------------
    publicAPI.create3DFromRaw = (width, height, depth, numComps, dataType, data) => {
      // Permit OpenGLDataType to be half float, if applicable, for 3D
      publicAPI.getOpenGLDataType(dataType);

      // Now determine the texture parameters using the arguments.
      publicAPI.getInternalFormat(dataType, numComps);
      publicAPI.getFormat(dataType, numComps);
      if (!model.internalFormat || !model.format || !model.openGLDataType) {
        vtkErrorMacro$j('Failed to determine texture parameters.');
        return false;
      }
      model.target = model.context.TEXTURE_3D;
      model.components = numComps;
      model.width = width;
      model.height = height;
      model.depth = depth;
      model.numberOfDimensions = 3;
      model._openGLRenderWindow.activateTexture(publicAPI);
      publicAPI.createTexture();
      publicAPI.bind();
      // Create an array of texture with one texture
      const dataArray = [data];
      const is3DArray = true;
      const pixData = updateArrayDataType(dataType, dataArray, is3DArray);
      const scaledData = scaleTextureToHighestPowerOfTwo(pixData);

      // Source texture data from the PBO.
      // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);

      // openGLDataType

      if (useTexStorage(dataType)) {
        model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);
        if (scaledData[0] != null) {
          model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);
        }
      } else {
        model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);
      }
      if (model.generateMipmap) {
        model.context.generateMipmap(model.target);
      }
      model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, model.oglNorm16Ext, model.useHalfFloat);
      publicAPI.deactivate();
      return true;
    };

    //----------------------------------------------------------------------------
    // This method simulates a 3D texture using 2D
    // Prefer create3DFilterableFromDataArray to enable caching of min and max values
    publicAPI.create3DFilterableFromRaw = function (width, height, depth, numberOfComponents, dataType, values) {
      let preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      return publicAPI.create3DFilterableFromDataArray(width, height, depth, vtkDataArray$1.newInstance({
        numberOfComponents,
        dataType,
        values
      }), preferSizeOverAccuracy);
    };

    //----------------------------------------------------------------------------
    // This method create a 3D texture from dimensions and a DataArray
    publicAPI.create3DFilterableFromDataArray = function (width, height, depth, dataArray) {
      let preferSizeOverAccuracy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      const {
        numComps,
        dataType,
        data,
        scaleOffsets
      } = processDataArray(dataArray, preferSizeOverAccuracy);
      const numPixelsIn = width * height * depth;
      const offset = [];
      const scale = [];
      for (let c = 0; c < numComps; ++c) {
        offset[c] = 0.0;
        scale[c] = 1.0;
      }

      // store the information, we will need it later
      // offset and scale are the offset and scale required to get
      // the texture value back to data values ala
      // data = texture * scale + offset
      // and texture = (data - offset)/scale
      model.volumeInfo = {
        scale,
        offset,
        dataComputedScale: scaleOffsets.scale,
        dataComputedOffset: scaleOffsets.offset,
        width,
        height,
        depth
      };

      // Create a copy of scale and offset to avoid aliasing issues
      // Original is read only, copy is read/write
      // Use the copy as volumeInfo.scale and volumeInfo.offset
      const scaleOffsetsCopy = structuredClone(scaleOffsets);

      // WebGL2 path, we have 3d textures etc
      if (model._openGLRenderWindow.getWebgl2()) {
        if (model.oglNorm16Ext && !model.useHalfFloat && dataType === VtkDataTypes$2.SHORT) {
          for (let c = 0; c < numComps; ++c) {
            model.volumeInfo.scale[c] = 32767.0;
          }
          return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
        }
        if (model.oglNorm16Ext && !model.useHalfFloat && dataType === VtkDataTypes$2.UNSIGNED_SHORT) {
          for (let c = 0; c < numComps; ++c) {
            model.volumeInfo.scale[c] = 65535.0;
          }
          return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
        }
        if (dataType === VtkDataTypes$2.FLOAT || model.useHalfFloat && (dataType === VtkDataTypes$2.SHORT || dataType === VtkDataTypes$2.UNSIGNED_SHORT)) {
          return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
        }
        if (dataType === VtkDataTypes$2.UNSIGNED_CHAR) {
          for (let c = 0; c < numComps; ++c) {
            model.volumeInfo.scale[c] = 255.0;
          }
          return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
        }
        // otherwise convert to float
        const newArray = new Float32Array(numPixelsIn * numComps);
        // use computed scale and offset
        model.volumeInfo.offset = scaleOffsetsCopy.offset;
        model.volumeInfo.scale = scaleOffsetsCopy.scale;
        let count = 0;
        const scaleInverse = scaleOffsetsCopy.scale.map(s => 1 / s);
        for (let i = 0; i < numPixelsIn; i++) {
          for (let nc = 0; nc < numComps; nc++) {
            newArray[count] = (data[count] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];
            count++;
          }
        }
        return publicAPI.create3DFromRaw(width, height, depth, numComps, VtkDataTypes$2.FLOAT, newArray);
      }

      // not webgl2, deal with webgl1, no 3d textures
      // and maybe no float textures

      let volCopyData = (outArray, outIdx, inValue, smin, smax) => {
        outArray[outIdx] = inValue;
      };
      let dataTypeToUse = VtkDataTypes$2.UNSIGNED_CHAR;
      // unsigned char gets used as is
      if (dataType === VtkDataTypes$2.UNSIGNED_CHAR) {
        for (let c = 0; c < numComps; ++c) {
          scaleOffsetsCopy.offset[c] = 0.0;
          scaleOffsetsCopy.scale[c] = 255.0;
        }
      } else if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {
        // use float textures scaled to 0.0 to 1.0
        dataTypeToUse = VtkDataTypes$2.FLOAT;
        volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {
          outArray[outIdx] = (inValue - soffset) / sscale;
        };
      } else {
        // worst case, scale data to uchar
        dataTypeToUse = VtkDataTypes$2.UNSIGNED_CHAR;
        volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {
          outArray[outIdx] = 255.0 * (inValue - soffset) / sscale;
        };
      }

      // Now determine the texture parameters using the arguments.
      publicAPI.getOpenGLDataType(dataTypeToUse);
      publicAPI.getInternalFormat(dataTypeToUse, numComps);
      publicAPI.getFormat(dataTypeToUse, numComps);
      if (!model.internalFormat || !model.format || !model.openGLDataType) {
        vtkErrorMacro$j('Failed to determine texture parameters.');
        return false;
      }

      // have to pack this 3D texture into pot 2D texture
      model.target = model.context.TEXTURE_2D;
      model.components = numComps;
      model.depth = 1;
      model.numberOfDimensions = 2;

      // MAX_TEXTURE_SIZE gives the max dimensions that can be supported by the GPU,
      // but it doesn't mean it will fit in memory. If we have to use a float data type
      // or 4 components, there are good chances that the texture size will blow up
      // and could not fit in the GPU memory. Use a smaller texture size in that case,
      // which will force a downsampling of the dataset.
      // That problem does not occur when using webGL2 since we can pack the data in
      // denser textures based on our data type.
      // TODO: try to fit in the biggest supported texture, catch the gl error if it
      // does not fix (OUT_OF_MEMORY), then attempt with smaller texture
      let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
      if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes$2.FLOAT || numComps >= 3)) {
        maxTexDim = 4096;
      }

      // compute estimate for XY subsample
      let xstride = 1;
      let ystride = 1;
      if (numPixelsIn > maxTexDim * maxTexDim) {
        xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));
        ystride = xstride;
      }
      let targetWidth = Math.sqrt(numPixelsIn) / xstride;
      targetWidth = nearestPowerOfTwo(targetWidth);
      // determine X reps
      const xreps = Math.floor(targetWidth * xstride / width);
      const yreps = Math.ceil(depth / xreps);
      const targetHeight = nearestPowerOfTwo(height * yreps / ystride);
      model.width = targetWidth;
      model.height = targetHeight;
      model._openGLRenderWindow.activateTexture(publicAPI);
      publicAPI.createTexture();
      publicAPI.bind();

      // store the information, we will need it later
      model.volumeInfo.xreps = xreps;
      model.volumeInfo.yreps = yreps;
      model.volumeInfo.xstride = xstride;
      model.volumeInfo.ystride = ystride;
      model.volumeInfo.offset = scaleOffsetsCopy.offset;
      model.volumeInfo.scale = scaleOffsetsCopy.scale;

      // OK stuff the data into the 2d TEXTURE

      // first allocate the new texture
      let newArray;
      const pixCount = targetWidth * targetHeight * numComps;
      if (dataTypeToUse === VtkDataTypes$2.FLOAT) {
        newArray = new Float32Array(pixCount);
      } else {
        newArray = new Uint8Array(pixCount);
      }

      // then stuff the data into it, nothing fancy right now
      // for stride
      let outIdx = 0;
      const tileWidth = Math.floor(width / xstride);
      const tileHeight = Math.floor(height / ystride);
      for (let yRep = 0; yRep < yreps; yRep++) {
        const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);
        const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));
        for (let tileY = 0; tileY < tileHeight; tileY++) {
          for (let xRep = 0; xRep < xrepsThisRow; xRep++) {
            const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);
            for (let tileX = 0; tileX < tileWidth; tileX++) {
              // copy value
              for (let nc = 0; nc < numComps; nc++) {
                volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);
                outIdx++;
              }
            }
          }
          outIdx += outXContIncr;
        }
      }

      // Source texture data from the PBO.
      // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
      if (useTexStorage(dataTypeToUse)) {
        model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
        if (newArray != null) {
          model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);
        }
      } else {
        model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);
      }
      publicAPI.deactivate();
      return true;
    };
    publicAPI.setOpenGLRenderWindow = rw => {
      if (model._openGLRenderWindow === rw) {
        return;
      }
      publicAPI.releaseGraphicsResources();
      model._openGLRenderWindow = rw;
      model.context = null;
      if (rw) {
        model.context = model._openGLRenderWindow.getContext();
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.getMaximumTextureSize = ctx => {
      if (ctx && ctx.isCurrent()) {
        return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);
      }
      return -1;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$12 = {
    _openGLRenderWindow: null,
    _forceInternalFormat: false,
    context: null,
    handle: 0,
    sendParametersTime: null,
    textureBuildTime: null,
    numberOfDimensions: 0,
    target: 0,
    format: 0,
    openGLDataType: 0,
    components: 0,
    width: 0,
    height: 0,
    depth: 0,
    autoParameters: true,
    wrapS: Wrap$1.CLAMP_TO_EDGE,
    wrapT: Wrap$1.CLAMP_TO_EDGE,
    wrapR: Wrap$1.CLAMP_TO_EDGE,
    minificationFilter: Filter$1.NEAREST,
    magnificationFilter: Filter$1.NEAREST,
    minLOD: -1000.0,
    maxLOD: 1000.0,
    baseLevel: 0,
    maxLevel: 1000,
    generateMipmap: false,
    // use half float by default, but it will get set
    // to false if the context does not support it or
    // the voxel intensity range is out of the accurate
    // range of half float
    useHalfFloat: true,
    oglNorm16Ext: null,
    allocatedGPUMemoryInBytes: 0
  };

  // ----------------------------------------------------------------------------

  function extend$14(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$12, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.sendParametersTime = {};
    obj(model.sendParametersTime, {
      mtime: 0
    });
    model.textureBuildTime = {};
    obj(model.textureBuildTime, {
      mtime: 0
    });

    // Build VTK API
    set(publicAPI, model, ['format', 'openGLDataType']);
    setGet(publicAPI, model, ['keyMatrixTime', 'minificationFilter', 'magnificationFilter', 'wrapS', 'wrapT', 'wrapR', 'generateMipmap', 'oglNorm16Ext']);
    get$1(publicAPI, model, ['width', 'height', 'volumeInfo', 'components', 'handle', 'target', 'allocatedGPUMemoryInBytes']);
    moveToProtected(publicAPI, model, ['openGLRenderWindow']);

    // Object methods
    vtkOpenGLTexture(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$14 = newInstance$1I(extend$14, 'vtkOpenGLTexture');

  // ----------------------------------------------------------------------------

  var vtkOpenGLTexture$1 = {
    newInstance: newInstance$14,
    extend: extend$14,
    ...Constants$4
  };

  // Register ourself to OpenGL backend if imported
  registerOverride$1('vtkTexture', newInstance$14);

  var vtkPolyDataVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n";

  var vtkPolyDataFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n";

  function implementReplaceShaderCoincidentOffset(publicAPI, model) {
    publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {
      const cp = publicAPI.getCoincidentParameters(ren, actor);

      // if we need an offset handle it here
      // The value of .000016 is suitable for depth buffers
      // of at least 16 bit depth. We do not query the depth
      // right now because we would need some mechanism to
      // cache the result taking into account FBO changes etc.
      if (cp && (cp.factor !== 0.0 || cp.offset !== 0.0)) {
        let FSSource = shaders.Fragment;
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Coincident::Dec', ['uniform float cfactor;', 'uniform float coffset;']).result;
        if (model.context.getExtension('EXT_frag_depth')) {
          if (cp.factor !== 0.0) {
            FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;
          } else {
            FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;').result;
          }
        }
        if (model._openGLRenderWindow.getWebgl2()) {
          if (cp.factor !== 0.0) {
            FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::UniformFlow::Impl', ['float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));', '//VTK::UniformFlow::Impl'], false).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;').result;
          } else {
            FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Depth::Impl', 'gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;').result;
          }
        }
        shaders.Fragment = FSSource;
      }
    };
  }
  function implementBuildShadersWithReplacements(publicAPI, model) {
    publicAPI.applyShaderReplacements = (shaders, viewSpec, pre) => {
      let shaderReplacements = null;
      if (viewSpec) {
        shaderReplacements = viewSpec.ShaderReplacements;
      }
      if (shaderReplacements) {
        for (let i = 0; i < shaderReplacements.length; i++) {
          const currReplacement = shaderReplacements[i];
          if (pre && currReplacement.replaceFirst || !pre && !currReplacement.replaceFirst) {
            const shaderType = currReplacement.shaderType;
            const ssrc = shaders[shaderType];
            const substituteRes = vtkShaderProgram$1.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);
            shaders[shaderType] = substituteRes.result;
          }
        }
      }
    };
    publicAPI.buildShaders = (shaders, ren, actor) => {
      publicAPI.getReplacedShaderTemplate(shaders, ren, actor);
      model.lastRenderPassShaderReplacement = model.currentRenderPass ? model.currentRenderPass.getShaderReplacement() : null;

      // apply any renderPassReplacements
      if (model.lastRenderPassShaderReplacement) {
        model.lastRenderPassShaderReplacement(shaders);
      }
      const openGLSpec = model.renderable.getViewSpecificProperties().OpenGL;

      // user specified pre replacements
      publicAPI.applyShaderReplacements(shaders, openGLSpec, true);
      publicAPI.replaceShaderValues(shaders, ren, actor);

      // user specified post replacements
      publicAPI.applyShaderReplacements(shaders, openGLSpec);
    };
    publicAPI.getReplacedShaderTemplate = (shaders, ren, actor) => {
      const openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;
      publicAPI.getShaderTemplate(shaders, ren, actor);
      let vertexShaderCode = shaders.Vertex;
      if (openGLSpecProp) {
        const vertexSpecProp = openGLSpecProp.VertexShaderCode;
        if (vertexSpecProp !== undefined && vertexSpecProp !== '') {
          vertexShaderCode = vertexSpecProp;
        }
      }
      shaders.Vertex = vertexShaderCode;
      let fragmentShaderCode = shaders.Fragment;
      if (openGLSpecProp) {
        const fragmentSpecProp = openGLSpecProp.FragmentShaderCode;
        if (fragmentSpecProp !== undefined && fragmentSpecProp !== '') {
          fragmentShaderCode = fragmentSpecProp;
        }
      }
      shaders.Fragment = fragmentShaderCode;
      let geometryShaderCode = shaders.Geometry;
      if (openGLSpecProp) {
        const geometrySpecProp = openGLSpecProp.GeometryShaderCode;
        if (geometrySpecProp !== undefined) {
          geometryShaderCode = geometrySpecProp;
        }
      }
      shaders.Geometry = geometryShaderCode;
    };
  }
  var vtkReplacementShaderMapper = {
    implementReplaceShaderCoincidentOffset,
    implementBuildShadersWithReplacements
  };

  const {
    FieldAssociations: FieldAssociations$3
  } = vtkDataSet$1;

  /* eslint-disable no-lonely-if */

  const {
    primTypes: primTypes$1
  } = vtkHelper;
  const {
    Representation: Representation$4,
    Shading
  } = vtkProperty$1;
  const {
    ScalarMode: ScalarMode$3
  } = vtkMapper$1;
  const {
    Filter,
    Wrap
  } = vtkOpenGLTexture$1;
  const {
    vtkErrorMacro: vtkErrorMacro$i
  } = macro$1;
  const StartEvent$1 = {
    type: 'StartEvent'
  };
  const EndEvent$1 = {
    type: 'EndEvent'
  };
  const {
    CoordinateSystem: CoordinateSystem$3
  } = vtkProp$1;

  // ----------------------------------------------------------------------------
  // vtkOpenGLPolyDataMapper methods
  // ----------------------------------------------------------------------------

  function getPickState(renderer) {
    const selector = renderer.getSelector();
    if (selector) {
      return selector.getCurrentPass();
    }
    return PassTypes$1.MIN_KNOWN_PASS - 1;
  }
  function vtkOpenGLPolyDataMapper(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLPolyDataMapper');
    publicAPI.buildPass = prepass => {
      if (prepass) {
        model.currentRenderPass = null;
        model.openGLActor = publicAPI.getFirstAncestorOfType('vtkOpenGLActor');
        model._openGLRenderer = model.openGLActor.getFirstAncestorOfType('vtkOpenGLRenderer');
        model._openGLRenderWindow = model._openGLRenderer.getParent();
        model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
      }
    };

    // Renders myself
    publicAPI.translucentPass = (prepass, renderPass) => {
      if (prepass) {
        model.currentRenderPass = renderPass;
        publicAPI.render();
      }
    };
    publicAPI.zBufferPass = prepass => {
      if (prepass) {
        model.haveSeenDepthRequest = true;
        model.renderDepth = true;
        publicAPI.render();
        model.renderDepth = false;
      }
    };
    publicAPI.opaqueZBufferPass = prepass => publicAPI.zBufferPass(prepass);
    publicAPI.opaquePass = prepass => {
      if (prepass) {
        publicAPI.render();
      }
    };
    publicAPI.render = () => {
      const ctx = model._openGLRenderWindow.getContext();
      if (model.context !== ctx) {
        model.context = ctx;
        for (let i = primTypes$1.Start; i < primTypes$1.End; i++) {
          model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
        }
      }
      const actor = model.openGLActor.getRenderable();
      const ren = model._openGLRenderer.getRenderable();
      publicAPI.renderPiece(ren, actor);
    };
    publicAPI.getShaderTemplate = (shaders, ren, actor) => {
      shaders.Vertex = vtkPolyDataVS;
      shaders.Fragment = vtkPolyDataFS;
      shaders.Geometry = '';
    };
    publicAPI.replaceShaderColor = (shaders, ren, actor) => {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');

      // create the material/color property declarations, and VS implementation
      // these are always defined
      let colorDec = ['uniform float ambient;', 'uniform float diffuse;', 'uniform float specular;', 'uniform float opacityUniform; // the fragment opacity', 'uniform vec3 ambientColorUniform;', 'uniform vec3 diffuseColorUniform;'];
      // add more for specular
      if (lastLightComplexity) {
        colorDec = colorDec.concat(['uniform vec3 specularColorUniform;', 'uniform float specularPowerUniform;']);
      }

      // now handle the more complex fragment shader implementation
      // the following are always defined variables.  We start
      // by assigning a default value from the uniform
      let colorImpl = ['vec3 ambientColor;', '  vec3 diffuseColor;', '  float opacity;'];
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(['  vec3 specularColor;', '  float specularPower;']);
      }
      colorImpl = colorImpl.concat(['  ambientColor = ambientColorUniform;', '  diffuseColor = diffuseColorUniform;', '  opacity = opacityUniform;']);
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(['  specularColor = specularColorUniform;', '  specularPower = specularPowerUniform;']);
      }

      // add scalar vertex coloring
      if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
        colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::Color::Dec', ['attribute vec4 scalarColor;', 'varying vec4 vertexColorVSOutput;']).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::Color::Impl', ['vertexColorVSOutput =  scalarColor;']).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 vertexColorVSOutput[];', 'out vec4 vertexColorGSOutput;']).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::Color::Impl', ['vertexColorGSOutput = vertexColorVSOutput[i];']).result;
      }
      if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  diffuseColor = vertexColorVSOutput.rgb;', '  ambientColor = vertexColorVSOutput.rgb;', '  opacity = opacity*vertexColorVSOutput.a;'])).result;
      } else {
        if (model.renderable.getInterpolateScalarsBeforeMapping() && model.renderable.getColorCoordinates() && !model.drawingEdges) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Color::Impl', colorImpl.concat(['  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);', '  diffuseColor = texColor.rgb;', '  ambientColor = texColor.rgb;', '  opacity = opacity*texColor.a;'])).result;
        } else {
          if (actor.getBackfaceProperty() && !model.drawingEdges) {
            colorDec = colorDec.concat(['uniform float opacityUniformBF; // the fragment opacity', 'uniform float ambientIntensityBF; // the material ambient', 'uniform float diffuseIntensityBF; // the material diffuse', 'uniform vec3 ambientColorUniformBF; // ambient material color', 'uniform vec3 diffuseColorUniformBF; // diffuse material color']);
            if (lastLightComplexity) {
              colorDec = colorDec.concat(['uniform float specularIntensityBF; // the material specular intensity', 'uniform vec3 specularColorUniformBF; // intensity weighted color', 'uniform float specularPowerUniformBF;']);
              colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  specularColor = specularIntensityBF * specularColorUniformBF;', '  specularPower = specularPowerUniformBF;', '  opacity = opacityUniformBF; }']);
            } else {
              colorImpl = colorImpl.concat(['if (gl_FrontFacing == false) {', '  ambientColor = ambientIntensityBF * ambientColorUniformBF;', '  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;', '  opacity = opacityUniformBF; }']);
            }
          }
          if (model.haveCellScalars && !model.drawingEdges) {
            colorDec = colorDec.concat(['uniform samplerBuffer texture1;']);
          }
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Color::Impl', colorImpl).result;
        }
      }
      FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Color::Dec', colorDec).result;
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    };
    publicAPI.replaceShaderLight = (shaders, ren, actor) => {
      let FSSource = shaders.Fragment;

      // check for shadow maps
      const shadowFactor = '';
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
      const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');
      let sstring = [];
      switch (lastLightComplexity) {
        case 0:
          // no lighting or RENDER_VALUES
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Light::Impl', ['  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);', '  //VTK::Light::Impl'], false).result;
          break;
        case 1:
          // headlight
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Light::Impl', ['  float df = max(0.0, normalVCVSOutput.z);', '  float sf = pow(df, specularPower);', '  vec3 diffuseL = df * diffuseColor;', '  vec3 specularL = sf * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl'], false).result;
          break;
        case 2:
          // light kit
          for (let lc = 0; lc < lastLightCount; ++lc) {
            sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`]);
          }
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Light::Dec', sstring).result;
          sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  float df;'];
          for (let lc = 0; lc < lastLightCount; ++lc) {
            sstring = sstring.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${lc}));`, `  diffuseL += ((df${shadowFactor}) * lightColor${lc});`, `  if (dot(normalVCVSOutput, lightDirectionVC${lc}) < 0.0)`, '    {', `    float sf = sign(df)*pow(max(1e-5,
                                              dot(reflect(lightDirectionVC${lc},normalVCVSOutput),
                                                  normalize(-vertexVC.xyz))),
                                         specularPower);`, `    specularL += (sf${shadowFactor} * lightColor${lc});`, '    }']);
          }
          sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;
          break;
        case 3:
          // positional
          for (let lc = 0; lc < lastLightCount; ++lc) {
            sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`, `uniform vec3 lightPositionVC${lc};`, `uniform vec3 lightAttenuation${lc};`, `uniform float lightConeAngle${lc};`, `uniform float lightExponent${lc};`, `uniform int lightPositional${lc};`]);
          }
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Light::Dec', sstring).result;
          sstring = ['vec3 diffuseL = vec3(0,0,0);', '  vec3 specularL = vec3(0,0,0);', '  vec3 vertLightDirectionVC;', '  float attenuation;', '  float df;'];
          for (let lc = 0; lc < lastLightCount; ++lc) {
            sstring = sstring.concat(['  attenuation = 1.0;', `  if (lightPositional${lc} == 0)`, '    {', `      vertLightDirectionVC = lightDirectionVC${lc};`, '    }', '  else', '    {', `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${lc};`, '    float distanceVC = length(vertLightDirectionVC);', '    vertLightDirectionVC = normalize(vertLightDirectionVC);', '    attenuation = 1.0 /', `      (lightAttenuation${lc}.x`, `       + lightAttenuation${lc}.y * distanceVC`, `       + lightAttenuation${lc}.z * distanceVC * distanceVC);`, '    // per OpenGL standard cone angle is 90 or less for a spot light', `    if (lightConeAngle${lc} <= 90.0)`, '      {', `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${lc});`, '      // if inside the cone', `      if (coneDot >= cos(radians(lightConeAngle${lc})))`, '        {', `        attenuation = attenuation * pow(coneDot, lightExponent${lc});`, '        }', '      else', '        {', '        attenuation = 0.0;', '        }', '      }', '    }', '    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));', `    diffuseL += ((df${shadowFactor}) * lightColor${lc});`, '    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)', '      {', `      float sf = sign(df)*attenuation*pow(max(1e-5,
                                                           dot(reflect(lightDirectionVC${lc},
                                                                       normalVCVSOutput),
                                                               normalize(-vertexVC.xyz))),
                                                       specularPower);`, `    specularL += ((sf${shadowFactor}) * lightColor${lc});`, '    }']);
          }
          sstring = sstring.concat(['  diffuseL = diffuseL * diffuseColor;', '  specularL = specularL * specularColor;', '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);', '  //VTK::Light::Impl']);
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Light::Impl', sstring, false).result;
          break;
        default:
          vtkErrorMacro$i('bad light complexity');
      }
      shaders.Fragment = FSSource;
    };
    publicAPI.replaceShaderNormal = (shaders, ren, actor) => {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
      if (lastLightComplexity > 0) {
        let VSSource = shaders.Vertex;
        let GSSource = shaders.Geometry;
        let FSSource = shaders.Fragment;
        if (model.lastBoundBO.getCABO().getNormalOffset()) {
          VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::Normal::Dec', ['attribute vec3 normalMC;', 'uniform mat3 normalMatrix;', 'varying vec3 normalVCVSOutput;']).result;
          VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::Normal::Impl', ['normalVCVSOutput = normalMatrix * normalMC;']).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::Normal::Dec', ['in vec3 normalVCVSOutput[];', 'out vec3 normalVCGSOutput;']).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::Normal::Impl', ['normalVCGSOutput = normalVCVSOutput[i];']).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Normal::Dec', ['varying vec3 normalVCVSOutput;']).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalVCVSOutput);',
          //  if (!gl_FrontFacing) does not work in intel hd4000 mac
          //  if (int(gl_FrontFacing) == 0) does not work on mesa
          '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;
        } else {
          if (model.haveCellNormals) {
            FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Normal::Dec', ['uniform mat3 normalMatrix;', 'uniform samplerBuffer textureN;']).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput = normalize(normalMatrix *', '    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);', '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }']).result;
          } else {
            if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {
              // generate a normal for lines, it will be perpendicular to the line
              // and maximally aligned with the camera view direction
              // no clue if this is the best way to do this.
              // the code below has been optimized a bit so what follows is
              // an explanation of the basic approach. Compute the gradient of the line
              // with respect to x and y, the the larger of the two
              // cross that with the camera view direction. That gives a vector
              // orthogonal to the camera view and the line. Note that the line and the camera
              // view are probably not orthogonal. Which is why when we cross result that with
              // the line gradient again we get a reasonable normal. It will be othogonal to
              // the line (which is a plane but maximally aligned with the camera view.
              FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::UniformFlow::Impl', ['  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements
              ).result;
              FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Normal::Impl', ['vec3 normalVCVSOutput;', '  if (abs(fdx.x) > 0.0)', '    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }', '  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}']).result;
            } else {
              FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Normal::Dec', ['uniform int cameraParallel;']).result;
              FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::UniformFlow::Impl', [
              // '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',
              // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',
              '  vec3 fdx = dFdx(vertexVC.xyz);', '  vec3 fdy = dFdy(vertexVC.xyz);', '  //VTK::UniformFlow::Impl'] // For further replacements
              ).result;
              FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Normal::Impl', ['  fdx = normalize(fdx);', '  fdy = normalize(fdy);', '  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));',
              // the code below is faster, but does not work on some devices
              // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',
              '  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }', '  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }']).result;
            }
          }
        }
        shaders.Vertex = VSSource;
        shaders.Geometry = GSSource;
        shaders.Fragment = FSSource;
      }
    };
    publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
      // replace common shader code
      model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;

      // do we need the vertex in the shader in View Coordinates
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
      if (lastLightComplexity > 0) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::PositionVC::Impl', ['vertexVCVSOutput = MCVCMatrix * vertexMC;', '  gl_Position = MCPCMatrix * vertexMC;']).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;', 'uniform mat4 MCVCMatrix;']).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::PositionVC::Dec', ['in vec4 vertexVCVSOutput[];', 'out vec4 vertexVCGSOutput;']).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::PositionVC::Impl', ['vertexVCGSOutput = vertexVCVSOutput[i];']).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::PositionVC::Dec', ['varying vec4 vertexVCVSOutput;']).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::PositionVC::Impl', ['vec4 vertexVC = vertexVCVSOutput;']).result;
      } else {
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::Camera::Dec', ['uniform mat4 MCPCMatrix;']).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::PositionVC::Impl', ['  gl_Position = MCPCMatrix * vertexMC;']).result;
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    };
    publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
      if (model.lastBoundBO.getCABO().getTCoordOffset()) {
        let VSSource = shaders.Vertex;
        let GSSource = shaders.Geometry;
        let FSSource = shaders.Fragment;
        if (model.drawingEdges) {
          return;
        }
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::TCoord::Impl', 'tcoordVCVSOutput = tcoordMC;').result;

        // we only handle the first texture by default
        // additional textures are activated and we set the uniform
        // for the texture unit they are assigned to, but you have to
        // add in the shader code to do something with them
        const tus = model.openGLActor.getActiveTextures();
        let tNumComp = 2;
        let tcdim = 2;
        if (tus && tus.length > 0) {
          tNumComp = tus[0].getComponents();
          if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {
            tcdim = 3;
          }
        }
        if (model.renderable.getColorTextureMap()) {
          tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();
          tcdim = 2;
        }
        if (tcdim === 2) {
          VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;').result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];', 'out vec2 tcoordVCGSOutput;']).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;
          if (tus && tus.length >= 1) {
            switch (tNumComp) {
              case 1:
                FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;
                break;
              case 2:
                FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;
                break;
              default:
                FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;
            }
          }
        } else {
          VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::TCoord::Dec', 'attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;').result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec3 tcoordVCVSOutput[];', 'out vec3 tcoordVCGSOutput;']).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];').result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::TCoord::Dec', ['varying vec3 tcoordVCVSOutput;', 'uniform samplerCube texture1;']).result;
          switch (tNumComp) {
            case 1:
              FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;']).result;
              break;
            case 2:
              FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.r;', '  diffuseColor = diffuseColor*tcolor.r;', '  opacity = opacity * tcolor.g;']).result;
              break;
            default:
              FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::TCoord::Impl', ['  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);', '  ambientColor = ambientColor*tcolor.rgb;', '  diffuseColor = diffuseColor*tcolor.rgb;', '  opacity = opacity * tcolor.a;']).result;
          }
        }
        shaders.Vertex = VSSource;
        shaders.Geometry = GSSource;
        shaders.Fragment = FSSource;
      }
    };
    publicAPI.replaceShaderClip = (shaders, ren, actor) => {
      let VSSource = shaders.Vertex;
      let FSSource = shaders.Fragment;
      if (model.renderable.getNumberOfClippingPlanes()) {
        const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `uniform vec4 clipPlanes[${numClipPlanes}];`, `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);', '    }']).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Clip::Dec', ['uniform int numClipPlanes;', `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Clip::Impl', [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, '    {', '    if (planeNum >= numClipPlanes)', '        {', '        break;', '        }', '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;', '    }']).result;
      }
      shaders.Vertex = VSSource;
      shaders.Fragment = FSSource;
    };
    publicAPI.getCoincidentParameters = (ren, actor) => {
      // 1. ResolveCoincidentTopology is On and non zero for this primitive
      // type
      let cp = {
        factor: 0.0,
        offset: 0.0
      };
      const prop = actor.getProperty();
      if (model.renderable.getResolveCoincidentTopology() || prop.getEdgeVisibility() && prop.getRepresentation() === Representation$4.SURFACE) {
        const primType = model.lastBoundBO.getPrimitiveType();
        if (primType === primTypes$1.Points || prop.getRepresentation() === Representation$4.POINTS) {
          cp = model.renderable.getCoincidentTopologyPointOffsetParameter();
        } else if (primType === primTypes$1.Lines || prop.getRepresentation() === Representation$4.WIREFRAME) {
          cp = model.renderable.getCoincidentTopologyLineOffsetParameters();
        } else if (primType === primTypes$1.Tris || primType === primTypes$1.TriStrips) {
          cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
        }
        if (primType === primTypes$1.TrisEdges || primType === primTypes$1.TriStripsEdges) {
          cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
          cp.factor /= 2.0;
          cp.offset /= 2.0;
        }
      }

      // hardware picking always offset due to saved zbuffer
      // This gets you above the saved surface depth buffer.
      const selector = model._openGLRenderer.getSelector();
      if (selector && selector.getFieldAssociation() === FieldAssociations$3.FIELD_ASSOCIATION_POINTS) {
        cp.offset -= 2.0;
      }
      return cp;
    };
    publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
      let FSSource = shaders.Fragment;
      let VSSource = shaders.Vertex;
      FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Picking::Dec', ['uniform int picking;', '//VTK::Picking::Dec']).result;
      if (!model._openGLRenderer.getSelector()) {
        return;
      }
      if (model.lastSelectionState === PassTypes$1.ID_LOW24 || model.lastSelectionState === PassTypes$1.ID_HIGH24) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::Picking::Dec', ['flat out int vertexIDVSOutput;\n', 'uniform int VertexIDOffset;\n']).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::Picking::Impl', '  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n').result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Picking::Dec', 'flat in int vertexIDVSOutput;\n').result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Picking::Impl', ['  int idx = vertexIDVSOutput;', '//VTK::Picking::Impl']).result;
      }
      switch (model.lastSelectionState) {
        case PassTypes$1.ID_LOW24:
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);').result;
          break;
        case PassTypes$1.ID_HIGH24:
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = vec4(float(idx)/255.0, 0.0, 0.0, 1.0);').result;
          break;
        default:
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Picking::Dec', 'uniform vec3 mapperIndex;').result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;
      }
      shaders.Fragment = FSSource;
      shaders.Vertex = VSSource;
    };
    publicAPI.replaceShaderValues = (shaders, ren, actor) => {
      publicAPI.replaceShaderColor(shaders, ren, actor);
      publicAPI.replaceShaderNormal(shaders, ren, actor);
      publicAPI.replaceShaderLight(shaders, ren, actor);
      publicAPI.replaceShaderTCoord(shaders, ren, actor);
      publicAPI.replaceShaderPicking(shaders, ren, actor);
      publicAPI.replaceShaderClip(shaders, ren, actor);
      publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
      publicAPI.replaceShaderPositionVC(shaders, ren, actor);
      if (model.haveSeenDepthRequest) {
        let FSSource = shaders.Fragment;
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::ZBuffer::Dec', 'uniform int depthRequest;').result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::ZBuffer::Impl', ['if (depthRequest == 1) {', 'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);', 'float rf = floor(iz/256.0)/255.0;', 'float gf = mod(iz,256.0)/255.0;', 'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }']).result;
        shaders.Fragment = FSSource;
      }
    };
    publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
      let lightComplexity = 0;
      let numberOfLights = 0;
      const primType = cellBO.getPrimitiveType();
      const poly = model.currentInput;

      // different algo from C++ as of 5/2019
      let needLighting = false;
      const pointNormals = poly.getPointData().getNormals();
      const cellNormals = poly.getCellData().getNormals();
      const flat = actor.getProperty().getInterpolation() === Shading.FLAT;
      const representation = actor.getProperty().getRepresentation();
      const mode = cellBO.getOpenGLMode(representation, primType);
      // 1) all surfaces need lighting
      if (mode === model.context.TRIANGLES) {
        needLighting = true;
        // 2) all cell normals without point normals need lighting
      } else if (cellNormals && !pointNormals) {
        needLighting = true;
        // 3) Phong + pointNormals need lighting
      } else if (!flat && pointNormals) {
        needLighting = true;
        // 4) Phong Lines need lighting
      } else if (!flat && mode === model.context.LINES) {
        needLighting = true;
      }
      // 5) everything else is unlit

      // do we need lighting?
      if (actor.getProperty().getLighting() && needLighting) {
        // consider the lighting complexity to determine which case applies
        // simple headlight, Light Kit, the whole feature set of VTK
        lightComplexity = 0;
        const lights = ren.getLightsByReference();
        for (let index = 0; index < lights.length; ++index) {
          const light = lights[index];
          const status = light.getSwitch();
          if (status > 0) {
            numberOfLights++;
            if (lightComplexity === 0) {
              lightComplexity = 1;
            }
          }
          if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1.0 || !light.lightTypeIsHeadLight())) {
            lightComplexity = 2;
          }
          if (lightComplexity < 3 && light.getPositional()) {
            lightComplexity = 3;
          }
        }
      }
      let needRebuild = false;
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
      const lastLightCount = model.lastBoundBO.getReferenceByName('lastLightCount');
      if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {
        model.lastBoundBO.set({
          lastLightComplexity: lightComplexity
        }, true);
        model.lastBoundBO.set({
          lastLightCount: numberOfLights
        }, true);
        needRebuild = true;
      }

      // has the render pass shader replacement changed? Two options
      if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
        needRebuild = true;
      }

      // has something changed that would require us to recreate the shader?
      // candidates are
      // property modified (representation interpolation and lighting)
      // input modified
      // light complexity changed
      // render pass shader replacement changed
      if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {
        model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
        return true;
      }
      return false;
    };
    publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
      const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
      if (listCallbacks) {
        listCallbacks.forEach(object => {
          object.callback(object.userData, cellBO, ren, actor);
        });
      }
    };
    publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
      // Now to update the VAO too, if necessary.
      if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {
        cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);
      }
      if (cellBO.getProgram().isUniformUsed('VertexIDOffset')) {
        cellBO.getProgram().setUniformi('VertexIDOffset', model.vertexIDOffset);
      }
      if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
        const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
        if (cellBO.getProgram().isAttributeUsed('vertexMC')) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexMC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
            vtkErrorMacro$i('Error setting vertexMC in shader VAO.');
          }
        }
        if (cellBO.getProgram().isAttributeUsed('normalMC') && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'normalMC', cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
            vtkErrorMacro$i('Error setting normalMC in shader VAO.');
          }
        } else {
          cellBO.getVAO().removeAttributeArray('normalMC');
        }
        model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
          if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
            if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
              vtkErrorMacro$i(`Error setting ${attrName}MC in shader VAO.`);
            }
          }
        });
        if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
            vtkErrorMacro$i('Error setting tcoordMC in shader VAO.');
          }
        } else {
          cellBO.getVAO().removeAttributeArray('tcoordMC');
        }
        if (cellBO.getProgram().isAttributeUsed('scalarColor') && cellBO.getCABO().getColorComponents()) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), 'scalarColor', cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {
            vtkErrorMacro$i('Error setting scalarColor in shader VAO.');
          }
        } else {
          cellBO.getVAO().removeAttributeArray('scalarColor');
        }
        cellBO.getAttributeUpdateTime().modified();
      }
      if (model.renderable.getNumberOfClippingPlanes()) {
        // add all the clipping planes
        const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
        const planeEquations = [];
        const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
        const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
        const mat = inverseShiftScaleMatrix ? copy$1(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();
        if (inverseShiftScaleMatrix) {
          transpose(mat, mat);
          multiply$1(mat, mat, inverseShiftScaleMatrix);
          transpose(mat, mat);
        }
        for (let i = 0; i < numClipPlanes; i++) {
          const planeEquation = [];
          model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);
          for (let j = 0; j < 4; j++) {
            planeEquations.push(planeEquation[j]);
          }
        }
        cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);
        cellBO.getProgram().setUniform4fv('clipPlanes', planeEquations);
      }
      if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {
        cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());
      }
      const tus = model.openGLActor.getActiveTextures();
      if (tus) {
        for (let index = 0; index < tus.length; ++index) {
          const tex = tus[index];
          const texUnit = tex.getTextureUnit();
          const tname = `texture${texUnit + 1}`;
          if (cellBO.getProgram().isUniformUsed(tname)) {
            cellBO.getProgram().setUniformi(tname, texUnit);
          }
        }
      }

      // handle depth requests
      if (model.haveSeenDepthRequest) {
        cellBO.getProgram().setUniformi('depthRequest', model.renderDepth ? 1 : 0);
      }

      // handle coincident
      if (cellBO.getProgram().isUniformUsed('coffset')) {
        const cp = publicAPI.getCoincidentParameters(ren, actor);
        cellBO.getProgram().setUniformf('coffset', cp.offset);
        // cfactor isn't always used when coffset is.
        if (cellBO.getProgram().isUniformUsed('cfactor')) {
          cellBO.getProgram().setUniformf('cfactor', cp.factor);
        }
      }

      // handle wide lines
      cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
      const selector = model._openGLRenderer.getSelector();
      cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);
      cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);
    };
    publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
      // for unlit and headlight there are no lighting parameters
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
      if (lastLightComplexity < 2) {
        return;
      }
      const program = cellBO.getProgram();

      // bind some light settings
      let numberOfLights = 0;
      const lights = ren.getLightsByReference();
      for (let index = 0; index < lights.length; ++index) {
        const light = lights[index];
        const status = light.getSwitch();
        if (status > 0.0) {
          const dColor = light.getColorByReference();
          const intensity = light.getIntensity();
          model.lightColor[0] = dColor[0] * intensity;
          model.lightColor[1] = dColor[1] * intensity;
          model.lightColor[2] = dColor[2] * intensity;
          // get required info from light
          const ld = light.getDirection();
          const transform = ren.getActiveCamera().getViewMatrix();
          const newLightDirection = [...ld];
          if (light.lightTypeIsSceneLight()) {
            newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];
            newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];
            newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];
            normalize(newLightDirection);
          }
          model.lightDirection[0] = newLightDirection[0];
          model.lightDirection[1] = newLightDirection[1];
          model.lightDirection[2] = newLightDirection[2];
          normalize(model.lightDirection);
          program.setUniform3fArray(`lightColor${numberOfLights}`, model.lightColor);
          program.setUniform3fArray(`lightDirectionVC${numberOfLights}`, model.lightDirection);
          numberOfLights++;
        }
      }

      // we are done unless we have positional lights
      if (lastLightComplexity < 3) {
        return;
      }

      // for lightkit case there are some parameters to set
      const cam = ren.getActiveCamera();
      const viewTF = cam.getViewMatrix();
      transpose(viewTF, viewTF);
      numberOfLights = 0;
      for (let index = 0; index < lights.length; ++index) {
        const light = lights[index];
        const status = light.getSwitch();
        if (status > 0.0) {
          const lp = light.getTransformedPosition();
          const np = new Float64Array(3);
          transformMat4$1(np, lp, viewTF);
          program.setUniform3fArray(`lightAttenuation${numberOfLights}`, light.getAttenuationValuesByReference());
          program.setUniformi(`lightPositional${numberOfLights}`, light.getPositional());
          program.setUniformf(`lightExponent${numberOfLights}`, light.getExponent());
          program.setUniformf(`lightConeAngle${numberOfLights}`, light.getConeAngle());
          program.setUniform3fArray(`lightPositionVC${numberOfLights}`, [np[0], np[1], np[2]]);
          numberOfLights++;
        }
      }
    };
    function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
      matrixType.identity(tmpMat);
      return matrixArray.reduce((res, matrix, index) => {
        if (index === 0) {
          return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
        }
        return matrix ? matrixType.multiply(res, res, matrix) : res;
      }, tmpMat);
    }
    publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
      const program = cellBO.getProgram();

      // [WMVP]C == {world, model, view, projection} coordinates
      // E.g., WCPC == world to projection coordinate transformation
      const keyMats = model.openGLCamera.getKeyMatrices(ren);
      const cam = ren.getActiveCamera();
      const camm = model.openGLCamera.getKeyMatrixTime().getMTime();
      const progm = program.getLastCameraMTime();
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      const actorIsIdentity = actor.getIsIdentity();
      const actMats = actorIsIdentity ? {
        mcwc: null,
        normalMatrix: null
      } : model.openGLActor.getKeyMatrices();
      if (actor.getCoordinateSystem() === CoordinateSystem$3.DISPLAY) {
        const size = model._openGLRenderer.getTiledSizeAndOrigin();
        identity$3(model.tmpMat4);
        model.tmpMat4[0] = 2.0 / size.usize;
        model.tmpMat4[12] = -1.0;
        model.tmpMat4[5] = 2.0 / size.vsize;
        model.tmpMat4[13] = -1.0;
        multiply$1(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);
        program.setUniformMatrix('MCPCMatrix', model.tmpMat4);
      } else {
        program.setUniformMatrix('MCPCMatrix', safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));
      }
      if (program.isUniformUsed('MCVCMatrix')) {
        program.setUniformMatrix('MCVCMatrix', safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4, model.tmpMat4));
      }
      if (program.isUniformUsed('normalMatrix')) {
        program.setUniformMatrix3x3('normalMatrix', safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], mat3, model.tmpMat3));
      }
      if (progm !== camm) {
        if (program.isUniformUsed('cameraParallel')) {
          program.setUniformi('cameraParallel', cam.getParallelProjection());
        }
        program.setLastCameraMTime(camm);
      }
      if (!actorIsIdentity) {
        // reset the cam mtime as actor modified the shader values
        program.setLastCameraMTime(0);
      }
    };
    publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
      const program = cellBO.getProgram();
      let ppty = actor.getProperty();
      let opacity = ppty.getOpacity();
      let aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();
      let dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();
      let aIntensity = model.drawingEdges ? 1.0 : ppty.getAmbient();
      let dIntensity = model.drawingEdges ? 0.0 : ppty.getDiffuse();
      let sIntensity = model.drawingEdges ? 0.0 : ppty.getSpecular();
      const specularPower = ppty.getSpecularPower();
      program.setUniformf('opacityUniform', opacity);
      program.setUniform3fArray('ambientColorUniform', aColor);
      program.setUniform3fArray('diffuseColorUniform', dColor);
      program.setUniformf('ambient', aIntensity);
      program.setUniformf('diffuse', dIntensity);

      // we are done unless we have lighting
      const lastLightComplexity = model.lastBoundBO.getReferenceByName('lastLightComplexity');
      if (lastLightComplexity < 1) {
        return;
      }
      let sColor = ppty.getSpecularColorByReference();
      program.setUniform3fArray('specularColorUniform', sColor);
      program.setUniformf('specularPowerUniform', specularPower);
      program.setUniformf('specular', sIntensity);

      // now set the backface properties if we have them
      if (program.isUniformUsed('ambientIntensityBF')) {
        ppty = actor.getBackfaceProperty();
        opacity = ppty.getOpacity();
        aColor = ppty.getAmbientColor();
        aIntensity = ppty.getAmbient();
        dColor = ppty.getDiffuseColor();
        dIntensity = ppty.getDiffuse();
        sColor = ppty.getSpecularColor();
        sIntensity = ppty.getSpecular();
        program.setUniformf('ambientIntensityBF', aIntensity);
        program.setUniformf('diffuseIntensityBF', dIntensity);
        program.setUniformf('opacityUniformBF', opacity);
        program.setUniform3fArray('ambientColorUniformBF', aColor);
        program.setUniform3fArray('diffuseColorUniformBF', dColor);

        // we are done unless we have lighting
        if (lastLightComplexity < 1) {
          return;
        }
        program.setUniformf('specularIntensityBF', sIntensity);
        program.setUniform3fArray('specularColorUniformBF', sColor);
        program.setUniformf('specularPowerUniformBF', specularPower);
      }
    };
    publicAPI.updateMaximumPointCellIds = (ren, actor) => {
      const selector = model._openGLRenderer.getSelector();
      if (!selector) {
        return;
      }
      if (model.selectionWebGLIdsToVTKIds?.points?.length) {
        const length = model.selectionWebGLIdsToVTKIds.points.length;
        selector.setMaximumPointId(length - 1);
      }
      if (model.selectionWebGLIdsToVTKIds?.cells?.length) {
        const length = model.selectionWebGLIdsToVTKIds.cells.length;
        selector.setMaximumCellId(length - 1);
      }
      const fieldAssociation = selector.getFieldAssociation();
      if (fieldAssociation === FieldAssociations$3.FIELD_ASSOCIATION_POINTS) {
        model.pointPicking = true;
      }
    };
    publicAPI.renderPieceStart = (ren, actor) => {
      model.primitiveIDOffset = 0;
      model.vertexIDOffset = 0;
      const picking = getPickState(model._openGLRenderer);
      if (model.lastSelectionState !== picking) {
        model.selectionStateChanged.modified();
        model.lastSelectionState = picking;
      }
      if (model._openGLRenderer.getSelector()) {
        switch (picking) {
          default:
            model._openGLRenderer.getSelector().renderProp(actor);
        }
      }

      // make sure the BOs are up to date
      publicAPI.updateBufferObjects(ren, actor);

      // If we are coloring by texture, then load the texture map.
      // Use Map as indicator, because texture hangs around.
      if (model.renderable.getColorTextureMap()) {
        model.internalColorTexture.activate();
      }

      // Bind the OpenGL, this is shared between the different primitive/cell types.
      model.lastBoundBO = null;
    };
    publicAPI.renderPieceDraw = (ren, actor) => {
      const representation = actor.getProperty().getRepresentation();
      const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation$4.SURFACE;
      const selector = model._openGLRenderer.getSelector();
      // If we are picking points, we need to tell it to the helper
      const pointPicking = selector && selector.getFieldAssociation() === FieldAssociations$3.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === PassTypes$1.ID_LOW24 || model.lastSelectionState === PassTypes$1.ID_HIGH24);

      // for every primitive type
      for (let i = primTypes$1.Start; i < primTypes$1.End; i++) {
        model.primitives[i].setPointPicking(pointPicking);
        const cabo = model.primitives[i].getCABO();
        if (cabo.getElementCount()) {
          // are we drawing edges
          model.drawingEdges = drawSurfaceWithEdges && (i === primTypes$1.TrisEdges || i === primTypes$1.TriStripsEdges);
          // don't draw edges when rendering depth or rendering for picking
          if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {
            model.lastBoundBO = model.primitives[i];
            model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
            model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();
          }
        }
      }
    };
    publicAPI.renderPieceFinish = (ren, actor) => {
      if (model.LastBoundBO) {
        model.LastBoundBO.getVAO().release();
      }
      if (model.renderable.getColorTextureMap()) {
        model.internalColorTexture.deactivate();
      }
    };
    publicAPI.renderPiece = (ren, actor) => {
      // Make sure that we have been properly initialized.
      // if (ren.getRenderWindow().checkAbortStatus()) {
      //   return;
      // }

      publicAPI.invokeEvent(StartEvent$1);
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      model.currentInput = model.renderable.getInputData();
      publicAPI.invokeEvent(EndEvent$1);
      if (!model.currentInput) {
        vtkErrorMacro$i('No input!');
        return;
      }

      // if there are no points then we are done
      if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
        return;
      }

      // apply faceCulling
      const gl = model.context;
      const backfaceCulling = actor.getProperty().getBackfaceCulling();
      const frontfaceCulling = actor.getProperty().getFrontfaceCulling();
      if (!backfaceCulling && !frontfaceCulling) {
        model._openGLRenderWindow.disableCullFace();
      } else if (frontfaceCulling) {
        model._openGLRenderWindow.enableCullFace();
        gl.cullFace(gl.FRONT);
      } else {
        model._openGLRenderWindow.enableCullFace();
        gl.cullFace(gl.BACK);
      }
      publicAPI.renderPieceStart(ren, actor);
      publicAPI.renderPieceDraw(ren, actor);
      publicAPI.renderPieceFinish(ren, actor);
    };
    publicAPI.computeBounds = (ren, actor) => {
      if (!publicAPI.getInput()) {
        uninitializeBounds(model.bounds);
        return;
      }
      model.bounds = publicAPI.getInput().getBounds();
    };
    publicAPI.updateBufferObjects = (ren, actor) => {
      // Rebuild buffers if needed
      if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
        publicAPI.buildBufferObjects(ren, actor);
      }
    };
    publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
      // first do a coarse check
      // Note that the actor's mtime includes it's properties mtime
      const vmtime = model.VBOBuildTime.getMTime();
      if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {
        return true;
      }
      return false;
    };
    publicAPI.buildBufferObjects = (ren, actor) => {
      const poly = model.currentInput;
      if (poly === null) {
        return;
      }
      model.renderable.mapScalars(poly, 1.0);
      const c = model.renderable.getColorMapColors();
      model.haveCellScalars = false;
      const scalarMode = model.renderable.getScalarMode();
      if (model.renderable.getScalarVisibility()) {
        // We must figure out how the scalars should be mapped to the polydata.
        if ((scalarMode === ScalarMode$3.USE_CELL_DATA || scalarMode === ScalarMode$3.USE_CELL_FIELD_DATA || scalarMode === ScalarMode$3.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode$3.USE_POINT_FIELD_DATA && c) {
          model.haveCellScalars = true;
        }
      }

      // Do we have normals?
      let n = actor.getProperty().getInterpolation() !== Shading.FLAT ? poly.getPointData().getNormals() : null;
      if (n === null && poly.getCellData().getNormals()) {
        model.haveCellNormals = true;
        n = poly.getCellData().getNormals();
      }

      // rebuild the VBO if the data has changed we create a string for the VBO what
      // can change the VBO? points normals tcoords colors so what can change those?
      // the input data is clearly one as it can change all four items tcoords may
      // haveTextures or not colors may change based on quite a few mapping
      // parameters in the mapper

      const representation = actor.getProperty().getRepresentation();
      let tcoords = poly.getPointData().getTCoords();
      if (!model.openGLActor.getActiveTextures()) {
        tcoords = null;
      }

      // handle color mapping via texture
      if (model.renderable.getColorCoordinates()) {
        tcoords = model.renderable.getColorCoordinates();
        if (!model.internalColorTexture) {
          model.internalColorTexture = vtkOpenGLTexture$1.newInstance({
            resizable: true
          });
        }
        const tex = model.internalColorTexture;
        // the following 4 lines allow for NPOT textures
        tex.setMinificationFilter(Filter.NEAREST);
        tex.setMagnificationFilter(Filter.NEAREST);
        tex.setWrapS(Wrap.CLAMP_TO_EDGE);
        tex.setWrapT(Wrap.CLAMP_TO_EDGE);
        tex.setOpenGLRenderWindow(model._openGLRenderWindow);
        const input = model.renderable.getColorTextureMap();
        const ext = input.getExtent();
        const inScalars = input.getPointData().getScalars();
        tex.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());
        tex.activate();
        tex.sendParameters();
        tex.deactivate();
      }
      const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}` + `C${n ? n.getMTime() : 1}D${c ? c.getMTime() : 1}` + `E${actor.getProperty().getEdgeVisibility()}` + `F${tcoords ? tcoords.getMTime() : 1}`;
      if (model.VBOBuildString !== toString) {
        // Build the VBOs
        const points = poly.getPoints();
        const options = {
          points,
          normals: n,
          tcoords,
          colors: c,
          cellOffset: 0,
          vertexOffset: 0,
          // Used to keep track of vertex ids across primitives for selection
          haveCellScalars: model.haveCellScalars,
          haveCellNormals: model.haveCellNormals,
          customAttributes: model.renderable.getCustomShaderAttributes().map(arrayName => poly.getPointData().getArrayByName(arrayName))
        };
        if (model.renderable.getPopulateSelectionSettings()) {
          model.selectionWebGLIdsToVTKIds = {
            points: null,
            cells: null
          };
        }
        const primitives = [{
          inRep: 'verts',
          cells: poly.getVerts()
        }, {
          inRep: 'lines',
          cells: poly.getLines()
        }, {
          inRep: 'polys',
          cells: poly.getPolys()
        }, {
          inRep: 'strips',
          cells: poly.getStrips()
        }, {
          inRep: 'polys',
          cells: poly.getPolys()
        }, {
          inRep: 'strips',
          cells: poly.getStrips()
        }];
        const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation$4.SURFACE;
        for (let i = primTypes$1.Start; i < primTypes$1.End; i++) {
          if (i !== primTypes$1.TrisEdges && i !== primTypes$1.TriStripsEdges) {
            options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);
            options.vertexOffset += model.primitives[i].getCABO().getElementCount();
          } else {
            // if we have edge visibility build the edge VBOs
            if (drawSurfaceWithEdges) {
              // VBOs for edges in "surface with edges" are the last to be built,
              // they are not used when picking with a hardware selector so they
              // don't need selectionWebGLIdsToVTKIds and don't update cellOffset and vertexOffset
              model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation$4.WIREFRAME, {
                ...options,
                tcoords: null,
                colors: null,
                haveCellScalars: false,
                haveCellNormals: false
              });
            } else {
              // otherwise free them
              model.primitives[i].releaseGraphicsResources();
            }
          }
        }
        if (model.renderable.getPopulateSelectionSettings()) {
          model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);
          publicAPI.updateMaximumPointCellIds();
        }
        model.VBOBuildTime.modified();
        model.VBOBuildString = toString;
      }
    };
    publicAPI.getAllocatedGPUMemoryInBytes = () => {
      let memUsed = 0;
      model.primitives.forEach(prim => {
        memUsed += prim.getAllocatedGPUMemoryInBytes();
      });
      // Return in MB
      return memUsed;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$11 = {
    context: null,
    VBOBuildTime: 0,
    VBOBuildString: null,
    primitives: null,
    primTypes: null,
    shaderRebuildString: null,
    tmpMat4: null,
    ambientColor: [],
    // used internally
    diffuseColor: [],
    // used internally
    specularColor: [],
    // used internally
    lightColor: [],
    // used internally
    lightDirection: [],
    // used internally
    lastHaveSeenDepthRequest: false,
    haveSeenDepthRequest: false,
    lastSelectionState: PassTypes$1.MIN_KNOWN_PASS - 1,
    selectionStateChanged: null,
    selectionWebGLIdsToVTKIds: null,
    pointPicking: false
  };

  // ----------------------------------------------------------------------------

  function extend$13(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$11, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
    vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
    model.primitives = [];
    model.primTypes = primTypes$1;
    model.tmpMat3 = identity$4(new Float64Array(9));
    model.tmpMat4 = identity$3(new Float64Array(16));
    for (let i = primTypes$1.Start; i < primTypes$1.End; i++) {
      model.primitives[i] = vtkHelper.newInstance();
      model.primitives[i].setPrimitiveType(i);
      model.primitives[i].set({
        lastLightComplexity: 0,
        lastLightCount: 0,
        lastSelectionPass: false
      }, true);
    }

    // Build VTK API
    setGet(publicAPI, model, ['context']);
    model.VBOBuildTime = {};
    obj(model.VBOBuildTime, {
      mtime: 0
    });
    model.selectionStateChanged = {};
    obj(model.selectionStateChanged, {
      mtime: 0
    });

    // Object methods
    vtkOpenGLPolyDataMapper(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$13 = newInstance$1I(extend$13, 'vtkOpenGLPolyDataMapper');

  // Register ourself to OpenGL backend if imported
  registerOverride$1('vtkMapper', newInstance$13);

  const {
    ColorMode,
    ScalarMode: ScalarMode$2,
    GetArray
  } = Constants$8;

  // ---------------------------------------------------------------------------
  // vtkMapper2D methods
  // ---------------------------------------------------------------------------

  function vtkMapper2D(publicAPI, model) {
    // Set out className
    model.classHierarchy.push('vtkMapper2D');
    publicAPI.createDefaultLookupTable = () => {
      model.lookupTable = vtkLookupTable$1.newInstance();
    };
    publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode, model.colorMode);
    publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
    publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
    publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);
    publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode$2, model.scalarMode);
    publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
    publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
    publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
    publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
    publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
    publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);
    publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {
      // make sure we have an input
      if (!input || !model.scalarVisibility) {
        return {
          scalars: null,
          cellFLag: false
        };
      }
      let scalars = null;
      let cellFlag = false;

      // get scalar data and point/cell attribute according to scalar mode
      if (scalarMode === ScalarMode$2.DEFAULT) {
        scalars = input.getPointData().getScalars();
        if (!scalars) {
          scalars = input.getCellData().getScalars();
          cellFlag = true;
        }
      } else if (scalarMode === ScalarMode$2.USE_POINT_DATA) {
        scalars = input.getPointData().getScalars();
      } else if (scalarMode === ScalarMode$2.USE_CELL_DATA) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      } else if (scalarMode === ScalarMode$2.USE_POINT_FIELD_DATA) {
        const pd = input.getPointData();
        if (arrayAccessMode === GetArray.BY_ID) {
          scalars = pd.getArrayByIndex(arrayId);
        } else {
          scalars = pd.getArrayByName(arrayName);
        }
      } else if (scalarMode === ScalarMode$2.USE_CELL_FIELD_DATA) {
        const cd = input.getCellData();
        cellFlag = true;
        if (arrayAccessMode === GetArray.BY_ID) {
          scalars = cd.getArrayByIndex(arrayId);
        } else {
          scalars = cd.getArrayByName(arrayName);
        }
      } else if (scalarMode === ScalarMode$2.USE_FIELD_DATA) {
        const fd = input.getFieldData();
        if (arrayAccessMode === GetArray.BY_ID) {
          scalars = fd.getArrayByIndex(arrayId);
        } else {
          scalars = fd.getArrayByName(arrayName);
        }
      }
      return {
        scalars,
        cellFlag
      };
    };
    publicAPI.getLookupTable = () => {
      if (!model.lookupTable) {
        publicAPI.createDefaultLookupTable();
      }
      return model.lookupTable;
    };
    publicAPI.getMTime = () => {
      let mt = model.mtime;
      if (model.lookupTable !== null) {
        const time = model.lookupTable.getMTime();
        mt = time > mt ? time : mt;
      }
      return mt;
    };
    publicAPI.mapScalars = (input, alpha) => {
      const scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;
      if (!scalars) {
        model.colorMapColors = null;
        return;
      }

      // we want to only recompute when something has changed
      const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
      if (model.colorBuildString === toString) return;
      if (!model.useLookupTableScalarRange) {
        publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
      }
      const lut = publicAPI.getLookupTable();
      if (lut) {
        // Ensure that the lookup table is built
        lut.build();
        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
      }
      model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
    };
    publicAPI.getPrimitiveCount = () => {
      const input = publicAPI.getInputData();
      const pcount = {
        points: input.getPoints().getNumberOfValues() / 3,
        verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
        lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
        triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
      };
      return pcount;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$10 = {
    static: false,
    lookupTable: null,
    scalarVisibility: false,
    scalarRange: [0, 1],
    useLookupTableScalarRange: false,
    colorMode: 0,
    scalarMode: 0,
    arrayAccessMode: 1,
    // By_NAME

    renderTime: 0,
    colorByArrayName: null,
    transformCoordinate: null,
    viewSpecificProperties: null,
    customShaderAttributes: []
  };

  // ----------------------------------------------------------------------------
  function extend$12(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$10, initialValues);

    // Inheritance
    vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
    macro.get(publicAPI, model, ['colorMapColors']);
    macro.setGet(publicAPI, model, ['arrayAccessMode', 'colorByArrayName', 'colorMode', 'lookupTable', 'renderTime', 'scalarMode', 'scalarVisibility', 'static', 'transformCoordinate', 'useLookupTableScalarRange', 'viewSpecificProperties', 'customShaderAttributes' // point data array names that will be transferred to the VBO
    ]);

    macro.setGetArray(publicAPI, model, ['scalarRange'], 2);
    if (!model.viewSpecificProperties) {
      model.viewSpecificProperties = {};
    }

    // Object methods
    vtkMapper2D(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$12 = macro.newInstance(extend$12, 'vtkMapper2D');

  // ----------------------------------------------------------------------------

  var vtkMapper2D$1 = {
    newInstance: newInstance$12,
    extend: extend$12
  };

  var vtkPolyData2DFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n";

  var vtkPolyData2DVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n";

  const DisplayLocation$2 = {
    BACKGROUND: 0,
    FOREGROUND: 1
  };
  var Constants$3 = {
    DisplayLocation: DisplayLocation$2
  };

  // import { mat3, mat4, vec3 } from 'gl-matrix';
  const {
    primTypes
  } = vtkHelper;
  const {
    ScalarMode: ScalarMode$1
  } = vtkMapper2D$1;
  const {
    vtkErrorMacro: vtkErrorMacro$h
  } = macro$1;
  const StartEvent = {
    type: 'StartEvent'
  };
  const EndEvent = {
    type: 'EndEvent'
  };

  // ----------------------------------------------------------------------------
  // vtkOpenGLPolyDataMapper2D methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLPolyDataMapper2D(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLPolyDataMapper2D');
    publicAPI.buildPass = prepass => {
      if (prepass) {
        model.openGLActor2D = publicAPI.getFirstAncestorOfType('vtkOpenGLActor2D');
        model._openGLRenderer = model.openGLActor2D.getFirstAncestorOfType('vtkOpenGLRenderer');
        model._openGLRenderWindow = model._openGLRenderer.getParent();
        model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera());
      }
    };
    publicAPI.overlayPass = prepass => {
      if (prepass) {
        publicAPI.render();
      }
    };
    publicAPI.getShaderTemplate = (shaders, ren, actor) => {
      shaders.Vertex = vtkPolyData2DVS;
      shaders.Fragment = vtkPolyData2DFS;
      shaders.Geometry = '';
    };
    publicAPI.render = () => {
      const ctx = model._openGLRenderWindow.getContext();
      if (model.context !== ctx) {
        model.context = ctx;
        for (let i = primTypes.Start; i < primTypes.End; i++) {
          model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
        }
      }
      const actor = model.openGLActor2D.getRenderable();
      const ren = model._openGLRenderer.getRenderable();
      publicAPI.renderPiece(ren, actor);
    };
    publicAPI.renderPiece = (ren, actor) => {
      publicAPI.invokeEvent(StartEvent);
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      model.currentInput = model.renderable.getInputData();
      publicAPI.invokeEvent(EndEvent);
      if (!model.currentInput) {
        vtkErrorMacro$h('No input!');
        return;
      }

      // if there are no points then we are done
      if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
        return;
      }
      publicAPI.renderPieceStart(ren, actor);
      publicAPI.renderPieceDraw(ren, actor);
      publicAPI.renderPieceFinish(ren, actor);
    };
    publicAPI.renderPieceStart = (ren, actor) => {
      model.primitiveIDOffset = 0;
      if (model._openGLRenderer.getSelector()) {
        switch (model._openGLRenderer.getSelector().getCurrentPass()) {
          default:
            model._openGLRenderer.getSelector().renderProp(actor);
        }
      }
      // make sure the BOs are up to date
      publicAPI.updateBufferObjects(ren, actor);

      // Bind the OpenGL, this is shared between the different primitive/cell types.
      model.lastBoundBO = null;
    };
    publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
      // has something changed that would require us to recreate the shader?
      // candidates are
      // property modified (representation interpolation and lighting)
      // input modified
      // light complexity changed
      if (cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {
        return true;
      }
      return false;
    };
    publicAPI.updateBufferObjects = (ren, actor) => {
      // Rebuild buffers if needed
      if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
        publicAPI.buildBufferObjects(ren, actor);
      }
    };
    publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
      // first do a coarse check
      // Note that the actor's mtime includes it's properties mtime
      const vmtime = model.VBOBuildTime.getMTime();
      if (vmtime < publicAPI.getMTime() || vmtime < model._openGLRenderWindow.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime() || model.renderable.getTransformCoordinate() && vmtime < ren.getMTime()) {
        return true;
      }
      return false;
    };
    publicAPI.buildBufferObjects = (ren, actor) => {
      const poly = model.currentInput;
      if (poly === null) {
        return;
      }
      model.renderable.mapScalars(poly, actor.getProperty().getOpacity());
      const c = model.renderable.getColorMapColors();
      model.haveCellScalars = false;
      const scalarMode = model.renderable.getScalarMode();
      if (model.renderable.getScalarVisibility()) {
        // We must figure out how the scalars should be mapped to the polydata.
        if ((scalarMode === ScalarMode$1.USE_CELL_DATA || scalarMode === ScalarMode$1.USE_CELL_FIELD_DATA || scalarMode === ScalarMode$1.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode$1.USE_POINT_FIELD_DATA && c) {
          model.haveCellScalars = true;
        }
      }
      const representation = actor.getProperty().getRepresentation();
      let tcoords = poly.getPointData().getTCoords();
      if (!model.openGLActor2D.getActiveTextures()) {
        tcoords = null;
      }
      const transformCoordinate = model.renderable.getTransformCoordinate();
      const view = ren.getRenderWindow().getViews()[0];
      const vsize = view.getViewportSize(ren);
      const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}` + `C${c ? c.getMTime() : 1}` + `D${tcoords ? tcoords.getMTime() : 1}` + `E${transformCoordinate ? ren.getMTime() : 1}` + `F${vsize}`;
      if (model.VBOBuildString !== toString) {
        // Build the VBOs
        let points = poly.getPoints();
        if (transformCoordinate) {
          const p = vtkPoints$1.newInstance();
          const numPts = points.getNumberOfPoints();
          p.setNumberOfPoints(numPts);
          const point = [];
          for (let i = 0; i < numPts; ++i) {
            points.getPoint(i, point);
            transformCoordinate.setValue(point);
            const v = transformCoordinate.getComputedDoubleViewportValue(ren);
            p.setPoint(i, v[0], v[1], 0.0);
          }
          points = p;
        }
        const options = {
          points,
          tcoords,
          colors: c,
          cellOffset: 0,
          haveCellScalars: model.haveCellSCalars,
          customAttributes: model.renderable.getCustomShaderAttributes().map(arrayName => poly.getPointData().getArrayByName(arrayName))
        };
        options.cellOffset += model.primitives[primTypes.Points].getCABO().createVBO(poly.getVerts(), 'verts', representation, options);
        options.cellOffset += model.primitives[primTypes.Lines].getCABO().createVBO(poly.getLines(), 'lines', representation, options);
        options.cellOffset += model.primitives[primTypes.Tris].getCABO().createVBO(poly.getPolys(), 'polys', representation, options);
        options.cellOffset += model.primitives[primTypes.TriStrips].getCABO().createVBO(poly.getStrips(), 'strips', representation, options);
        model.VBOBuildTime.modified();
        model.VBOBuildString = toString;
      }
    };
    publicAPI.renderPieceDraw = (ren, actor) => {
      const representation = actor.getProperty().getRepresentation();
      const gl = model.context;
      gl.depthMask(true);

      // for every primitive type
      for (let i = primTypes.Start; i < primTypes.End; i++) {
        // if there are entries
        const cabo = model.primitives[i].getCABO();
        if (cabo.getElementCount()) {
          model.lastBoundBO = model.primitives[i];
          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
        }
      }
    };
    publicAPI.renderPieceFinish = (ren, actor) => {
      if (model.lastBoundBO) {
        model.lastBoundBO.getVAO().release();
      }
    };
    publicAPI.replaceShaderValues = (shaders, ren, actor) => {
      publicAPI.replaceShaderColor(shaders, ren, actor);
      publicAPI.replaceShaderTCoord(shaders, ren, actor);
      publicAPI.replaceShaderPicking(shaders, ren, actor);
      publicAPI.replaceShaderPositionVC(shaders, ren, actor);
    };
    publicAPI.replaceShaderColor = (shaders, ren, actor) => {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      if (model.haveCellScalars) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Color::Dec', ['uniform samplerBuffer texture1;']).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Color::Impl', ['gl_FragData[0] = texelFetchBuffer(texture1, gl_PrimitiveID + PrimitiveIDOffset);']).result;
      }
      if (model.lastBoundBO.getCABO().getColorComponents() !== 0) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::Color::Dec', ['in vec4 diffuseColor;', 'out vec4 fcolorVSOutput;']).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::Color::Impl', ['fcolorVSOutput = diffuseColor;']).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::Color::Dec', ['in vec4 fcolorVSOutput[];\n', 'out vec4 fcolorGSOutput;']).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::Color::Impl', ['fcolorGSOutput = fcolorVSOutput[i];']).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Color::Dec', ['in vec4 fcolorVSOutput;']).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Color::Impl', ['gl_FragData[0] = fcolorVSOutput;']).result;
      } else {
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Color::Dec', ['uniform vec4 diffuseColor;']).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Color::Impl', ['gl_FragData[0] = diffuseColor;']).result;
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    };
    publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
      if (model.lastBoundBO.getCABO().getTCoordOffset()) {
        let VSSource = shaders.Vertex;
        let GSSource = shaders.Geometry;
        let FSSource = shaders.Fragment;
        const tcdim = model.lastBoundBO.getCABO().getTCoordComponents();
        if (tcdim === 1) {
          VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::TCoord::Dec', ['in float tcoordMC;', 'out float tcoordVCVSOutput;']).result;
          VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::TCoord::Impl', ['tcoordVCVSOutput = tcoordMC;']).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::TCoord::Dec', ['in float tcoordVCVSOutput[];\n', 'out float tcoordVCGSOutput;']).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, ['//VTK::TCoord::Impl', 'tcoordVCGSOutput = tcoordVCVSOutput[i];']).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::TCoord::Dec', ['in float tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::TCoord::Impl', ['gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));']).result;
        } else if (tcdim === 2) {
          VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordMC;', 'out vec2 tcoordVCVSOutput;']).result;
          VSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::TCoord::Impl', ['tcoordVCVSOutput = tcoordMC;']).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput[];\n', 'out vec2 tcoordVCGSOutput;']).result;
          GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::TCoord::Impl', ['tcoordVCGSOutput = tcoordVCVSOutput[i];']).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::TCoord::Dec', ['in vec2 tcoordVCVSOutput;', 'uniform sampler2D texture1;']).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::TCoord::Impl', ['gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);']).result;
        }
        if (model.haveCellScalars) {
          GSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::PrimID::Impl', ['gl_PrimitiveID = gl_PrimitiveIDIn;']).result;
        }
        shaders.Vertex = VSSource;
        shaders.Geometry = GSSource;
        shaders.Fragment = FSSource;
      }
    };
    publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
      let FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Picking::Dec', ['uniform vec3 mapperIndex;', 'uniform int picking;']).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, '//VTK::Picking::Impl', '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];').result;
      shaders.Fragment = FSSource;
    };
    publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
      // replace common shader code
      model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
    };
    publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
      const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
      if (listCallbacks) {
        listCallbacks.forEach(object => {
          object.callback(object.userData, cellBO, ren, actor);
        });
      }
    };
    publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
      // Now to update the VAO too, if necessary.
      if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {
        cellBO.getProgram().setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);
      }
      if (cellBO.getProgram().isAttributeUsed('vertexWC')) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'vertexWC', cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro$h('Error setting vertexWC in shader VAO.');
        }
      }
      if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
        model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
          if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
            if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
              vtkErrorMacro$h(`Error setting ${attrName}MC in shader VAO.`);
            }
          }
        });
        if (cellBO.getProgram().isAttributeUsed('tcoordMC') && cellBO.getCABO().getTCoordOffset()) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), 'tcoordMC', cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
            vtkErrorMacro$h('Error setting tcoordMC in shader VAO.');
          }
        } else {
          cellBO.getVAO().removeAttributeArray('tcoordMC');
        }
        if (model.internalColorTexture && cellBO.getProgram().isUniformUsed('texture1')) {
          cellBO.getProgram().setUniformi('texture1', model.internalColorTexture.getTextureUnit());
        }
        const tus = model.openGLActor2D.getActiveTextures();
        if (tus) {
          for (let index = 0; index < tus.length; ++index) {
            const tex = tus[index];
            const texUnit = tex.getTextureUnit();
            const tname = `texture${texUnit + 1}`;
            if (cellBO.getProgram().isUniformUsed(tname)) {
              cellBO.getProgram().setUniformi(tname, texUnit);
            }
          }
        }

        // handle wide lines
        cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
        const selector = model._openGLRenderer.getSelector();
        cellBO.getProgram().setUniform3fArray('mapperIndex', selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]);
        cellBO.getProgram().setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);
      }
    };
    publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
      const c = model.renderable.getColorMapColors();
      if (!c || c.getNumberOfComponents() === 0) {
        const program = cellBO.getProgram();
        const ppty = actor.getProperty();
        const opacity = ppty.getOpacity();
        const dColor = ppty.getColor();
        const diffuseColor = [dColor[0], dColor[1], dColor[2], opacity];
        program.setUniform4f('diffuseColor', diffuseColor);
      }
    };
    publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
      // no-op
    };
    function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
      matrixType.identity(tmpMat);
      return matrixArray.reduce((res, matrix, index) => {
        if (index === 0) {
          return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
        }
        return matrix ? matrixType.multiply(res, res, matrix) : res;
      }, tmpMat);
    }
    publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
      const program = cellBO.getProgram();
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;

      // Get the position of the actor
      const view = ren.getRenderWindow().getViews()[0];
      const size = view.getViewportSize(ren);
      const vport = ren.getViewport();
      const actorPos = actor.getActualPositionCoordinate().getComputedDoubleViewportValue(ren);

      // Get the window info
      // Assume tile viewport is 0 1 based on vtkOpenGLRenderer
      const tileViewport = [0.0, 0.0, 1.0, 1.0];
      const visVP = [0.0, 0.0, 1.0, 1.0];
      visVP[0] = vport[0] >= tileViewport[0] ? vport[0] : tileViewport[0];
      visVP[1] = vport[1] >= tileViewport[1] ? vport[1] : tileViewport[1];
      visVP[2] = vport[2] <= tileViewport[2] ? vport[2] : tileViewport[2];
      visVP[3] = vport[3] <= tileViewport[3] ? vport[3] : tileViewport[3];
      if (visVP[0] >= visVP[2]) {
        return;
      }
      if (visVP[1] >= visVP[3]) {
        return;
      }
      size[0] = round(size[0] * (visVP[2] - visVP[0]) / (vport[2] - vport[0]));
      size[1] = round(size[1] * (visVP[3] - visVP[1]) / (vport[3] - vport[1]));
      const winSize = model._openGLRenderer.getParent().getSize();
      const xoff = round(actorPos[0] - (visVP[0] - vport[0]) * winSize[0]);
      const yoff = round(actorPos[1] - (visVP[1] - vport[1]) * winSize[1]);

      // set ortho projection
      const left = -xoff;
      let right = -xoff + size[0];
      const bottom = -yoff;
      let top = -yoff + size[1];

      // it's an error to call glOrtho with
      // either left==right or top==bottom
      if (left === right) {
        right = left + 1.0;
      }
      if (bottom === top) {
        top = bottom + 1.0;
      }

      // compute the combined ModelView matrix and send it down to save time in the shader
      const tmpMat4 = identity$3(new Float64Array(16));
      tmpMat4[0] = 2.0 / (right - left);
      tmpMat4[1 * 4 + 1] = 2.0 / (top - bottom);
      tmpMat4[0 * 4 + 3] = -1.0 * (right + left) / (right - left);
      tmpMat4[1 * 4 + 3] = -1.0 * (top + bottom) / (top - bottom);
      tmpMat4[2 * 4 + 2] = 0.0;
      tmpMat4[2 * 4 + 3] = actor.getProperty().getDisplayLocation() === DisplayLocation$2.FOREGROUND ? -1.0 : 1.0;
      tmpMat4[3 * 4 + 3] = 1.0;
      transpose(tmpMat4, tmpMat4);
      program.setUniformMatrix('WCVCMatrix', safeMatrixMultiply([tmpMat4, inverseShiftScaleMatrix], mat4, model.tmpMat4));
    };
    publicAPI.getAllocatedGPUMemoryInBytes = () => {
      let memUsed = 0;
      model.primitives.forEach(prim => {
        memUsed += prim.getAllocatedGPUMemoryInBytes();
      });
      // Return in MB
      return memUsed;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$$ = {
    context: null,
    VBOBuildTime: 0,
    VBOBuildString: null,
    primitives: null,
    primTypes: null,
    shaderRebuildString: null
  };

  // ----------------------------------------------------------------------------

  function extend$11(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$$, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
    vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
    model.primitives = [];
    model.primTypes = primTypes;
    model.tmpMat4 = identity$3(new Float64Array(16));
    for (let i = primTypes.Start; i < primTypes.End; i++) {
      model.primitives[i] = vtkHelper.newInstance();
      model.primitives[i].setPrimitiveType(i);
      model.primitives[i].set({
        lastLightComplexity: 0,
        lastLightCount: 0,
        lastSelectionPass: false
      }, true);
    }

    // Build VTK API
    setGet(publicAPI, model, ['context']);
    model.VBOBuildTime = {};
    obj(model.VBOBuildTime, {
      mtime: 0
    });

    // Object methods
    vtkOpenGLPolyDataMapper2D(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$11 = newInstance$1I(extend$11, 'vtkOpenGLPolyDataMapper2D');

  // Register ourself to OpenGL backend if imported
  registerOverride$1('vtkMapper2D', newInstance$11);

  const {
    VectorMode
  } = vtkScalarsToColors$1;

  // ----------------------------------------------------------------------------
  // vtkScalarBarActor
  //
  // Note log scales are currently not supported
  //
  // Developer note: This class is broken into the main class and a helper
  // class. The main class holds view independent properties (those properties
  // that do not change as the view's resolution/aspect ratio change). The
  // helper class is instantiated one per view and holds properties that can
  // depend on view specific values such as resolution. The helper class code
  // could have been left to the View specific implementation (such as
  // vtkWebGPUScalarBarActor) but is instead placed here to it can be shared by
  // multiple rendering backends.
  //
  // ----------------------------------------------------------------------------

  function applyTextStyle(ctx, style) {
    ctx.strokeStyle = style.strokeColor;
    ctx.lineWidth = style.strokeSize;
    ctx.fillStyle = style.fontColor;
    ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;
  }

  // ----------------------------------------------------------------------------
  // Default autoLayout function
  // ----------------------------------------------------------------------------

  // compute good values to use based on window size etc a bunch of heuristics
  // here with hand tuned constants These values worked for me but really this
  // method could be redically changed. The basic gist is
  // 1) compute a resonable font size
  // 2) render the text atlas using those font sizes
  // 3) pick horizontal or vertical bsed on window size
  // 4) based on the size of the title and tick labels rendered
  //    compute the box size and position such that
  //    the text will all fit nicely and the bar will be a resonable size
  // 5) compute the bar segments based on the above settings
  //
  // Note that this function can and should read values from the
  // ScalarBarActor but should only write values to the view dependent helper
  // instance that is provided as those values are the ones that will be used
  // for rendering.
  //
  function defaultAutoLayout(publicAPI, model) {
    return helper => {
      // we don't do a linear scale, the proportions for
      // a 700 pixel window differ from a 1400
      const lastSize = helper.getLastSize();
      const xAxisAdjust = (lastSize[0] / 700) ** 0.8;
      const yAxisAdjust = (lastSize[1] / 700) ** 0.8;
      const minAdjust = Math.min(xAxisAdjust, yAxisAdjust);
      const axisTextStyle = helper.getAxisTextStyle();
      const tickTextStyle = helper.getTickTextStyle();
      Object.assign(axisTextStyle, model.axisTextStyle);
      Object.assign(tickTextStyle, model.tickTextStyle);

      // compute a reasonable font size first
      axisTextStyle.fontSize = Math.max(24 * minAdjust, 12);
      if (helper.getLastAspectRatio() > 1.0) {
        tickTextStyle.fontSize = Math.max(20 * minAdjust, 10);
      } else {
        tickTextStyle.fontSize = Math.max(16 * minAdjust, 10);
      }

      // rebuild the text atlas
      const textSizes = helper.updateTextureAtlas();

      // now compute the boxSize and pixel offsets, different algorithm
      // for horizonal versus vertical
      helper.setTopTitle(false);
      const boxSize = helper.getBoxSizeByReference();

      // if vertical
      if (helper.getLastAspectRatio() > 1.0) {
        helper.setTickLabelPixelOffset(0.3 * tickTextStyle.fontSize);

        // if the title will fit within the width of the bar then that looks
        // nicer to put it at the top (helper.topTitle), otherwise rotate it
        // and place it sideways
        if (textSizes.titleWidth <= textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) {
          helper.setTopTitle(true);
          helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);
          boxSize[0] = 2.0 * (textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];
          helper.setBoxPosition([0.98 - boxSize[0], -0.92]);
        } else {
          helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);
          boxSize[0] = 2.0 * (textSizes.titleHeight + helper.getAxisTitlePixelOffset() + textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];
          helper.setBoxPosition([0.99 - boxSize[0], -0.92]);
        }
        boxSize[1] = Math.max(1.2, Math.min(1.84 / yAxisAdjust, 1.84));
      } else {
        // horizontal
        helper.setAxisTitlePixelOffset(1.2 * tickTextStyle.fontSize);
        helper.setTickLabelPixelOffset(0.1 * tickTextStyle.fontSize);
        const titleHeight =
        // total offset from top of bar (includes ticks)
        2.0 * (0.8 * tickTextStyle.fontSize + textSizes.titleHeight + helper.getAxisTitlePixelOffset()) / lastSize[1];
        const tickWidth = 2.0 * textSizes.tickWidth / lastSize[0];
        boxSize[0] = Math.min(1.9, Math.max(1.4, 1.4 * tickWidth * (helper.getTicks().length + 3)));
        boxSize[1] = titleHeight;
        helper.setBoxPosition([-0.5 * boxSize[0], -0.97]);
      }

      // recomute bar segments based on positioning
      helper.recomputeBarSegments(textSizes);
    };
  }

  // ----------------------------------------------------------------------------
  // Default generateTicks function
  // ----------------------------------------------------------------------------

  // This function returns the default function used to generate vtkScalarBarActor ticks.
  // The default function makes use of d3.scaleLinear() to generate 5 tick marks between
  // the minimum and maximum values of the scalar bar. Customize this behavior by passing
  // a function to vtkScalarBarActor.newInstance({ generateTicks: customGenerateTicks })
  // or by calling scalarBarActor.setGenerateTicks(customGenerateTicks).
  function defaultGenerateTicks(publicApi, model) {
    return helper => {
      const lastTickBounds = helper.getLastTickBounds();
      const scale = linear().domain([lastTickBounds[0], lastTickBounds[1]]);
      const ticks = scale.ticks(5);
      const format = scale.tickFormat(5);
      helper.setTicks(ticks);
      helper.setTickStrings(ticks.map(format));
    };
  }

  // many properties of this actor depend on the API specific view The main
  // dependency being the resolution as that drives what font sizes to use.
  // Bacause of this we need to do some of the calculations in a API specific
  // subclass. But... we don't want a lot of duplicated code between WebGL and
  // WebGPU for example so we have this helper class, that is designed to be
  // fairly API independent so that API specific views can call this to do
  // most of the work.
  function vtkScalarBarActorHelper(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkScalarBarActorHelper');
    publicAPI.setRenderable = renderable => {
      if (model.renderable === renderable) {
        return;
      }
      model.renderable = renderable;
      model.barActor.setProperty(renderable.getProperty());
      model.barActor.setParentProp(renderable);
      model.barActor.setCoordinateSystemToDisplay();
      model.tmActor.setProperty(renderable.getProperty());
      model.tmActor.setParentProp(renderable);
      model.tmActor.setCoordinateSystemToDisplay();
      model.generateTicks = renderable.generateTicks;
      model.axisTextStyle = {
        ...renderable.getAxisTextStyle()
      };
      model.tickTextStyle = {
        ...renderable.getTickTextStyle()
      };
      publicAPI.modified();
    };
    publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {
      // has the size changed?
      if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {
        model.lastSize[0] = size[0];
        model.lastSize[1] = size[1];
        model.lastAspectRatio = size[0] / size[1];
        model.forceUpdate = true;
      }
      const scalarsToColors = model.renderable.getScalarsToColors();
      if (!scalarsToColors || !model.renderable.getVisibility()) {
        return;
      }

      // make sure the lut is assigned to our mapper
      model.barMapper.setLookupTable(scalarsToColors);

      // camera should be the same for all views
      model.camera = camera;
      model.renderWindow = renderWindow;

      // did something significant change? If so rebuild a lot of things
      if (model.forceUpdate || Math.max(scalarsToColors.getMTime(), publicAPI.getMTime(), model.renderable.getMTime()) > model.lastRebuildTime.getMTime()) {
        const range = scalarsToColors.getMappingRange();
        model.lastTickBounds = [...range];

        // compute tick marks for axes (update for log scale)
        model.renderable.getGenerateTicks()(publicAPI);
        if (model.renderable.getAutomated()) {
          model.renderable.getAutoLayout()(publicAPI);
        } else {
          // copy values from renderable
          model.axisTextStyle = {
            ...model.renderable.getAxisTextStyle()
          };
          model.tickTextStyle = {
            ...model.renderable.getTickTextStyle()
          };
          model.barPosition = [...model.renderable.getBarPosition()];
          model.barSize = [...model.renderable.getBarSize()];
          model.boxPosition = [...model.renderable.getBoxPosition()];
          model.boxSize = [...model.renderable.getBoxSize()];
          model.axisTitlePixelOffset = model.renderable.getAxisTitlePixelOffset();
          model.tickLabelPixelOffset = model.renderable.getTickLabelPixelOffset();

          // rebuild the texture only when force or changed bounds, face
          // visibility changes do to change the atlas
          const textSizes = publicAPI.updateTextureAtlas();

          // recompute bar segments based on positioning
          publicAPI.recomputeBarSegments(textSizes);
        }
        publicAPI.updatePolyDataForLabels();
        publicAPI.updatePolyDataForBarSegments();
        model.lastRebuildTime.modified();
        model.forceUpdate = false;
      }
    };

    // create the texture map atlas that contains the rendering of
    // all the text strings. Only needs to be called when the text strings
    // have changed (labels and ticks)
    publicAPI.updateTextureAtlas = () => {
      // set the text properties
      model.tmContext.textBaseline = 'bottom';
      model.tmContext.textAlign = 'left';

      // return some factors about the text atlas
      const results = {};

      // first the axislabel
      const newTmAtlas = new Map();
      let maxWidth = 0;
      let totalHeight = 1; // start one pixel in so we have a border
      applyTextStyle(model.tmContext, model.axisTextStyle);
      let metrics = model.tmContext.measureText(model.renderable.getAxisLabel());
      let entry = {
        height: metrics.actualBoundingBoxAscent + 2,
        startingHeight: totalHeight,
        width: metrics.width + 2,
        textStyle: model.axisTextStyle
      };
      newTmAtlas.set(model.renderable.getAxisLabel(), entry);
      totalHeight += entry.height;
      maxWidth = entry.width;
      results.titleWidth = entry.width;
      results.titleHeight = entry.height;

      // and the ticks, NaN Below and Above
      results.tickWidth = 0;
      results.tickHeight = 0;
      applyTextStyle(model.tmContext, model.tickTextStyle);
      const strings = [...publicAPI.getTickStrings(), 'NaN', 'Below', 'Above'];
      for (let t = 0; t < strings.length; t++) {
        if (!newTmAtlas.has(strings[t])) {
          metrics = model.tmContext.measureText(strings[t]);
          entry = {
            height: metrics.actualBoundingBoxAscent + 2,
            startingHeight: totalHeight,
            width: metrics.width + 2,
            textStyle: model.tickTextStyle
          };
          newTmAtlas.set(strings[t], entry);
          totalHeight += entry.height;
          if (maxWidth < entry.width) {
            maxWidth = entry.width;
          }
          if (results.tickWidth < entry.width) {
            results.tickWidth = entry.width;
          }
          if (results.tickHeight < entry.height) {
            results.tickHeight = entry.height;
          }
        }
      }

      // always use power of two to avoid interpolation
      // in cases where PO2 is required
      maxWidth = nearestPowerOfTwo(maxWidth);
      totalHeight = nearestPowerOfTwo(totalHeight);

      // set the tcoord values
      newTmAtlas.forEach(value => {
        value.tcoords = [0.0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0.0, (totalHeight - value.startingHeight) / totalHeight];
      });

      // make sure we have power of two dimensions
      model.tmCanvas.width = maxWidth;
      model.tmCanvas.height = totalHeight;
      model.tmContext.textBaseline = 'bottom';
      model.tmContext.textAlign = 'left';
      model.tmContext.clearRect(0, 0, maxWidth, totalHeight);

      // draw the text onto the texture
      newTmAtlas.forEach((value, key) => {
        applyTextStyle(model.tmContext, value.textStyle);
        model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);
      });
      model.tmTexture.setCanvas(model.tmCanvas);
      // mark as modified since the canvas typically doesn't change
      model.tmTexture.modified();
      model._tmAtlas = newTmAtlas;
      return results;
    };
    publicAPI.computeBarSize = textSizes => {
      // compute orientation
      model.vertical = model.boxSize[1] > model.boxSize[0];
      const tickHeight = 2.0 * textSizes.tickHeight / model.lastSize[1];
      const segSize = [1, 1];

      // horizontal and vertical have different astetics so adjust based on
      // orientation
      if (model.vertical) {
        const tickWidth = 2.0 * (textSizes.tickWidth + model.tickLabelPixelOffset) / model.lastSize[0];
        if (model.topTitle) {
          const titleHeight = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];
          model.barSize[0] = model.boxSize[0] - tickWidth;
          model.barSize[1] = model.boxSize[1] - titleHeight;
        } else {
          // rotated title so width is based off height
          const titleWidth = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[0];
          model.barSize[0] = model.boxSize[0] - titleWidth - tickWidth;
          model.barSize[1] = model.boxSize[1];
        }
        model.barPosition[0] = model.boxPosition[0] + tickWidth;
        model.barPosition[1] = model.boxPosition[1];
        segSize[1] = tickHeight;
      } else {
        const tickWidth = (2.0 * textSizes.tickWidth - 8) / model.lastSize[0];
        const titleHeight = 2.0 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];
        model.barSize[0] = model.boxSize[0];
        model.barPosition[0] = model.boxPosition[0];
        model.barSize[1] = model.boxSize[1] - titleHeight;
        model.barPosition[1] = model.boxPosition[1];
        segSize[0] = tickWidth;
      }
      return segSize;
    };

    // based on all the settins compute a barSegments array
    // containing the segments of the scalar bar
    // each segment contains
    //   corners[4][2]
    //   title - e.g. NaN, Above, ticks
    //   scalars - the normalized scalars values to use for that segment
    //
    // Note that the bar consumes the space in the box that remains after
    // leaving room for the text labels
    publicAPI.recomputeBarSegments = textSizes => {
      // first compute the barSize/Position
      const segSize = publicAPI.computeBarSize(textSizes);
      model.barSegments = [];
      const startPos = [0.0, 0.0];

      // horizontal and vertical have different astetics so adjust based on
      // orientation
      const barAxis = model.vertical ? 1 : 0;
      const segSpace = model.vertical ? 0.01 : 0.02;
      function pushSeg(title, scalars) {
        model.barSegments.push({
          corners: [[...startPos], [startPos[0] + segSize[0], startPos[1]], [startPos[0] + segSize[0], startPos[1] + segSize[1]], [startPos[0], startPos[1] + segSize[1]]],
          scalars,
          title
        });
        startPos[barAxis] += segSize[barAxis] + segSpace;
      }
      if (model.renderable.getDrawNanAnnotation() && model.renderable.getScalarsToColors().getNanColor()) {
        pushSeg('NaN', [NaN, NaN, NaN, NaN]);
      }
      if (model.renderable.getDrawBelowRangeSwatch() && model.renderable.getScalarsToColors().getUseBelowRangeColor?.()) {
        pushSeg('Below', [-0.1, -0.1, -0.1, -0.1]);
      }
      const haveAbove = model.renderable.getScalarsToColors().getUseAboveRangeColor?.();

      // extra space around the ticks section
      startPos[barAxis] += segSpace;
      const oldSegSize = segSize[barAxis];
      segSize[barAxis] = haveAbove ? 1.0 - 2.0 * segSpace - segSize[barAxis] - startPos[barAxis] : 1.0 - segSpace - startPos[barAxis];
      pushSeg('ticks', model.vertical ? [0, 0, 0.995, 0.995] : [0, 0.995, 0.995, 0]);
      if (model.renderable.getDrawAboveRangeSwatch() && haveAbove) {
        segSize[barAxis] = oldSegSize;
        startPos[barAxis] += segSpace;
        pushSeg('Above', [1.1, 1.1, 1.1, 1.1]);
      }
    };

    // called by updatePolyDataForLabels
    // modifies class constants tmp2v3
    const tmp2v3 = new Float64Array(3);

    // anchor point = pos
    // H alignment = left, middle, right
    // V alignment = bottom, middle, top
    // Text Orientation = horizontal, vertical
    // orientation
    publicAPI.createPolyDataForOneLabel = (text, pos, alignment, orientation, offset, results) => {
      const value = model._tmAtlas.get(text);
      if (!value) {
        return;
      }
      // have to find the four corners of the texture polygon for this label
      let ptIdx = results.ptIdx;
      let cellIdx = results.cellIdx;

      // get achor point in pixels
      tmp2v3[0] = (0.5 * pos[0] + 0.5) * model.lastSize[0];
      tmp2v3[1] = (0.5 * pos[1] + 0.5) * model.lastSize[1];
      tmp2v3[2] = pos[2];
      tmp2v3[0] += offset[0];
      tmp2v3[1] += offset[1];

      // get text size in display pixels
      const textSize = [];
      const textAxes = orientation === 'vertical' ? [1, 0] : [0, 1];
      if (orientation === 'vertical') {
        textSize[0] = value.width;
        textSize[1] = -value.height;
        // update anchor point based on alignment
        if (alignment[0] === 'middle') {
          tmp2v3[1] -= value.width / 2.0;
        } else if (alignment[0] === 'right') {
          tmp2v3[1] -= value.width;
        }
        if (alignment[1] === 'middle') {
          tmp2v3[0] += value.height / 2.0;
        } else if (alignment[1] === 'top') {
          tmp2v3[0] += value.height;
        }
      } else {
        textSize[0] = value.width;
        textSize[1] = value.height;
        // update anchor point based on alignment
        if (alignment[0] === 'middle') {
          tmp2v3[0] -= value.width / 2.0;
        } else if (alignment[0] === 'right') {
          tmp2v3[0] -= value.width;
        }
        if (alignment[1] === 'middle') {
          tmp2v3[1] -= value.height / 2.0;
        } else if (alignment[1] === 'top') {
          tmp2v3[1] -= value.height;
        }
      }
      results.points[ptIdx * 3] = tmp2v3[0];
      results.points[ptIdx * 3 + 1] = tmp2v3[1];
      results.points[ptIdx * 3 + 2] = tmp2v3[2];
      results.tcoords[ptIdx * 2] = value.tcoords[0];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];
      ptIdx++;
      tmp2v3[textAxes[0]] += textSize[0];
      results.points[ptIdx * 3] = tmp2v3[0];
      results.points[ptIdx * 3 + 1] = tmp2v3[1];
      results.points[ptIdx * 3 + 2] = tmp2v3[2];
      results.tcoords[ptIdx * 2] = value.tcoords[2];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];
      ptIdx++;
      tmp2v3[textAxes[1]] += textSize[1];
      results.points[ptIdx * 3] = tmp2v3[0];
      results.points[ptIdx * 3 + 1] = tmp2v3[1];
      results.points[ptIdx * 3 + 2] = tmp2v3[2];
      results.tcoords[ptIdx * 2] = value.tcoords[4];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];
      ptIdx++;
      tmp2v3[textAxes[0]] -= textSize[0];
      results.points[ptIdx * 3] = tmp2v3[0];
      results.points[ptIdx * 3 + 1] = tmp2v3[1];
      results.points[ptIdx * 3 + 2] = tmp2v3[2];
      results.tcoords[ptIdx * 2] = value.tcoords[6];
      results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];
      ptIdx++;

      // add the two triangles to represent the quad
      results.polys[cellIdx * 4] = 3;
      results.polys[cellIdx * 4 + 1] = ptIdx - 4;
      results.polys[cellIdx * 4 + 2] = ptIdx - 3;
      results.polys[cellIdx * 4 + 3] = ptIdx - 2;
      cellIdx++;
      results.polys[cellIdx * 4] = 3;
      results.polys[cellIdx * 4 + 1] = ptIdx - 4;
      results.polys[cellIdx * 4 + 2] = ptIdx - 2;
      results.polys[cellIdx * 4 + 3] = ptIdx - 1;
      results.ptIdx += 4;
      results.cellIdx += 2;
    };

    // update the polydata associated with drawing the text labels
    // specifically the quads used for each label and their associated tcoords
    // etc. This changes every time the camera viewpoint changes
    const tmpv3 = new Float64Array(3);
    publicAPI.updatePolyDataForLabels = () => {
      // update the polydata
      const numLabels = publicAPI.getTickStrings().length + model.barSegments.length;
      const numPts = numLabels * 4;
      const numTris = numLabels * 2;
      const points = new Float64Array(numPts * 3);
      const polys = new Uint16Array(numTris * 4);
      const tcoords = new Float32Array(numPts * 2);
      const results = {
        ptIdx: 0,
        cellIdx: 0,
        polys,
        points,
        tcoords
      };

      // compute the direction vector
      const offsetAxis = model.vertical ? 0 : 1;
      const spacedAxis = model.vertical ? 1 : 0;
      tmpv3[2] = -0.99; // near plane

      // draw the title
      const alignment = model.vertical ? ['right', 'middle'] : ['middle', 'bottom'];
      let dir = [0, 1];
      const tickOffsets = [0, 0];
      if (model.vertical) {
        tickOffsets[0] = -model.tickLabelPixelOffset;
        if (model.topTitle) {
          tmpv3[0] = model.boxPosition[0] + 0.5 * model.boxSize[0];
          tmpv3[1] = model.barPosition[1] + model.barSize[1];

          // write the axis label
          publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'bottom'], 'horizontal', [0, model.axisTitlePixelOffset], results);
        } else {
          tmpv3[0] = model.barPosition[0] + model.barSize[0];
          tmpv3[1] = model.barPosition[1] + 0.5 * model.barSize[1];

          // write the axis label
          publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'top'], 'vertical', [model.axisTitlePixelOffset, 0], results);
        }
        dir = [-1, 0];
      } else {
        tickOffsets[1] = model.tickLabelPixelOffset;
        tmpv3[0] = model.barPosition[0] + 0.5 * model.barSize[0];
        tmpv3[1] = model.barPosition[1] + model.barSize[1];
        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv3, ['middle', 'bottom'], 'horizontal', [0, model.axisTitlePixelOffset], results);
      }
      tmpv3[offsetAxis] = model.barPosition[offsetAxis] + (0.5 * dir[offsetAxis] + 0.5) * model.barSize[offsetAxis];
      tmpv3[spacedAxis] = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * 0.5;

      // draw bar segment labels
      let tickSeg = null;
      for (let i = 0; i < model.barSegments.length; i++) {
        const seg = model.barSegments[i];
        if (seg.title === 'ticks') {
          // handle ticks below
          tickSeg = seg;
        } else {
          tmpv3[spacedAxis] = model.barPosition[spacedAxis] + 0.5 * model.barSize[spacedAxis] * (seg.corners[2][spacedAxis] + seg.corners[0][spacedAxis]);
          publicAPI.createPolyDataForOneLabel(seg.title, tmpv3, alignment, 'horizontal', tickOffsets, results);
        }
      }

      // write the tick labels
      const tickSegmentStart = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * tickSeg.corners[0][spacedAxis];
      const tickSegmentSize = model.barSize[spacedAxis] * (tickSeg.corners[2][spacedAxis] - tickSeg.corners[0][spacedAxis]);
      const ticks = publicAPI.getTicks();
      const tickStrings = publicAPI.getTickStrings();
      for (let t = 0; t < ticks.length; t++) {
        const tickPos = (ticks[t] - model.lastTickBounds[0]) / (model.lastTickBounds[1] - model.lastTickBounds[0]);
        tmpv3[spacedAxis] = tickSegmentStart + tickSegmentSize * tickPos;
        publicAPI.createPolyDataForOneLabel(tickStrings[t], tmpv3, alignment, 'horizontal', tickOffsets, results);
      }
      const tcoordDA = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcoords,
        name: 'TextureCoordinates'
      });
      model.tmPolyData.getPointData().setTCoords(tcoordDA);
      model.tmPolyData.getPoints().setData(points, 3);
      model.tmPolyData.getPoints().modified();
      model.tmPolyData.getPolys().setData(polys, 1);
      model.tmPolyData.getPolys().modified();
      model.tmPolyData.modified();
    };
    publicAPI.updatePolyDataForBarSegments = () => {
      const scalarsToColors = model.renderable.getScalarsToColors();
      let numberOfExtraColors = 0;
      if (model.renderable.getDrawNanAnnotation() && scalarsToColors.getNanColor()) {
        numberOfExtraColors += 1;
      }
      if (model.renderable.getDrawBelowRangeSwatch() && scalarsToColors.getUseBelowRangeColor?.()) {
        numberOfExtraColors += 1;
      }
      if (model.renderable.getDrawAboveRangeSwatch() && scalarsToColors.getUseAboveRangeColor?.()) {
        numberOfExtraColors += 1;
      }
      const numPts = 4 * (1 + numberOfExtraColors);
      const numQuads = numPts;

      // handle vector component mode
      let numComps = 1;
      if (scalarsToColors.getVectorMode() === VectorMode.COMPONENT) {
        numComps = scalarsToColors.getVectorComponent() + 1;
      }

      // create the colored bars
      const points = new Float64Array(numPts * 3);
      const cells = new Uint16Array(numQuads * 5);
      const scalars = new Float32Array(numPts * numComps);
      let ptIdx = 0;
      let cellIdx = 0;
      for (let i = 0; i < model.barSegments.length; i++) {
        const seg = model.barSegments[i];
        for (let e = 0; e < 4; e++) {
          tmpv3[0] = model.barPosition[0] + seg.corners[e][0] * model.barSize[0];
          tmpv3[1] = model.barPosition[1] + seg.corners[e][1] * model.barSize[1];
          points[ptIdx * 3] = (0.5 * tmpv3[0] + 0.5) * model.lastSize[0];
          points[ptIdx * 3 + 1] = (0.5 * tmpv3[1] + 0.5) * model.lastSize[1];
          points[ptIdx * 3 + 2] = tmpv3[2];
          for (let nc = 0; nc < numComps; nc++) {
            scalars[ptIdx * numComps + nc] = model.lastTickBounds[0] + seg.scalars[e] * (model.lastTickBounds[1] - model.lastTickBounds[0]);
          }
          ptIdx++;
        }
        cells[cellIdx * 5] = 4;
        cells[cellIdx * 5 + 1] = ptIdx - 4;
        cells[cellIdx * 5 + 2] = ptIdx - 3;
        cells[cellIdx * 5 + 3] = ptIdx - 2;
        cells[cellIdx * 5 + 4] = ptIdx - 1;
        cellIdx++;
      }
      const scalarsDA = vtkDataArray$1.newInstance({
        numberOfComponents: numComps,
        values: scalars,
        name: 'Scalars'
      });
      model.polyData.getPointData().setScalars(scalarsDA);
      model.polyData.getPoints().setData(points, 3);
      model.polyData.getPoints().modified();
      model.polyData.getPolys().setData(cells, 1);
      model.polyData.getPolys().modified();
      model.polyData.modified();
    };
  }
  const newScalarBarActorHelper = macro.newInstance(function (publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      renderable: null
    };
    Object.assign(model, {}, initialValues);

    // Inheritance
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ['axisTitlePixelOffset', 'tickLabelPixelOffset', 'renderable', 'topTitle', 'ticks', 'tickStrings']);
    macro.get(publicAPI, model, ['lastSize', 'lastAspectRatio', 'lastTickBounds', 'axisTextStyle', 'tickTextStyle', 'barActor', 'tmActor']);
    macro.getArray(publicAPI, model, ['boxPosition', 'boxSize']);
    macro.setArray(publicAPI, model, ['boxPosition', 'boxSize'], 2);
    model.forceUpdate = false;
    model.lastRebuildTime = {};
    macro.obj(model.lastRebuildTime, {
      mtime: 0
    });
    model.lastSize = [-1, -1];
    model.tmCanvas = document.createElement('canvas');
    model.tmContext = model.tmCanvas.getContext('2d');
    model._tmAtlas = new Map();
    model.barMapper = vtkMapper$1.newInstance();
    model.barMapper.setInterpolateScalarsBeforeMapping(true);
    model.barMapper.setUseLookupTableScalarRange(true);
    model.polyData = vtkPolyData$1.newInstance();
    model.barMapper.setInputData(model.polyData);
    model.barActor = vtkActor$1.newInstance();
    model.barActor.setMapper(model.barMapper);

    // for texture atlas
    model.tmPolyData = vtkPolyData$1.newInstance();
    model.tmMapper = vtkMapper$1.newInstance();
    model.tmMapper.setInputData(model.tmPolyData);
    model.tmTexture = vtkTexture$1.newInstance({
      resizable: true
    });
    model.tmTexture.setInterpolate(false);
    model.tmActor = vtkActor$1.newInstance({
      parentProp: publicAPI
    });
    model.tmActor.setMapper(model.tmMapper);
    model.tmActor.addTexture(model.tmTexture);
    model.barPosition = [0, 0];
    model.barSize = [0, 0];
    model.boxPosition = [0.88, -0.92];
    model.boxSize = [0.1, 1.1];

    // internal variables
    model.lastTickBounds = [];
    vtkScalarBarActorHelper(publicAPI, model);
  }, 'vtkScalarBarActorHelper');

  //
  // Now we define the public class that the application sets view independent
  // properties on. This class is fairly small as it mainly just holds
  // properties setter and getters leaving all calculations to the helper
  // class.
  //
  function vtkScalarBarActor(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkScalarBarActor');
    publicAPI.setTickTextStyle = tickStyle => {
      model.tickTextStyle = {
        ...model.tickTextStyle,
        ...tickStyle
      };
      publicAPI.modified();
    };
    publicAPI.setAxisTextStyle = axisStyle => {
      model.axisTextStyle = {
        ...model.axisTextStyle,
        ...axisStyle
      };
      publicAPI.modified();
    };
    publicAPI.resetAutoLayoutToDefault = () => {
      publicAPI.setAutoLayout(defaultAutoLayout(publicAPI, model));
    };
    publicAPI.resetGenerateTicksToDefault = () => {
      publicAPI.setGenerateTicks(defaultGenerateTicks());
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  function defaultValues$1(initialValues) {
    return {
      automated: true,
      autoLayout: null,
      axisLabel: 'Scalar Value',
      barPosition: [0, 0],
      barSize: [0, 0],
      boxPosition: [0.88, -0.92],
      boxSize: [0.1, 1.1],
      scalarToColors: null,
      axisTitlePixelOffset: 36.0,
      axisTextStyle: {
        fontColor: 'white',
        fontStyle: 'normal',
        fontSize: 18,
        fontFamily: 'serif'
      },
      tickLabelPixelOffset: 14.0,
      tickTextStyle: {
        fontColor: 'white',
        fontStyle: 'normal',
        fontSize: 14,
        fontFamily: 'serif'
      },
      generateTicks: null,
      drawNanAnnotation: true,
      drawBelowRangeSwatch: true,
      drawAboveRangeSwatch: true,
      ...initialValues
    };
  }

  // ----------------------------------------------------------------------------

  function extend$10(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, defaultValues$1(initialValues));
    if (!model.autoLayout) model.autoLayout = defaultAutoLayout(publicAPI, model);
    if (!model.generateTicks) model.generateTicks = defaultGenerateTicks();

    // Inheritance
    vtkActor$1.extend(publicAPI, model, initialValues);
    publicAPI.getProperty().setDiffuse(0.0);
    publicAPI.getProperty().setAmbient(1.0);
    macro.setGet(publicAPI, model, ['automated', 'autoLayout', 'axisTitlePixelOffset', 'axisLabel', 'scalarsToColors', 'tickLabelPixelOffset', 'generateTicks', 'drawNanAnnotation', 'drawBelowRangeSwatch', 'drawAboveRangeSwatch']);
    macro.get(publicAPI, model, ['axisTextStyle', 'tickTextStyle']);
    macro.getArray(publicAPI, model, ['barPosition', 'barSize', 'boxPosition', 'boxSize']);
    macro.setArray(publicAPI, model, ['barPosition', 'barSize', 'boxPosition', 'boxSize'], 2);

    // Object methods
    vtkScalarBarActor(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$10 = macro.newInstance(extend$10, 'vtkScalarBarActor');

  // ----------------------------------------------------------------------------

  var vtkScalarBarActor$1 = {
    newInstance: newInstance$10,
    extend: extend$10,
    newScalarBarActorHelper
  };

  // ----------------------------------------------------------------------------
  // vtkOpenGLScalarBarActor methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLScalarBarActor(publicAPI, model) {
    model.classHierarchy.push('vtkOpenGLScalarBarActor');

    // Builds myself.
    publicAPI.buildPass = prepass => {
      if (prepass) {
        model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
        model._openGLRenderWindow = model._openGLRenderer.getParent();
        if (!model.scalarBarActorHelper.getRenderable()) {
          model.scalarBarActorHelper.setRenderable(model.renderable);
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
        publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
        publicAPI.removeUnusedNodes();
      }
    };
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass) {
        const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
        const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
        model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$_ = {};

  // ----------------------------------------------------------------------------

  function extend$$(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$_, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();

    // Object methods
    vtkOpenGLScalarBarActor(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$$ = newInstance$1I(extend$$, 'vtkOpenGLScalarBarActor');

  // Register ourself to OpenGL backend if imported
  registerOverride$1('vtkScalarBarActor', newInstance$$);

  const {
    vtkErrorMacro: vtkErrorMacro$g
  } = macro$1;

  // ----------------------------------------------------------------------------
  // vtkOpenGLSkybox methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLSkybox(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLSkybox');

    // Builds myself.
    publicAPI.buildPass = prepass => {
      if (prepass) {
        model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
        model._openGLRenderWindow = model._openGLRenderer.getParent();
        model.context = model._openGLRenderWindow.getContext();
        model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
        const ren = model._openGLRenderer.getRenderable();
        model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      }
    };
    publicAPI.queryPass = (prepass, renderPass) => {
      if (prepass) {
        if (!model.renderable || !model.renderable.getVisibility()) {
          return;
        }
        renderPass.incrementOpaqueActorCount();
      }
    };
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass && !model._openGLRenderer.getSelector()) {
        publicAPI.updateBufferObjects();
        model.context.depthMask(true);
        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.tris.getProgram());
        model.openGLTexture.render(model._openGLRenderWindow);
        const texUnit = model.openGLTexture.getTextureUnit();
        model.tris.getProgram().setUniformi('sbtexture', texUnit);
        const ren = model._openGLRenderer.getRenderable();
        const keyMats = model.openGLCamera.getKeyMatrices(ren);
        const imat = new Float64Array(16);
        invert(imat, keyMats.wcpc);
        model.tris.getProgram().setUniformMatrix('IMCPCMatrix', imat);
        if (model.lastFormat === 'box') {
          const camPos = ren.getActiveCamera().getPosition();
          model.tris.getProgram().setUniform3f('camPos', camPos[0], camPos[1], camPos[2]);
        }
        model.tris.getVAO().bind();

        // draw polygons
        model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
        model.tris.getVAO().release();
        model.openGLTexture.deactivate();
      }
    };
    publicAPI.updateBufferObjects = () => {
      // build the VBO if needed, only happens once
      if (!model.tris.getCABO().getElementCount()) {
        const ptsArray = new Float32Array(12);
        for (let i = 0; i < 4; i++) {
          ptsArray[i * 3] = i % 2 * 2 - 1.0;
          ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;
          ptsArray[i * 3 + 2] = 1.0;
        }
        const points = vtkDataArray$1.newInstance({
          numberOfComponents: 3,
          values: ptsArray
        });
        points.setName('points');
        const cellArray = new Uint16Array(8);
        cellArray[0] = 3;
        cellArray[1] = 0;
        cellArray[2] = 1;
        cellArray[3] = 3;
        cellArray[4] = 3;
        cellArray[5] = 0;
        cellArray[6] = 3;
        cellArray[7] = 2;
        const cells = vtkDataArray$1.newInstance({
          numberOfComponents: 1,
          values: cellArray
        });
        model.tris.getCABO().createVBO(cells, 'polys', Representation$6.SURFACE, {
          points,
          cellOffset: 0
        });
      }

      // update the program?
      if (model.renderable.getFormat() !== model.lastFormat) {
        model.lastFormat = model.renderable.getFormat();
        if (model.lastFormat === 'box') {
          // we invert Y below because opengl is messed up!
          // Cube Maps have been specified to follow the RenderMan
          // specification (for whatever reason), and RenderMan
          // assumes the images' origin being in the upper left,
          // contrary to the usual OpenGL behaviour of having the
          // image origin in the lower left. That's why things get
          // swapped in the Y direction. It totally breaks with the usual
          // OpenGL semantics and doesn't make sense at all.
          // But now we're stuck with it.  From
          // https://stackoverflow.com/questions/11685608/convention-of-faces-in-opengl-cubemapping
          //
          model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec3 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = wpos.xyz/wpos.w;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec3 TexCoords;
             uniform samplerCube sbtexture;
             uniform vec3 camPos;
             void main () {
               // skybox looks from inside out
               // which means we have to adjust
               // our tcoords. Otherwise text would
               // be flipped
               vec3 tc = normalize(TexCoords - camPos);
               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))
               {
                 tc = vec3(1.0, 1.0, -1.0) * tc;
               }
               else
               {
                 tc = vec3(-1.0, 1.0, 1.0) * tc;
               }
               gl_FragData[0] = textureCube(sbtexture, tc);
             }`, ''));
        }
        if (model.lastFormat === 'background') {
          // maps the texture to the window
          model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec2 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec2 TexCoords;
             uniform sampler2D sbtexture;
             void main () {
               gl_FragData[0] = texture2D(sbtexture, TexCoords);
             }`, ''));
        }
        model.tris.getShaderSourceTime().modified();
        model.tris.getVAO().bind();
        if (!model.tris.getVAO().addAttributeArray(model.tris.getProgram(), model.tris.getCABO(), 'vertexMC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro$g('Error setting vertexMC in shader VAO.');
        }
      }

      // set/update the texture map if needed
      const tmaps = model.renderable.getTextures();
      if (!tmaps.length) {
        vtkErrorMacro$g('vtkSkybox requires a texture map');
      }
      if (model.openGLTexture.getRenderable() !== tmaps[0]) {
        model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);
        model.openGLTexture.setRenderable(tmaps[0]);
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$Z = {
    context: null
  };

  // ----------------------------------------------------------------------------

  function extend$_(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$Z, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.openGLTexture = vtkOpenGLTexture$1.newInstance();
    model.tris = vtkHelper.newInstance();
    model.keyMatrixTime = {};
    obj(model.keyMatrixTime, {
      mtime: 0
    });
    model.keyMatrices = {
      normalMatrix: identity$4(new Float64Array(9)),
      mcwc: identity$3(new Float64Array(16))
    };

    // Build VTK API
    setGet(publicAPI, model, ['context']);
    get$1(publicAPI, model, ['activeTextures']);

    // Object methods
    vtkOpenGLSkybox(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$_ = newInstance$1I(extend$_);

  // Register ourself to OpenGL backend if imported
  registerOverride$1('vtkSkybox', newInstance$_);

  // import { mat4, vec3 }     from 'gl-matrix';
  const {
    vtkDebugMacro: vtkDebugMacro$5
  } = macro$1;

  // ----------------------------------------------------------------------------
  // vtkOpenGLPixelSpaceCallbackMapper methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {
    model.classHierarchy.push('vtkOpenGLPixelSpaceCallbackMapper');
    publicAPI.opaquePass = (prepass, renderPass) => {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      const aspectRatio = model._openGLRenderer.getAspectRatio();
      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      let texels = null;
      if (model.renderable.getUseZValues()) {
        const zbt = renderPass.getZBufferTexture();
        const width = Math.floor(zbt.getWidth());
        const height = Math.floor(zbt.getHeight());
        const gl = model._openGLRenderWindow.getContext();
        zbt.bind();

        // Here we need to use vtkFramebuffer to save current settings (bindings/buffers)
        const fb = renderPass.getFramebuffer();
        if (!fb) {
          vtkDebugMacro$5('No framebuffer to save/restore');
        } else {
          // save framebuffer settings
          fb.saveCurrentBindingsAndBuffers();
        }
        const framebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, zbt.getHandle(), 0);
        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
          texels = new Uint8Array(width * height * 4);
          gl.viewport(0, 0, width, height);
          gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);
        }

        // Now we need to restore framebuffer bindings/buffers
        if (fb) {
          fb.restorePreviousBindingsAndBuffers();
        }
        gl.deleteFramebuffer(framebuffer);
      }
      model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
    };
    publicAPI.queryPass = (prepass, renderPass) => {
      if (prepass) {
        if (model.renderable.getUseZValues()) {
          renderPass.requestDepth();
        }
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$Y = {};

  // ----------------------------------------------------------------------------

  function extend$Z(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$Y, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);

    // Object methods
    vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$Z = newInstance$1I(extend$Z, 'vtkOpenGLPixelSpaceCallbackMapper');

  // Register ourself to OpenGL backend if imported
  registerOverride$1('vtkPixelSpaceCallbackMapper', newInstance$Z);

  const CLASS_MAPPING = Object.create(null);
  function registerOverride(className, fn) {
    CLASS_MAPPING[className] = fn;
  }

  // ----------------------------------------------------------------------------
  // vtkWebGPUViewNodeFactory methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUViewNodeFactory(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUViewNodeFactory');
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$X = {};

  // ----------------------------------------------------------------------------

  function extend$Y(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$X, initialValues);

    // Static class mapping shared across instances
    model.overrides = CLASS_MAPPING;

    // Inheritance
    vtkViewNodeFactory$1$1.extend(publicAPI, model, initialValues);

    // Object methods
    vtkWebGPUViewNodeFactory(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$Y = macro.newInstance(extend$Y, 'vtkWebGPUViewNodeFactory');

  // ----------------------------------------------------------------------------

  var vtkWebGPUViewNodeFactory$1 = {
    newInstance: newInstance$Y,
    extend: extend$Y
  };

  // ----------------------------------------------------------------------------
  // vtkWebGPUCamera methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUCamera(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUCamera');
    publicAPI.getProjectionMatrix = (outMat, aspect, cRange, windowCenter) => {
      identity$3(outMat);
      if (model.renderable.getParallelProjection()) {
        // set up a rectangular parallelipiped
        const parallelScale = model.renderable.getParallelScale();
        const width = parallelScale * aspect;
        const height = parallelScale;
        const xmin = (windowCenter[0] - 1.0) * width;
        const xmax = (windowCenter[0] + 1.0) * width;
        const ymin = (windowCenter[1] - 1.0) * height;
        const ymax = (windowCenter[1] + 1.0) * height;
        const xr = 1.0 / (xmax - xmin);
        const yr = 1.0 / (ymax - ymin);
        outMat[0] = 2.0 * xr;
        outMat[5] = 2.0 * yr;
        outMat[10] = 1.0 / (cRange[1] - cRange[0]);
        outMat[12] = (xmax + xmin) * xr;
        outMat[13] = (ymax + ymin) * yr;
        outMat[14] = cRange[1] / (cRange[1] - cRange[0]);
      } else {
        const tmp = Math.tan(Math.PI * model.renderable.getViewAngle() / 360.0);
        let width;
        let height;
        if (model.renderable.getUseHorizontalViewAngle() === true) {
          width = cRange[0] * tmp;
          height = cRange[0] * tmp / aspect;
        } else {
          width = cRange[0] * tmp * aspect;
          height = cRange[0] * tmp;
        }
        const xmin = (windowCenter[0] - 1.0) * width;
        const xmax = (windowCenter[0] + 1.0) * width;
        const ymin = (windowCenter[1] - 1.0) * height;
        const ymax = (windowCenter[1] + 1.0) * height;
        outMat[0] = 2.0 * cRange[0] / (xmax - xmin);
        outMat[5] = 2.0 * cRange[0] / (ymax - ymin);
        outMat[12] = (xmin + xmax) / (xmax - xmin);
        outMat[13] = (ymin + ymax) / (ymax - ymin);
        outMat[10] = 0.0;
        outMat[14] = cRange[0];
        outMat[11] = -1.0;
        outMat[15] = 0.0;
      }
    };
    publicAPI.convertToOpenGLDepth = val => {
      if (model.renderable.getParallelProjection()) {
        return 1.0 - val;
      }
      const cRange = model.renderable.getClippingRangeByReference();
      let zval = -cRange[0] / val;
      zval = (cRange[0] + cRange[1]) / (cRange[1] - cRange[0]) + 2.0 * cRange[0] * cRange[1] / (zval * (cRange[1] - cRange[0]));
      return 0.5 * zval + 0.5;
    };
    publicAPI.getKeyMatrices = webGPURenderer => {
      // has the camera changed?
      const ren = webGPURenderer.getRenderable();
      const webGPURenderWindow = webGPURenderer.getParent();
      if (Math.max(webGPURenderWindow.getMTime(), publicAPI.getMTime(), ren.getMTime(), model.renderable.getMTime(), webGPURenderer.getStabilizedTime()) > model.keyMatrixTime.getMTime()) {
        const wcvc = model.renderable.getViewMatrix();
        copy$1(model.keyMatrices.normalMatrix, wcvc);
        // zero out translation
        model.keyMatrices.normalMatrix[3] = 0.0;
        model.keyMatrices.normalMatrix[7] = 0.0;
        model.keyMatrices.normalMatrix[11] = 0.0;
        invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        transpose(model.keyMatrices.wcvc, wcvc);
        const center = webGPURenderer.getStabilizedCenterByReference();
        translate(model.keyMatrices.scvc, model.keyMatrices.wcvc, center);
        const aspectRatio = webGPURenderer.getAspectRatio();
        const cRange = model.renderable.getClippingRangeByReference();
        publicAPI.getProjectionMatrix(model.keyMatrices.vcpc, aspectRatio, cRange, model.renderable.getWindowCenterByReference());
        multiply$1(model.keyMatrices.scpc, model.keyMatrices.vcpc, model.keyMatrices.scvc);
        invert(model.keyMatrices.pcsc, model.keyMatrices.scpc);
        model.keyMatrixTime.modified();
      }
      return model.keyMatrices;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$W = {
    keyMatrixTime: null,
    keyMatrices: null
  };

  // ----------------------------------------------------------------------------

  function extend$X(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$W, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.keyMatrixTime = {};
    macro.obj(model.keyMatrixTime);

    // values always get set by the get method
    model.keyMatrices = {
      normalMatrix: new Float64Array(16),
      vcpc: new Float64Array(16),
      pcsc: new Float64Array(16),
      wcvc: new Float64Array(16),
      scpc: new Float64Array(16),
      scvc: new Float64Array(16)
    };

    // Build VTK API
    macro.setGet(publicAPI, model, ['keyMatrixTime']);

    // Object methods
    vtkWebGPUCamera(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$X = macro.newInstance(extend$X);

  // Register ourself to WebGPU backend if imported
  registerOverride('vtkCamera', newInstance$X);

  // ----------------------------------------------------------------------------
  // vtkWebGPUBindGroup methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUBindGroup(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUBindGroup');
    publicAPI.setBindables = bindables => {
      // is there a difference between the old and new list?
      if (model.bindables.length === bindables.length) {
        let allMatch = true;
        for (let i = 0; i < model.bindables.length; i++) {
          if (model.bindables[i] !== bindables[i]) {
            allMatch = false;
          }
        }
        if (allMatch) {
          return;
        }
      }

      // there is a difference
      model.bindables = bindables;
      publicAPI.modified();
    };
    publicAPI.getBindGroupLayout = device => {
      const entries = [];
      for (let i = 0; i < model.bindables.length; i++) {
        const entry = model.bindables[i].getBindGroupLayoutEntry();
        entry.binding = i;
        entries.push(entry);
      }
      return device.getBindGroupLayout({
        entries
      });
    };
    publicAPI.getBindGroup = device => {
      // check mtime
      let mtime = publicAPI.getMTime();
      for (let i = 0; i < model.bindables.length; i++) {
        const tm = model.bindables[i].getBindGroupTime().getMTime();
        mtime = tm > mtime ? tm : mtime;
      }
      if (mtime < model.bindGroupTime.getMTime()) {
        return model.bindGroup;
      }
      const entries = [];
      for (let i = 0; i < model.bindables.length; i++) {
        const entry = model.bindables[i].getBindGroupEntry();
        entry.binding = i;
        entries.push(entry);
      }
      model.bindGroup = device.getHandle().createBindGroup({
        layout: publicAPI.getBindGroupLayout(device),
        entries,
        label: model.label
      });
      model.bindGroupTime.modified();
      return model.bindGroup;
    };
    publicAPI.getShaderCode = pipeline => {
      const lines = [];
      const bgroup = pipeline.getBindGroupLayoutCount(model.label);
      for (let i = 0; i < model.bindables.length; i++) {
        lines.push(model.bindables[i].getShaderCode(i, bgroup));
      }
      return lines.join('\n');
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$V = {
    device: null,
    handle: null,
    label: null
  };

  // ----------------------------------------------------------------------------

  function extend$W(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$V, initialValues);

    // Object methods
    macro.obj(publicAPI, model);
    model.bindables = [];
    model.bindGroupTime = {};
    macro.obj(model.bindGroupTime, {
      mtime: 0
    });
    macro.get(publicAPI, model, ['bindGroupTime', 'handle', 'sizeInBytes', 'usage']);
    macro.setGet(publicAPI, model, ['label', 'device', 'arrayInformation']);
    vtkWebGPUBindGroup(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$W = macro.newInstance(extend$W);

  // ----------------------------------------------------------------------------

  var vtkWebGPUBindGroup$1 = {
    newInstance: newInstance$W,
    extend: extend$W
  };

  // ----------------------------------------------------------------------------
  // vtkWebGPUShaderModule methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUShaderModule(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUShaderModule');
    publicAPI.initialize = (device, shaderDesc) => {
      model.device = device;
      // console.log(shaderDesc.getCode());
      model.handle = model.device.getHandle().createShaderModule({
        code: shaderDesc.getCode()
      });
    };

    // publicAPI.setLastCameraMTime = (mtime) => {
    //   model.lastCameraMTime = mtime;
    // };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$U = {
    device: null,
    handle: null
  };

  // ----------------------------------------------------------------------------

  function extend$V(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$U, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ['lastCameraMTime']);
    macro.setGet(publicAPI, model, ['device', 'handle']);

    // Object methods
    vtkWebGPUShaderModule(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$V = macro.newInstance(extend$V, 'vtkWebGPUShaderModule');

  // ----------------------------------------------------------------------------

  var vtkWebGPUShaderModule$1 = {
    newInstance: newInstance$V,
    extend: extend$V
  };

  // perform in place string substitutions, indicate if a substitution was done
  // this is useful for building up shader strings which typically involve
  // lots of string substitutions. Return true if a substitution was done.
  function substitute(source, search, replace) {
    let all = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    const replaceStr = Array.isArray(replace) ? replace.join('\n') : replace;
    let replaced = false;
    if (source.search(search) !== -1) {
      replaced = true;
    }
    let gflag = '';
    if (all) {
      gflag = 'g';
    }
    const regex = new RegExp(search, gflag);
    const resultstr = source.replace(regex, replaceStr);
    return {
      replace: replaced,
      result: resultstr
    };
  }

  // ----------------------------------------------------------------------------
  // vtkWebGPUShaderCache methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUShaderCache(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUShaderCache');
    publicAPI.getShaderModule = shaderDesc => {
      // has it already been created?
      const sType = shaderDesc.getType();
      const sHash = shaderDesc.getHash();
      const keys = model._shaderModules.keys();
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key.getHash() === sHash && key.getType() === sType) {
          return model._shaderModules.get(key);
        }
      }

      // console.log(JSON.stringify(shaderDesc));

      const sm = vtkWebGPUShaderModule$1.newInstance();
      sm.initialize(model.device, shaderDesc);
      model._shaderModules.set(shaderDesc, sm);
      return sm;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$T = {
    shaderModules: null,
    device: null,
    window: null
  };

  // ----------------------------------------------------------------------------

  function extend$U(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$T, initialValues);

    // Internal objects
    model._shaderModules = new Map();

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ['device', 'window']);

    // Object methods
    vtkWebGPUShaderCache(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$U = macro.newInstance(extend$U, 'vtkWebGPUShaderCache');

  // ----------------------------------------------------------------------------

  var vtkWebGPUShaderCache$1 = {
    newInstance: newInstance$U,
    extend: extend$U,
    substitute
  };

  // ----------------------------------------------------------------------------
  // vtkWebGPUPipeline methods
  // ----------------------------------------------------------------------------
  function vtkWebGPUPipeline(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUPipeline');
    publicAPI.getShaderDescriptions = () => model.shaderDescriptions;
    publicAPI.initialize = (device, hash) => {
      // start with the renderencoder settings
      model.pipelineDescription = model.renderEncoder.getPipelineSettings();
      model.pipelineDescription.primitive.topology = model.topology;
      model.pipelineDescription.vertex = model.vertexState;
      model.pipelineDescription.label = hash;

      // add in bind group layouts
      const bindGroupLayouts = [];
      for (let i = 0; i < model.layouts.length; i++) {
        bindGroupLayouts.push(model.layouts[i].layout);
      }
      model.pipelineLayout = device.getHandle().createPipelineLayout({
        bindGroupLayouts
      });
      model.pipelineDescription.layout = model.pipelineLayout;
      for (let i = 0; i < model.shaderDescriptions.length; i++) {
        const sd = model.shaderDescriptions[i];
        const sm = device.getShaderModule(sd);
        if (sd.getType() === 'vertex') {
          model.pipelineDescription.vertex.module = sm.getHandle();
          model.pipelineDescription.vertex.entryPoint = 'main';
        }
        if (sd.getType() === 'fragment') {
          model.pipelineDescription.fragment.module = sm.getHandle();
          model.pipelineDescription.fragment.entryPoint = 'main';
        }
      }
      model.handle = device.getHandle().createRenderPipeline(model.pipelineDescription);
    };
    publicAPI.getShaderDescription = stype => {
      for (let i = 0; i < model.shaderDescriptions.length; i++) {
        if (model.shaderDescriptions[i].getType() === stype) return model.shaderDescriptions[i];
      }
      return null;
    };
    publicAPI.addBindGroupLayout = bindGroup => {
      if (!bindGroup) {
        return;
      }
      model.layouts.push({
        layout: bindGroup.getBindGroupLayout(model.device),
        label: bindGroup.getLabel()
      });
    };
    publicAPI.getBindGroupLayout = idx => model.layouts[idx].layout;
    publicAPI.getBindGroupLayoutCount = llabel => {
      for (let i = 0; i < model.layouts.length; i++) {
        if (model.layouts[i].label === llabel) {
          return i;
        }
      }
      return 0;
    };
    publicAPI.bindVertexInput = (renderEncoder, vInput) => {
      vInput.bindBuffers(renderEncoder);
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------
  const DEFAULT_VALUES$S = {
    handle: null,
    layouts: null,
    renderEncoder: null,
    shaderDescriptions: null,
    vertexState: null,
    topology: null,
    pipelineDescription: null
  };

  // ----------------------------------------------------------------------------
  function extend$T(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$S, initialValues);

    // Build VTK API
    obj(publicAPI, model);
    model.layouts = [];
    model.shaderDescriptions = [];
    get$1(publicAPI, model, ['handle', 'pipelineDescription']);
    setGet(publicAPI, model, ['device', 'renderEncoder', 'topology', 'vertexState']);

    // For more macro methods, see "Sources/macros.js"
    // Object specific methods
    vtkWebGPUPipeline(publicAPI, model);
  }

  // ----------------------------------------------------------------------------
  const newInstance$T = newInstance$1I(extend$T, 'vtkWebGPUPipeline');

  // ----------------------------------------------------------------------------
  var vtkWebGPUPipeline$1 = {
    newInstance: newInstance$T,
    extend: extend$T
  };

  // ----------------------------------------------------------------------------
  // vtkWebGPUShaderDescription methods
  // ----------------------------------------------------------------------------

  // shader description

  function vtkWebGPUShaderDescription(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUShaderDescription');
    publicAPI.hasOutput = name => model.outputNames.includes(name);
    publicAPI.addOutput = function (type, name) {
      let interpolation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      model.outputTypes.push(type);
      model.outputNames.push(name);
      model.outputInterpolations.push(interpolation);
    };
    publicAPI.addBuiltinOutput = (type, name) => {
      model.builtinOutputTypes.push(type);
      model.builtinOutputNames.push(name);
    };
    publicAPI.addBuiltinInput = (type, name) => {
      model.builtinInputTypes.push(type);
      model.builtinInputNames.push(name);
    };

    // perform shader replacements for the input and outputs
    // of this shader. That includes vertex inputs if specified
    publicAPI.replaceShaderCode = (priorStage, vertexInput) => {
      const inputImpl = [];
      let iodec = [];
      if (vertexInput) {
        inputImpl.push(vertexInput.getShaderCode());
      }
      if (priorStage || model.builtinInputNames.length) {
        const inputStruct = [];
        inputStruct.push(`struct ${model.type}Input\n{`);
        if (priorStage) {
          const inputNames = priorStage.getOutputNamesByReference();
          const inputTypes = priorStage.getOutputTypesByReference();
          const inputInterpolations = priorStage.getOutputInterpolationsByReference();
          for (let i = 0; i < inputNames.length; i++) {
            if (inputInterpolations[i] !== undefined) {
              inputStruct.push(`  @location(${i}) @interpolate(${inputInterpolations[i]}) ${inputNames[i]} : ${inputTypes[i]},`);
            } else {
              inputStruct.push(`  @location(${i}) ${inputNames[i]} : ${inputTypes[i]},`);
            }
          }
        }
        for (let i = 0; i < model.builtinInputNames.length; i++) {
          inputStruct.push(`  ${model.builtinInputNames[i]} : ${model.builtinInputTypes[i]},`);
        }
        if (inputStruct.length > 1) {
          inputStruct.push('};');
          iodec = inputStruct;
          inputImpl[inputImpl.length - 1] += ',';
          inputImpl.push(`input: ${model.type}Input`);
        }
      }
      if (inputImpl.length) {
        model.code = vtkWebGPUShaderCache$1.substitute(model.code, '//VTK::IOStructs::Input', inputImpl).result;
      }
      if (model.outputNames.length + model.builtinOutputNames.length) {
        const outputStruct = [`struct ${model.type}Output\n{`];
        for (let i = 0; i < model.outputNames.length; i++) {
          if (model.outputInterpolations[i] !== undefined) {
            outputStruct.push(`  @location(${i}) @interpolate(${model.outputInterpolations[i]}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);
          } else {
            outputStruct.push(`  @location(${i}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);
          }
        }
        for (let i = 0; i < model.builtinOutputNames.length; i++) {
          outputStruct.push(`  ${model.builtinOutputNames[i]} : ${model.builtinOutputTypes[i]},`);
        }
        outputStruct.push('};');
        iodec = iodec.concat(outputStruct);
        model.code = vtkWebGPUShaderCache$1.substitute(model.code, '//VTK::IOStructs::Output', [`-> ${model.type}Output`]).result;
      }
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, '//VTK::IOStructs::Dec', iodec).result;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$R = {
    type: null,
    // 'vertex' or 'fragment'
    hash: null,
    code: null,
    outputNames: null,
    outputTypes: null
  };

  // ----------------------------------------------------------------------------

  function extend$S(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$R, initialValues);
    model.outputNames = [];
    model.outputTypes = [];
    model.outputInterpolations = [];
    model.builtinOutputNames = [];
    model.builtinOutputTypes = [];
    model.builtinInputNames = [];
    model.builtinInputTypes = [];

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ['type', 'hash', 'code']);
    macro.getArray(publicAPI, model, ['outputTypes', 'outputNames', 'outputInterpolations']);

    // Object methods
    vtkWebGPUShaderDescription(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$S = macro.newInstance(extend$S, 'vtkWebGPUShaderDescription');

  // ----------------------------------------------------------------------------

  var vtkWebGPUShaderDescription$1 = {
    newInstance: newInstance$S,
    extend: extend$S
  };

  // ----------------------------------------------------------------------------
  // vtkWebGPUDevice static functions
  //
  // WebGPU uses types in a many places and calls, and often those types
  // need to be associated with byte sizes, alignments, native arrays etc.
  // The folowing methods are designed to help vtk.js introspect those types.
  // WebGPU currently tends to use multiple type formats:
  //  - buffer types such as float32x4
  //  - shader types suchs as vec4<f32>
  //  - texture types such as rgba32float
  // ----------------------------------------------------------------------------

  // see https://gpuweb.github.io/gpuweb/#texture-formats
  // for possible formats, there are a lot of them
  const textureDetails = {
    // 8-bit formats
    r8unorm: {
      numComponents: 1,
      nativeType: Uint8Array,
      stride: 1,
      elementSize: 1,
      sampleType: 'float'
    },
    r8snorm: {
      numComponents: 1,
      nativeType: Int8Array,
      stride: 1,
      elementSize: 1,
      sampleType: 'float'
    },
    r8uint: {
      numComponents: 1,
      nativeType: Uint8Array,
      stride: 1,
      elementSize: 1,
      sampleType: 'uint'
    },
    r8sint: {
      numComponents: 1,
      nativeType: Int8Array,
      stride: 1,
      elementSize: 1,
      sampleType: 'sint'
    },
    // 16-bit formats
    r16uint: {
      numComponents: 1,
      nativeType: Uint16Array,
      stride: 2,
      elementSize: 2,
      sampleType: 'uint'
    },
    r16sint: {
      numComponents: 1,
      nativeType: Int16Array,
      stride: 2,
      elementSize: 2,
      sampleType: 'sint'
    },
    r16float: {
      numComponents: 1,
      nativeType: Float32Array,
      stride: 2,
      elementSize: 2,
      sampleType: 'float'
    },
    rg8unorm: {
      numComponents: 2,
      nativeType: Uint8Array,
      stride: 2,
      elementSize: 1,
      sampleType: 'float'
    },
    rg8snorm: {
      numComponents: 2,
      nativeType: Int8Array,
      stride: 2,
      elementSize: 1,
      sampleType: 'float'
    },
    rg8uint: {
      numComponents: 2,
      nativeType: Uint8Array,
      stride: 2,
      elementSize: 1,
      sampleType: 'uint'
    },
    rg8sint: {
      numComponents: 2,
      nativeType: Int8Array,
      stride: 2,
      elementSize: 1,
      sampleType: 'sint'
    },
    // 32-bit formats
    r32uint: {
      numComponents: 1,
      nativeType: Uint32Array,
      stride: 4,
      elementSize: 4,
      sampleType: 'uint'
    },
    r32sint: {
      numComponents: 1,
      nativeType: Int32Array,
      stride: 4,
      elementSize: 4,
      sampleType: 'sint'
    },
    r32float: {
      numComponents: 1,
      nativeType: Float32Array,
      stride: 4,
      elementSize: 4,
      sampleType: 'unfilterable-float'
    },
    rg16uint: {
      numComponents: 2,
      nativeType: Uint16Array,
      stride: 4,
      elementSize: 2,
      sampleType: 'uint'
    },
    rg16sint: {
      numComponents: 2,
      nativeType: Int16Array,
      stride: 4,
      elementSize: 2,
      sampleType: 'sint'
    },
    rg16float: {
      numComponents: 2,
      nativeType: Float32Array,
      stride: 4,
      elementSize: 2,
      sampleType: 'float'
    },
    rgba8unorm: {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: 'float'
    },
    'rgba8unorm-srgb': {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: 'float'
    },
    rgba8snorm: {
      numComponents: 4,
      nativeType: Int8Array,
      stride: 4,
      elementSize: 1,
      sampleType: 'float'
    },
    rgba8uint: {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: 'uint'
    },
    rgba8sint: {
      numComponents: 4,
      nativeType: Int8Array,
      stride: 4,
      elementSize: 1,
      sampleType: 'sint'
    },
    bgra8unorm: {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: 'float'
    },
    'bgra8unorm-srgb': {
      numComponents: 4,
      nativeType: Uint8Array,
      stride: 4,
      elementSize: 1,
      sampleType: 'float'
    },
    // Packed 32-bit formats
    rgb9e5ufloat: {
      numComponents: 4,
      nativeType: Uint32Array,
      stride: 4,
      sampleType: 'float'
    },
    rgb10a2unorm: {
      numComponents: 4,
      nativeType: Uint32Array,
      stride: 4,
      sampleType: 'float'
    },
    rg11b10ufloat: {
      numComponents: 4,
      nativeType: Float32Array,
      stride: 4,
      sampleType: 'float'
    },
    // 64-bit formats
    rg32uint: {
      numComponents: 2,
      nativeType: Uint32Array,
      stride: 8,
      elementSize: 4,
      sampleType: 'uint'
    },
    rg32sint: {
      numComponents: 2,
      nativeType: Int32Array,
      stride: 8,
      elementSize: 4,
      sampleType: 'sint'
    },
    rg32float: {
      numComponents: 2,
      nativeType: Float32Array,
      stride: 8,
      elementSize: 4,
      sampleType: 'unfilterable-float'
    },
    rgba16uint: {
      numComponents: 4,
      nativeType: Uint16Array,
      stride: 8,
      elementSize: 2,
      sampleType: 'uint'
    },
    rgba16sint: {
      numComponents: 4,
      nativeType: Int16Array,
      stride: 8,
      elementSize: 2,
      sampleType: 'sint'
    },
    rgba16float: {
      numComponents: 4,
      nativeType: Float32Array,
      stride: 8,
      elementSize: 2,
      sampleType: 'float'
    },
    // 128-bit formats
    rgba32uint: {
      numComponents: 4,
      nativeType: Uint32Array,
      stride: 16,
      elementSize: 4,
      sampleType: 'uint'
    },
    rgba32sint: {
      numComponents: 4,
      nativeType: Int32Array,
      stride: 16,
      elementSize: 4,
      sampleType: 'sint'
    },
    rgba32float: {
      numComponents: 4,
      nativeType: Float32Array,
      stride: 16,
      elementSize: 4,
      sampleType: 'unfilterable-float'
    },
    // Depth and stencil formats
    stencil8: {
      numComponents: 1,
      nativeType: Uint8Array,
      stride: 1,
      elementSize: 1,
      sampleType: 'uint'
    },
    depth16unorm: {
      numComponents: 1,
      nativeType: Uint16Array,
      stride: 2,
      elementSize: 2,
      sampleType: 'depth'
    },
    depth24plus: {
      numComponents: 1,
      nativeType: Uint32Array,
      stride: 4,
      elementSize: 3,
      sampleType: 'depth'
    },
    'depth24plus-stencil8': {
      numComponents: 2,
      nativeType: Uint32Array,
      stride: 4,
      sampleType: 'mixed'
    },
    depth32float: {
      numComponents: 1,
      nativeType: Float32Array,
      stride: 4,
      elementSize: 4,
      sampleType: 'depth'
    }
  };
  function getDetailsFromTextureFormat(format) {
    if (!format || format.length < 6) return 0;
    if (format in textureDetails === true) {
      return textureDetails[format];
    }
    vtkErrorMacro$v(`unknown format ${format}`);
    return null;
  }

  // see https://gpuweb.github.io/gpuweb/#enumdef-gpuvertexformat
  // for possible formats
  function getByteStrideFromBufferFormat(format) {
    if (!format || format.length < 5) return 0;

    // options are x2, x3, x4 or nothing
    let numComp = 1;
    if (format[format.length - 2] === 'x') {
      numComp = Number(format[format.length - 1]);
    }
    const sizeStart = numComp === 1 ? format.length - 1 : format.length - 3;
    // options are 8, 16, 32 resulting in 8, 6, 2 as the last char
    // plugged into the formula below gives 1, 2, 4 respectively
    const num = Number(format[sizeStart]);
    if (Number.isNaN(num)) {
      vtkErrorMacro$v(`unknown format ${format}`);
      return 0;
    }
    const typeSize = 5 - num / 2;
    return numComp * typeSize;
  }

  // see https://gpuweb.github.io/gpuweb/#enumdef-gpuvertexformat
  // for possible formats
  function getNumberOfComponentsFromBufferFormat(format) {
    if (!format || format.length < 5) return 0;

    // options are x2, x3, x4 or nothing
    let numComp = 1;
    if (format[format.length - 2] === 'x') {
      numComp = Number(format[format.length - 1]);
    }
    return numComp;
  }

  // see https://gpuweb.github.io/gpuweb/#enumdef-gpuvertexformat
  // for possible formats
  function getNativeTypeFromBufferFormat(format) {
    if (!format || format.length < 5) return 0;

    // raw types are Uint Int or Float as follows
    let result;
    if (format[0] === 'f') {
      result = 'Float';
    } else if (format[0] === 's') {
      result = 'Int';
    } else if (format[0] === 'u') {
      result = 'Uint';
    } else {
      vtkErrorMacro$v(`unknown format ${format}`);
      return undefined;
    }

    // options are 8, 16, 32 resulting in 8, 6, 2 as the last char
    // plugged into the formula below gives 1, 2, 4 respectively
    const base = format.split('x')[0];
    const num = Number(base[base.length - 1]);
    if (Number.isNaN(num)) {
      vtkErrorMacro$v(`unknown format ${format}`);
      return undefined;
    }
    result += 8 * (5 - num / 2);
    result += 'Array';
    return result;
  }
  function getShaderTypeFromBufferFormat(format) {
    let dataType;
    if (format[0] === 'f' || format[1] === 'n') {
      dataType = 'f32';
    } else if (format[0] === 's' && format[1] === 'i') {
      dataType = 'i32';
    } else if (format[0] === 'u' && format[1] === 'i') {
      dataType = 'u32';
    } else {
      vtkErrorMacro$v(`unknown format ${format}`);
      return undefined;
    }

    // options are x2, x3, x4 or nothing
    let numComp = 1;
    if (format[format.length - 2] === 'x') {
      numComp = Number(format[format.length - 1]);
    }
    if (numComp === 4) return `vec4<${dataType}>`;
    if (numComp === 3) return `vec3<${dataType}>`;
    if (numComp === 2) return `vec2<${dataType}>`;
    return dataType;
  }
  function getByteStrideFromShaderFormat(format) {
    if (!format) return 0;
    let numComp = 1;
    if (format.substring(0, 3) === 'vec') {
      numComp = Number(format[3]);
    } else if (format.substring(0, 3) === 'mat') {
      numComp = format[3] * format[5];
    }
    const typeSize = 4;
    return numComp * typeSize;
  }
  function getNativeTypeFromShaderFormat(format) {
    if (!format) return undefined;
    if (format.includes('f32')) return 'Float32Array';
    if (format.includes('i32')) return 'Int32Array';
    if (format.includes('u32')) return 'Uint32Array';
    vtkErrorMacro$v(`unknown format ${format}`);
    return undefined;
  }
  var vtkWebGPUTypes = {
    getDetailsFromTextureFormat,
    getByteStrideFromBufferFormat,
    getNumberOfComponentsFromBufferFormat,
    getNativeTypeFromBufferFormat,
    getShaderTypeFromBufferFormat,
    getByteStrideFromShaderFormat,
    getNativeTypeFromShaderFormat
  };

  function arraysEqual(a, b) {
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; ++i) {
      if (!b.includes(a[i])) return false;
    }
    return true;
  }

  // ----------------------------------------------------------------------------
  // vtkWebGPUVertexInput methods
  // ----------------------------------------------------------------------------
  function vtkWebGPUVertexInput(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUVertexInput');
    publicAPI.addBuffer = function (buffer, inames) {
      let stepMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'vertex';
      let names = inames;
      if (!Array.isArray(names)) {
        names = [names];
      }
      // only add if it is a new setting
      for (let i = 0; i < model.inputs.length; i++) {
        if (arraysEqual(model.inputs[i].names, names)) {
          if (model.inputs[i].buffer === buffer) {
            return;
          }
          model.inputs[i].buffer = buffer;
          return;
        }
      }

      // when adding a new entry, make sure we sort the array
      // as the order is important to the shader and must always
      // be the same, so alphabetical is an easy option
      model.inputs.push({
        buffer,
        stepMode,
        names
      });
      model.inputs = model.inputs.sort((v1, v2) => {
        if (v1.names[0] < v2.names[0]) {
          return -1;
        }
        if (v1.names[0] > v2.names[0]) {
          return 1;
        }
        return 0;
      });
    };
    publicAPI.removeBufferIfPresent = name => {
      for (let i = 0; i < model.inputs.length; i++) {
        if (model.inputs[i].names.includes(name)) {
          model.inputs.splice(i, 1);
        }
      }
    };
    publicAPI.getBuffer = name => {
      for (let i = 0; i < model.inputs.length; i++) {
        if (model.inputs[i].names.includes(name)) {
          return model.inputs[i].buffer;
        }
      }
      return null;
    };
    publicAPI.hasAttribute = name => {
      for (let i = 0; i < model.inputs.length; i++) {
        if (model.inputs[i].names.includes(name)) {
          return true;
        }
      }
      return false;
    };
    publicAPI.getAttributeTime = name => {
      for (let i = 0; i < model.inputs.length; i++) {
        if (model.inputs[i].names.includes(name)) {
          return model.inputs[i].buffer.getSourceTime();
        }
      }
      return 0;
    };
    publicAPI.getShaderCode = () => {
      let result = '';
      let nameCount = 0;
      for (let i = 0; i < model.inputs.length; i++) {
        for (let nm = 0; nm < model.inputs[i].names.length; nm++) {
          const arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];
          const type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);
          if (nameCount > 0) {
            result += ',\n';
          }
          result = `${result}  @location(${nameCount}) ${model.inputs[i].names[nm]} : ${type}`;
          nameCount++;
        }
      }
      return result;
    };
    publicAPI.getVertexInputInformation = () => {
      const info = {};
      if (model.inputs.length) {
        const vertexBuffers = [];
        let nameCount = 0;
        for (let i = 0; i < model.inputs.length; i++) {
          const buf = model.inputs[i].buffer;
          const buffer = {
            arrayStride: buf.getStrideInBytes(),
            stepMode: model.inputs[i].stepMode,
            attributes: []
          };
          const arrayInfo = buf.getArrayInformation();
          for (let nm = 0; nm < model.inputs[i].names.length; nm++) {
            buffer.attributes.push({
              shaderLocation: nameCount,
              offset: arrayInfo[nm].offset,
              format: arrayInfo[nm].format
            });
            nameCount++;
          }
          vertexBuffers.push(buffer);
        }
        info.buffers = vertexBuffers;
      }
      return info;
    };
    publicAPI.bindBuffers = renderEncoder => {
      for (let i = 0; i < model.inputs.length; i++) {
        renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());
      }
      if (model.indexBuffer) {
        renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);
      }
    };
    publicAPI.getReady = () => {};
    publicAPI.releaseGraphicsResources = () => {
      if (model.created) {
        model.inputs = [];
        model.bindingDescriptions = [];
        model.attributeDescriptions = [];
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------
  const DEFAULT_VALUES$Q = {
    inputs: null,
    bindingDescriptions: false,
    attributeDescriptions: null,
    indexBuffer: null
  };

  // ----------------------------------------------------------------------------
  function extend$R(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$Q, initialValues);

    // Build VTK API
    obj(publicAPI, model);
    model.bindingDescriptions = [];
    model.attributeDescriptions = [];
    model.inputs = [];
    setGet(publicAPI, model, ['created', 'device', 'handle', 'indexBuffer']);

    // For more macro methods, see "Sources/macros.js"
    // Object specific methods
    vtkWebGPUVertexInput(publicAPI, model);
  }

  // ----------------------------------------------------------------------------
  const newInstance$R = newInstance$1I(extend$R, 'vtkWebGPUVertexInput');

  // ----------------------------------------------------------------------------
  var vtkWebGPUVertexInput$1 = {
    newInstance: newInstance$R,
    extend: extend$R
  };

  const vtkWebGPUSimpleMapperVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  // var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
  const vtkWebGPUSimpleMapperFS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::Light::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);

  //VTK::RenderEncoder::Impl
  return output;
}
`;

  // ----------------------------------------------------------------------------
  // vtkWebGPUSimpleMapper methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUSimpleMapper(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUSimpleMapper');
    publicAPI.generateShaderDescriptions = (hash, pipeline, vertexInput) => {
      // create the shader descriptions
      const vDesc = vtkWebGPUShaderDescription$1.newInstance({
        type: 'vertex',
        hash,
        code: model.vertexShaderTemplate
      });
      const fDesc = vtkWebGPUShaderDescription$1.newInstance({
        type: 'fragment',
        hash,
        code: model.fragmentShaderTemplate
      });

      // add them to the pipeline
      const sdrs = pipeline.getShaderDescriptions();
      sdrs.push(vDesc);
      sdrs.push(fDesc);

      // look for replacements to invoke
      const scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;
      // eslint-disable-next-line prefer-regex-literals
      const re = new RegExp('//VTK::[^:]*::', 'g');
      const unique = scode.match(re).filter((v, i, a) => a.indexOf(v) === i);
      const fnames = unique.map(v => `replaceShader${v.substring(7, v.length - 2)}`);

      // now invoke shader replacement functions
      for (let i = 0; i < fnames.length; i++) {
        const fname = fnames[i];
        if (fname !== 'replaceShaderIOStructs' && model.shaderReplacements.has(fname)) {
          model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);
        }
      }

      // always replace the IOStructs last as other replacement funcs may
      // add inputs or outputs
      publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);

      // console.log(vDesc.getCode());
      // console.log(fDesc.getCode());
    };

    publicAPI.replaceShaderIOStructs = (hash, pipeline, vertexInput) => {
      const vDesc = pipeline.getShaderDescription('vertex');
      vDesc.replaceShaderCode(null, vertexInput);
      const fDesc = pipeline.getShaderDescription('fragment');
      fDesc.replaceShaderCode(vDesc);
    };
    publicAPI.replaceShaderRenderEncoder = (hash, pipeline, vertexInput) => {
      model.renderEncoder.replaceShaderCode(pipeline);
    };
    model.shaderReplacements.set('replaceShaderRenderEncoder', publicAPI.replaceShaderRenderEncoder);
    publicAPI.replaceShaderRenderer = (hash, pipeline, vertexInput) => {
      if (!model.WebGPURenderer) {
        return;
      }
      const ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);
      const vDesc = pipeline.getShaderDescription('vertex');
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription('fragment');
      code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Renderer::Dec', [ubocode]).result;
      fDesc.setCode(code);
    };
    model.shaderReplacements.set('replaceShaderRenderer', publicAPI.replaceShaderRenderer);
    publicAPI.replaceShaderMapper = (hash, pipeline, vertexInput) => {
      const ubocode = model.bindGroup.getShaderCode(pipeline);
      const vDesc = pipeline.getShaderDescription('vertex');
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription('fragment');
      fDesc.addBuiltinInput('bool', '@builtin(front_facing) frontFacing');
      code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Mapper::Dec', [ubocode]).result;
      fDesc.setCode(code);
    };
    model.shaderReplacements.set('replaceShaderMapper', publicAPI.replaceShaderMapper);
    publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
      const vDesc = pipeline.getShaderDescription('vertex');
      vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Position::Impl', ['    output.Position = rendererUBO.SCPCMatrix*vertexBC;']).result;
      vDesc.setCode(code);
    };
    model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);
    publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
      const vDesc = pipeline.getShaderDescription('vertex');
      vDesc.addOutput('vec2<f32>', 'tcoordVS');
    };
    model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);
    publicAPI.addTextureView = view => {
      // is it already there?
      if (model.textureViews.includes(view)) {
        return;
      }
      model.textureViews.push(view);
    };

    // do everything required for this mapper to be rerady to draw
    // but do not bind or do the actual draw commands as the pipeline
    // is not neccessarily bound yet
    publicAPI.prepareToDraw = renderEncoder => {
      model.renderEncoder = renderEncoder;

      // do anything needed to get our input data up to date
      publicAPI.updateInput();

      // make sure buffers are created and up to date
      publicAPI.updateBuffers();

      // update bindings and bind groups/layouts
      // does not acutally bind them, that is done in draw(...)
      publicAPI.updateBindings();

      // update the pipeline, includes computing the hash, and if needed
      // creating the pipeline, shader code etc
      publicAPI.updatePipeline();
    };
    publicAPI.updateInput = () => {};
    publicAPI.updateBuffers = () => {};
    publicAPI.updateBindings = () => {
      // bindings can change without a pipeline change
      // as long as their layout remains the same.
      // That is why this is done even when the pipeline
      // hash doesn't change.
      model.bindGroup.setBindables(publicAPI.getBindables());
    };
    publicAPI.computePipelineHash = () => {};
    publicAPI.registerDrawCallback = encoder => {
      encoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    };
    publicAPI.prepareAndDraw = encoder => {
      publicAPI.prepareToDraw(encoder);
      encoder.setPipeline(model.pipeline);
      publicAPI.draw(encoder);
    };

    // do the rest of the calls required to draw this mapper
    // at this point the command encouder and pipeline are
    // created and bound
    publicAPI.draw = renderEncoder => {
      const pipeline = renderEncoder.getBoundPipeline();

      // bind the mapper bind group
      renderEncoder.activateBindGroup(model.bindGroup);
      if (model.WebGPURenderer) {
        model.WebGPURenderer.bindUBO(renderEncoder);
      }

      // bind the vertex input
      pipeline.bindVertexInput(renderEncoder, model.vertexInput);
      const indexBuffer = model.vertexInput.getIndexBuffer();
      if (indexBuffer) {
        renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);
      } else {
        renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);
      }
    };
    publicAPI.getBindables = () => {
      const bindables = [...model.additionalBindables];
      if (model.UBO) {
        bindables.push(model.UBO);
      }
      if (model.SSBO) {
        bindables.push(model.SSBO);
      }

      // add texture BindGroupLayouts
      for (let t = 0; t < model.textureViews.length; t++) {
        bindables.push(model.textureViews[t]);
        const samp = model.textureViews[t].getSampler();
        if (samp) {
          bindables.push(samp);
        }
      }
      return bindables;
    };
    publicAPI.updatePipeline = () => {
      publicAPI.computePipelineHash();
      model.pipeline = model.device.getPipeline(model.pipelineHash);

      // build the pipeline if needed
      if (!model.pipeline) {
        model.pipeline = vtkWebGPUPipeline$1.newInstance();
        model.pipeline.setDevice(model.device);
        if (model.WebGPURenderer) {
          model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());
        }
        model.pipeline.addBindGroupLayout(model.bindGroup);
        publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);
        model.pipeline.setTopology(model.topology);
        model.pipeline.setRenderEncoder(model.renderEncoder);
        model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());
        model.device.createPipeline(model.pipelineHash, model.pipeline);
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$P = {
    additionalBindables: undefined,
    bindGroup: null,
    device: null,
    fragmentShaderTemplate: null,
    numberOfInstances: 1,
    numberOfVertices: 0,
    pipelineHash: null,
    shaderReplacements: null,
    SSBO: null,
    textureViews: null,
    topology: 'triangle-list',
    UBO: null,
    vertexShaderTemplate: null,
    WebGPURenderer: null
  };

  // ----------------------------------------------------------------------------

  function extend$Q(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$P, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.textureViews = [];
    model.vertexInput = vtkWebGPUVertexInput$1.newInstance();
    model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
      label: 'mapperBG'
    });
    model.additionalBindables = [];
    model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;
    model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;
    model.shaderReplacements = new Map();

    // Build VTK API
    macro.get(publicAPI, model, ['pipeline', 'vertexInput']);
    macro.setGet(publicAPI, model, ['additionalBindables', 'device', 'fragmentShaderTemplate', 'interpolate', 'numberOfInstances', 'numberOfVertices', 'pipelineHash', 'shaderReplacements', 'SSBO', 'textureViews', 'topology', 'UBO', 'vertexShaderTemplate', 'WebGPURenderer']);

    // Object methods
    vtkWebGPUSimpleMapper(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$Q = macro.newInstance(extend$Q, 'vtkWebGPUSimpleMapper');

  // ----------------------------------------------------------------------------

  var vtkWebGPUSimpleMapper$1 = {
    newInstance: newInstance$Q,
    extend: extend$Q
  };

  // ----------------------------------------------------------------------------
  // vtkWebGPUFullScreenQuad methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUFullScreenQuad(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUFullScreenQuad');
    publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
      const vDesc = pipeline.getShaderDescription('vertex');
      vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');
      vDesc.addOutput('vec4<f32>', 'vertexVC');
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Position::Impl', ['output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);', 'output.Position = vec4<f32>(vertexBC, 1.0);', 'output.vertexVC = vec4<f32>(vertexBC, 1);']).result;
      vDesc.setCode(code);
    };
    model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);
    publicAPI.updateBuffers = () => {
      const buff = model.device.getBufferManager().getFullScreenQuadBuffer();
      model.vertexInput.addBuffer(buff, ['vertexBC']);
      model.numberOfVertices = 6;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$O = {};

  // ----------------------------------------------------------------------------

  function extend$P(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$O, initialValues);

    // Inheritance
    vtkWebGPUSimpleMapper$1.extend(publicAPI, model, initialValues);

    // Object methods
    vtkWebGPUFullScreenQuad(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$P = macro.newInstance(extend$P, 'vtkWebGPUFullScreenQuad');

  // ----------------------------------------------------------------------------

  var vtkWebGPUFullScreenQuad$1 = {
    newInstance: newInstance$P,
    extend: extend$P
  };

  const BufferUsage$6 = {
    Verts: 0,
    Lines: 1,
    Triangles: 2,
    Strips: 3,
    LinesFromStrips: 4,
    LinesFromTriangles: 5,
    Points: 6,
    UniformArray: 7,
    PointArray: 8,
    NormalsFromPoints: 9,
    Texture: 10,
    RawVertex: 11,
    Storage: 12,
    Index: 13
  };
  const PrimitiveTypes$5 = {
    Start: 0,
    Points: 0,
    Lines: 1,
    Triangles: 2,
    TriangleStrips: 3,
    TriangleEdges: 4,
    TriangleStripEdges: 5,
    End: 6
  };
  var Constants$2 = {
    BufferUsage: BufferUsage$6,
    PrimitiveTypes: PrimitiveTypes$5
  };

  // methods we forward to the handle
  const forwarded$1 = ['getMappedRange', 'mapAsync', 'unmap'];
  function bufferSubData(device, destBuffer, destOffset, srcArrayBuffer) {
    const byteCount = srcArrayBuffer.byteLength;
    const srcBuffer = device.createBuffer({
      size: byteCount,
      /* eslint-disable no-undef */
      usage: GPUBufferUsage.COPY_SRC,
      /* eslint-enable no-undef */
      mappedAtCreation: true
    });
    const arrayBuffer = srcBuffer.getMappedRange(0, byteCount);
    new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer)); // memcpy
    srcBuffer.unmap();
    const encoder = device.createCommandEncoder();
    encoder.copyBufferToBuffer(srcBuffer, 0, destBuffer, destOffset, byteCount);
    const commandBuffer = encoder.finish();
    const queue = device.queue;
    queue.submit([commandBuffer]);
    srcBuffer.destroy();
  }
  // ----------------------------------------------------------------------------
  // vtkWebGPUBufferManager methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUBuffer(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUBuffer');
    publicAPI.create = (sizeInBytes, usage) => {
      model.handle = model.device.getHandle().createBuffer({
        size: sizeInBytes,
        usage,
        label: model.label
      });
      model.sizeInBytes = sizeInBytes;
      model.usage = usage;
    };
    publicAPI.write = data => {
      bufferSubData(model.device.getHandle(), model.handle, 0, data.buffer);
    };
    publicAPI.createAndWrite = (data, usage) => {
      model.handle = model.device.getHandle().createBuffer({
        size: data.byteLength,
        usage,
        mappedAtCreation: true,
        label: model.label
      });
      model.sizeInBytes = data.byteLength;
      model.usage = usage;
      new Uint8Array(model.handle.getMappedRange()).set(new Uint8Array(data.buffer)); // memcpy
      model.handle.unmap();
    };

    // simple forwarders
    for (let i = 0; i < forwarded$1.length; i++) {
      publicAPI[forwarded$1[i]] = function () {
        return model.handle[forwarded$1[i]](...arguments);
      };
    }
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$N = {
    device: null,
    handle: null,
    sizeInBytes: 0,
    strideInBytes: 0,
    arrayInformation: null,
    usage: null,
    label: null,
    sourceTime: null
  };

  // ----------------------------------------------------------------------------

  function extend$O(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$N, initialValues);

    // Object methods
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ['handle', 'sizeInBytes', 'usage']);
    macro.setGet(publicAPI, model, ['strideInBytes', 'device', 'arrayInformation', 'label', 'sourceTime']);
    vtkWebGPUBuffer(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$O = macro.newInstance(extend$O);

  // ----------------------------------------------------------------------------

  var vtkWebGPUBuffer$1 = {
    newInstance: newInstance$O,
    extend: extend$O,
    ...Constants$2
  };

  const {
    Representation: Representation$3
  } = vtkProperty$1;
  const {
    PrimitiveTypes: PrimitiveTypes$4
  } = Constants$2;

  // Simulate a small map of pointId to flatId for a cell. The original code
  // used a map and was 2.6x slower (4.7 to 1.9 seconds). Using two fixed
  // length arrays with a count is so much faster even with the required for
  // loops and if statements. This only works as we know the usage is
  // restricted to clear(), set() get() and has() so the count is always
  // incrmenting except for clear where it goes back to 0. Performance
  // improvement is probably due to this appoach not hitting the heap but wow
  // it is so much faster. Code that adds to these vectors checks against 9 to
  // make sure there is room. Switching to test against vec.length -1 results
  // in a small performance hit, so if you change 10, search for 9 in this
  // small class and change those as well.
  class _LimitedMap {
    constructor() {
      this.keys = new Uint32Array(10);
      this.values = new Uint32Array(10);
      this.count = 0;
    }
    clear() {
      this.count = 0;
    }
    has(key) {
      for (let i = 0; i < this.count; i++) {
        if (this.keys[i] === key) {
          return true;
        }
      }
      return undefined;
    }
    get(key) {
      for (let i = 0; i < this.count; i++) {
        if (this.keys[i] === key) {
          return this.values[i];
        }
      }
      return undefined;
    }
    set(key, value) {
      if (this.count < 9) {
        this.keys[this.count] = key;
        this.values[this.count++] = value;
      }
    }
  }
  function getPrimitiveName(primType) {
    switch (primType) {
      case PrimitiveTypes$4.Points:
        return 'points';
      case PrimitiveTypes$4.Lines:
        return 'lines';
      case PrimitiveTypes$4.Triangles:
      case PrimitiveTypes$4.TriangleEdges:
        return 'polys';
      case PrimitiveTypes$4.TriangleStripEdges:
      case PrimitiveTypes$4.TriangleStrips:
        return 'strips';
      default:
        return '';
    }
  }
  function _getOrAddFlatId(state, ptId, cellId) {
    let flatId = state.pointIdToFlatId[ptId];
    if (flatId < 0) {
      flatId = state.flatId;
      state.pointIdToFlatId[ptId] = flatId;
      state.flatIdToPointId[state.flatId] = ptId;
      state.flatIdToCellId[state.flatId] = cellId;
      state.flatId++;
    }
    return flatId;
  }
  function fillCell(ptIds, cellId, state) {
    const numPtIds = ptIds.length;
    // are any points already marked for this cell? If so use that as the provoking point
    for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
      let ptId = ptIds[ptIdx];
      if (state.cellProvokedMap.has(ptId)) {
        state.ibo[state.iboId++] = state.cellProvokedMap.get(ptId);

        // insert remaining ptIds (they do not need to provoke)
        for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
          ptId = ptIds[ptIdx2 % numPtIds];
          const flatId = _getOrAddFlatId(state, ptId, cellId);
          // add to ibo
          state.ibo[state.iboId++] = flatId;
        }
        // all done now
        return;
      }
    }

    // else have any of the points not been used yet? (not in provokedPointIds)
    for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
      let ptId = ptIds[ptIdx];
      if (!state.provokedPointIds[ptId]) {
        let flatId = _getOrAddFlatId(state, ptId, cellId);
        // mark provoking and add to ibo
        state.provokedPointIds[ptId] = 1;
        state.cellProvokedMap.set(ptId, flatId);
        // when provoking always set the cellId as an original non-provoking value
        // will have been stored and we need to overwrite that
        state.flatIdToCellId[flatId] = cellId;
        state.ibo[state.iboId++] = flatId;

        // insert remaining ptIds (they do not need to provoke)
        for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
          ptId = ptIds[ptIdx2 % numPtIds];
          flatId = _getOrAddFlatId(state, ptId, cellId);
          // add to ibo
          state.ibo[state.iboId++] = flatId;
        }
        // all done now
        return;
      }
    }

    // if we got here then none of the ptIds could be used to provoke
    // so just duplicate the first one
    let ptId = ptIds[0];
    let flatId = state.flatId;
    state.cellProvokedMap.set(ptId, flatId);
    state.flatIdToPointId[state.flatId] = ptId;
    state.flatIdToCellId[state.flatId] = cellId;
    state.flatId++;

    // add to ibo
    state.ibo[state.iboId++] = flatId;

    // insert remaining ptIds (they do not need to provoke)
    for (let ptIdx2 = 1; ptIdx2 < numPtIds; ptIdx2++) {
      ptId = ptIds[ptIdx2];
      flatId = _getOrAddFlatId(state, ptId, cellId);
      // add to ibo
      state.ibo[state.iboId++] = flatId;
    }
  }
  function countCell(ptIds, cellId, state) {
    const numPtIds = ptIds.length;
    state.iboSize += numPtIds;

    // are any points already marked for this cell? If so use that as the provoking point
    for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
      const ptId = ptIds[ptIdx];
      if (state.cellProvokedMap.has(ptId)) {
        return;
      }
    }

    // else have any of the points not been used yet? (not in provokedPointIds)
    for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
      const ptId = ptIds[ptIdx];
      if (!state.provokedPointIds[ptId]) {
        state.provokedPointIds[ptId] = 1;
        state.cellProvokedMap.set(ptId, 1);
        return;
      }
    }
    // if we got here then none of the ptIds could be used to provoke
    state.cellProvokedMap.set(ptIds[0], 1);
    state.extraPoints++;
  }
  let processCell;
  const _single = new Uint32Array(1);
  const _double = new Uint32Array(2);
  const _triple = new Uint32Array(3);
  const _indexCellBuilders = {
    // easy, every input point becomes an output point
    anythingToPoints(numPoints, cellPts, offset, cellId, state) {
      for (let i = 0; i < numPoints; ++i) {
        _single[0] = cellPts[offset + i];
        processCell(_single, cellId, state);
      }
    },
    linesToWireframe(numPoints, cellPts, offset, cellId, state) {
      // for lines we add a bunch of segments
      for (let i = 0; i < numPoints - 1; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + i + 1];
        processCell(_double, cellId, state);
      }
    },
    polysToWireframe(numPoints, cellPts, offset, cellId, state) {
      // for polys we add a bunch of segments and close it
      if (numPoints > 2) {
        for (let i = 0; i < numPoints; ++i) {
          _double[0] = cellPts[offset + i];
          _double[1] = cellPts[offset + (i + 1) % numPoints];
          processCell(_double, cellId, state);
        }
      }
    },
    stripsToWireframe(numPoints, cellPts, offset, cellId, state) {
      if (numPoints > 2) {
        // for strips we add a bunch of segments and close it
        for (let i = 0; i < numPoints - 1; ++i) {
          _double[0] = cellPts[offset + i];
          _double[1] = cellPts[offset + i + 1];
          processCell(_double, cellId, state);
        }
        for (let i = 0; i < numPoints - 2; i++) {
          _double[0] = cellPts[offset + i];
          _double[1] = cellPts[offset + i + 2];
          processCell(_double, cellId, state);
        }
      }
    },
    polysToSurface(npts, cellPts, offset, cellId, state) {
      for (let i = 0; i < npts - 2; i++) {
        _triple[0] = cellPts[offset];
        _triple[1] = cellPts[offset + i + 1];
        _triple[2] = cellPts[offset + i + 2];
        processCell(_triple, cellId, state);
      }
    },
    stripsToSurface(npts, cellPts, offset, cellId, state) {
      for (let i = 0; i < npts - 2; i++) {
        _triple[0] = cellPts[offset + i];
        _triple[1] = cellPts[offset + i + 1 + i % 2];
        _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];
        processCell(_triple, cellId, state);
      }
    }
  };

  // ----------------------------------------------------------------------------
  // vtkWebGPUIndexBufferManager methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUIndexBuffer(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUIndexBuffer');
    publicAPI.buildIndexBuffer = req => {
      const cellArray = req.cells;
      const primitiveType = req.primitiveType;
      const representation = req.representation;
      const cellOffset = req.cellOffset;
      const array = cellArray.getData();
      const cellArraySize = array.length;
      const inRepName = getPrimitiveName(primitiveType);
      const numPts = req.numberOfPoints;
      const state = {
        provokedPointIds: new Uint8Array(numPts),
        // size is good
        extraPoints: 0,
        iboSize: 0,
        flatId: 0,
        iboId: 0,
        cellProvokedMap: new _LimitedMap()
      };
      let func = null;
      if (representation === Representation$3.POINTS || primitiveType === PrimitiveTypes$4.Points) {
        func = _indexCellBuilders.anythingToPoints;
      } else if (representation === Representation$3.WIREFRAME || primitiveType === PrimitiveTypes$4.Lines) {
        func = _indexCellBuilders[`${inRepName}ToWireframe`];
      } else {
        func = _indexCellBuilders[`${inRepName}ToSurface`];
      }

      // first we count how many extra provoking points we need
      processCell = countCell;
      let cellId = cellOffset || 0;
      for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {
        state.cellProvokedMap.clear();
        func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);
        cellArrayIndex += array[cellArrayIndex] + 1;
        cellId++;
      }

      // then we allocate the remaining structures
      // (we pick the best size to save space and transfer costs)
      if (numPts <= 0xffff) {
        state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);
      } else {
        state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);
      }
      if (numPts + state.extraPoints < 0x8fff) {
        state.pointIdToFlatId = new Int16Array(numPts);
      } else {
        state.pointIdToFlatId = new Int32Array(numPts);
      }
      if (numPts + state.extraPoints <= 0xffff) {
        state.ibo = new Uint16Array(state.iboSize);
        req.format = 'uint16';
      } else {
        state.ibo = new Uint32Array(state.iboSize);
        req.format = 'uint32';
      }
      if (cellId <= 0xffff) {
        state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);
      } else {
        state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);
      }
      state.pointIdToFlatId.fill(-1);
      state.provokedPointIds.fill(0);

      // and fill them in
      processCell = fillCell;
      cellId = cellOffset || 0;
      for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize;) {
        state.cellProvokedMap.clear();
        func(array[cellArrayIndex], array, cellArrayIndex + 1, cellId, state);
        cellArrayIndex += array[cellArrayIndex] + 1;
        cellId++;
      }
      delete state.provokedPointIds;
      delete state.pointIdToFlatId;

      // store the results we need
      req.nativeArray = state.ibo;
      model.flatIdToPointId = state.flatIdToPointId;
      model.flatIdToCellId = state.flatIdToCellId;
      model.flatSize = state.flatId;
      model.indexCount = state.iboId;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$M = {
    flatIdToPointId: null,
    flatIdToCellId: null,
    flatSize: 0,
    indexCount: 0
  };

  // ----------------------------------------------------------------------------

  function extend$N(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$M, initialValues);

    // Inheritance
    vtkWebGPUBuffer$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ['flatIdToPointId', 'flatIdToCellId', 'flatSize', 'indexCount']);
    vtkWebGPUIndexBuffer(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$N = macro.newInstance(extend$N);

  // ----------------------------------------------------------------------------

  var vtkWebGPUIndexBuffer$1 = {
    newInstance: newInstance$N,
    extend: extend$N,
    ...Constants$2
  };

  const {
    BufferUsage: BufferUsage$5
  } = Constants$2;
  const {
    vtkErrorMacro: vtkErrorMacro$f
  } = macro$1;
  const {
    VtkDataTypes: VtkDataTypes$1
  } = vtkDataArray$1;

  // the webgpu constants all show up as undefined
  /* eslint-disable no-undef */

  // ----------------------------------------------------------------------------
  // Static API
  // ----------------------------------------------------------------------------

  const STATIC$1 = {};
  function _getFormatForDataArray(dataArray) {
    let format;
    switch (dataArray.getDataType()) {
      case VtkDataTypes$1.UNSIGNED_CHAR:
        format = 'uint8';
        break;
      case VtkDataTypes$1.FLOAT:
        format = 'float32';
        break;
      case VtkDataTypes$1.UNSIGNED_INT:
        format = 'uint32';
        break;
      case VtkDataTypes$1.INT:
        format = 'sint32';
        break;
      case VtkDataTypes$1.DOUBLE:
        format = 'float32';
        break;
      case VtkDataTypes$1.UNSIGNED_SHORT:
        format = 'uint16';
        break;
      case VtkDataTypes$1.SHORT:
        format = 'sin16';
        break;
      default:
        format = 'float32';
        break;
    }
    switch (dataArray.getNumberOfComponents()) {
      case 2:
        format += 'x2';
        break;
      case 3:
        // only 32bit types support x3
        if (!format.includes('32')) {
          vtkErrorMacro$f(`unsupported x3 type for ${format}`);
        }
        format += 'x3';
        break;
      case 4:
        format += 'x4';
        break;
    }
    return format;
  }
  function packArray(indexBuffer, inArrayData, numComp, outputType, options) {
    const result = {};
    const flatSize = indexBuffer.getFlatSize();
    if (!flatSize) {
      return result;
    }

    // setup shift and scale
    let shift = [0.0, 0.0, 0.0, 0.0];
    if (options.shift) {
      if (options.shift.length) {
        shift = options.shift;
      } else {
        shift.fill(options.shift);
      }
    }
    let scale = [1.0, 1.0, 1.0, 1.0];
    if (options.scale) {
      if (options.scale.length) {
        scale = options.scale;
      } else {
        scale.fill(options.scale);
      }
    }
    const packExtra = Object.prototype.hasOwnProperty.call(options, 'packExtra') ? options.packExtra : false;
    let addAPoint;
    let vboidx = 0;
    const stride = numComp + (packExtra ? 1 : 0);
    const packedVBO = newTypedArray(outputType, flatSize * stride);

    // pick the right function based on point versus cell data
    let flatIdMap = indexBuffer.getFlatIdToPointId();
    if (options.cellData) {
      flatIdMap = indexBuffer.getFlatIdToCellId();
    }

    // add data based on number of components
    if (numComp === 1) {
      addAPoint = function addAPointFunc(i) {
        packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
      };
    } else if (numComp === 2) {
      addAPoint = function addAPointFunc(i) {
        packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
        packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
      };
    } else if (numComp === 3 && !packExtra) {
      addAPoint = function addAPointFunc(i) {
        packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
        packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
        packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];
      };
    } else if (numComp === 3 && packExtra) {
      addAPoint = function addAPointFunc(i) {
        packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
        packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
        packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];
        packedVBO[vboidx++] = scale[3] * 1.0 + shift[3];
      };
    } else if (numComp === 4) {
      addAPoint = function addAPointFunc(i) {
        packedVBO[vboidx++] = scale[0] * inArrayData[i] + shift[0];
        packedVBO[vboidx++] = scale[1] * inArrayData[i + 1] + shift[1];
        packedVBO[vboidx++] = scale[2] * inArrayData[i + 2] + shift[2];
        packedVBO[vboidx++] = scale[3] * inArrayData[i + 3] + shift[3];
      };
    }

    // for each entry in the flat array process it
    for (let index = 0; index < flatSize; index++) {
      const inArrayId = numComp * flatIdMap[index];
      addAPoint(inArrayId);
    }
    result.nativeArray = packedVBO;
    return result;
  }
  function getNormal(pointData, i0, i1, i2) {
    const v1 = [pointData[i2 * 3] - pointData[i1 * 3], pointData[i2 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i2 * 3 + 2] - pointData[i1 * 3 + 2]];
    const v2 = [pointData[i0 * 3] - pointData[i1 * 3], pointData[i0 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i0 * 3 + 2] - pointData[i1 * 3 + 2]];
    const result = [];
    cross(v1, v2, result);
    normalize(result);
    return result;
  }
  function generateNormals(cellArray, pointArray) {
    const pointData = pointArray.getData();
    const cellArrayData = cellArray.getData();
    if (!cellArrayData || !pointData) {
      return null;
    }

    // return a cellArray of normals
    const packedVBO = new Int8Array(cellArray.getNumberOfCells() * 4);
    const size = cellArrayData.length;
    let vboidx = 0;
    for (let index = 0; index < size;) {
      const normal = getNormal(pointData, cellArrayData[index + 1], cellArrayData[index + 2], cellArrayData[index + 3]);
      packedVBO[vboidx++] = 127 * normal[0];
      packedVBO[vboidx++] = 127 * normal[1];
      packedVBO[vboidx++] = 127 * normal[2];
      packedVBO[vboidx++] = 127;
      index += cellArrayData[index] + 1;
    }
    return packedVBO;
  }

  // ----------------------------------------------------------------------------
  // vtkWebGPUBufferManager methods
  // ----------------------------------------------------------------------------
  function vtkWebGPUBufferManager(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUBufferManager');
    function _createBuffer(req) {
      // if a dataArray is provided set the nativeArray
      if (req.dataArray && !req.nativeArray) {
        req.nativeArray = req.dataArray.getData();
      }
      let buffer;
      let gpuUsage;

      // handle index buffers
      if (req.usage === BufferUsage$5.Index) {
        // todo change to FlattenedIndex to be more clear
        buffer = vtkWebGPUIndexBuffer$1.newInstance({
          label: req.label
        });
        buffer.setDevice(model.device);
        /* eslint-disable no-bitwise */
        gpuUsage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST;
        /* eslint-enable no-bitwise */
        buffer.buildIndexBuffer(req);
        buffer.createAndWrite(req.nativeArray, gpuUsage);
        buffer.setArrayInformation([{
          format: req.format
        }]);
      }

      // create one if not done already
      if (!buffer) {
        buffer = vtkWebGPUBuffer$1.newInstance({
          label: req.label
        });
        buffer.setDevice(model.device);
      }

      // handle uniform buffers
      if (req.usage === BufferUsage$5.UniformArray) {
        /* eslint-disable no-bitwise */
        gpuUsage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
        /* eslint-enable no-bitwise */
        buffer.createAndWrite(req.nativeArray, gpuUsage);
      }

      // handle storage buffers
      if (req.usage === BufferUsage$5.Storage) {
        /* eslint-disable no-bitwise */
        gpuUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
        /* eslint-enable no-bitwise */
        buffer.createAndWrite(req.nativeArray, gpuUsage);
      }

      // handle textures
      if (req.usage === BufferUsage$5.Texture) {
        /* eslint-disable no-bitwise */
        gpuUsage = GPUBufferUsage.COPY_SRC;
        /* eslint-enable no-bitwise */
        buffer.createAndWrite(req.nativeArray, gpuUsage);
      }

      // all of the below types that have gpuUsage = VERTEX require format
      // to be provided.

      // handle point data
      if (req.usage === BufferUsage$5.PointArray) {
        gpuUsage = GPUBufferUsage.VERTEX;
        const arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
        const result = packArray(req.indexBuffer, req.dataArray.getData(), req.dataArray.getNumberOfComponents(), arrayType, {
          packExtra: req.packExtra,
          shift: req.shift,
          scale: req.scale,
          cellData: req.cellData,
          cellOffset: req.cellOffset
        });
        buffer.createAndWrite(result.nativeArray, gpuUsage);
        buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
        buffer.setArrayInformation([{
          offset: 0,
          format: req.format,
          interpolation: req.cellData ? 'flat' : 'perspective'
        }]);
      }

      // handle normals from points, snorm8x4
      if (req.usage === BufferUsage$5.NormalsFromPoints) {
        gpuUsage = GPUBufferUsage.VERTEX;
        const arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
        const normals = generateNormals(req.cells, req.dataArray);
        const result = packArray(req.indexBuffer, normals, 4, arrayType, {
          cellData: true
        });
        buffer.createAndWrite(result.nativeArray, gpuUsage);
        buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
        buffer.setArrayInformation([{
          offset: 0,
          format: req.format,
          interpolation: 'flat'
        }]);
      }
      if (req.usage === BufferUsage$5.RawVertex) {
        gpuUsage = GPUBufferUsage.VERTEX;
        buffer.createAndWrite(req.nativeArray, gpuUsage);
        buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
        buffer.setArrayInformation([{
          offset: 0,
          format: req.format
        }]);
      }
      buffer.setSourceTime(req.time);
      return buffer;
    }

    // is the buffer already present?
    publicAPI.hasBuffer = hash => model.device.hasCachedObject(hash);
    publicAPI.getBuffer = req => {
      // if we have a source the get/create/cache the buffer
      if (req.hash) {
        return model.device.getCachedObject(req.hash, _createBuffer, req);
      }
      return _createBuffer(req);
    };
    publicAPI.getBufferForPointArray = (dataArray, indexBuffer) => {
      const format = _getFormatForDataArray(dataArray);
      const buffRequest = {
        hash: `${dataArray.getMTime()}I${indexBuffer.getMTime()}${format}`,
        usage: BufferUsage$5.PointArray,
        format,
        dataArray,
        indexBuffer
      };
      return publicAPI.getBuffer(buffRequest);
    };
    publicAPI.getFullScreenQuadBuffer = () => {
      if (model.fullScreenQuadBuffer) {
        return model.fullScreenQuadBuffer;
      }
      model.fullScreenQuadBuffer = vtkWebGPUBuffer$1.newInstance();
      model.fullScreenQuadBuffer.setDevice(model.device);

      // prettier-ignore
      const array = new Float32Array([-1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0.0]);
      model.fullScreenQuadBuffer.createAndWrite(array, GPUBufferUsage.VERTEX);
      model.fullScreenQuadBuffer.setStrideInBytes(12);
      model.fullScreenQuadBuffer.setArrayInformation([{
        offset: 0,
        format: 'float32x3'
      }]);
      return model.fullScreenQuadBuffer;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$L = {
    device: null,
    fullScreenQuadBuffer: null
  };

  // ----------------------------------------------------------------------------

  function extend$M(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$L, initialValues);

    // Object methods
    obj(publicAPI, model);
    setGet(publicAPI, model, ['device']);
    vtkWebGPUBufferManager(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$M = newInstance$1I(extend$M);

  // ----------------------------------------------------------------------------

  var vtkWebGPUBufferManager$1 = {
    newInstance: newInstance$M,
    extend: extend$M,
    ...STATIC$1,
    ...Constants$2
  };

  const {
    BufferUsage: BufferUsage$4
  } = vtkWebGPUBufferManager$1;
  const {
    vtkErrorMacro: vtkErrorMacro$e
  } = macro;

  // ----------------------------------------------------------------------------
  // vtkWebGPUStorageBuffer - similar to the UniformBuffer class
  // but YOU are responsible for layout issues and alignment.
  // The order you add entries is the order they will be layed out
  // in memory. But you must follow layout rules.
  // ----------------------------------------------------------------------------

  // ----------------------------------------------------------------------------
  // vtkWebGPUStorageBuffer methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUStorageBuffer(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUStorageBuffer');
    publicAPI.addEntry = (name, type) => {
      if (model._bufferEntryNames.has(name)) {
        vtkErrorMacro$e(`entry named ${name} already exists`);
        return;
      }
      model._bufferEntryNames.set(name, model.bufferEntries.length);
      const sizeInBytes = vtkWebGPUTypes.getByteStrideFromShaderFormat(type);
      model.bufferEntries.push({
        name,
        type,
        sizeInBytes,
        offset: model.sizeInBytes,
        nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type)
      });
      model.sizeInBytes += sizeInBytes;
    };
    publicAPI.send = device => {
      if (!model._buffer) {
        const req = {
          nativeArray: model.Float32Array,
          usage: BufferUsage$4.Storage,
          label: model.label
        };
        model._buffer = device.getBufferManager().getBuffer(req);
        model.bindGroupTime.modified();
        model._sendTime.modified();
        return;
      }
      device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);
      model._sendTime.modified();
    };
    publicAPI.createView = type => {
      if (type in model === false) {
        if (!model.arrayBuffer) {
          model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);
        }
        model[type] = macro.newTypedArray(type, model.arrayBuffer);
      }
    };
    publicAPI.setValue = (name, instance, val) => {
      const idx = model._bufferEntryNames.get(name);
      if (idx === undefined) {
        vtkErrorMacro$e(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;
    };
    publicAPI.setArray = (name, instance, arr) => {
      const idx = model._bufferEntryNames.get(name);
      if (idx === undefined) {
        vtkErrorMacro$e(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      const ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let i = 0; i < arr.length; i++) {
        view[ioffset + i] = arr[i];
      }
    };
    publicAPI.setAllInstancesFromArray = (name, arr) => {
      const idx = model._bufferEntryNames.get(name);
      if (idx === undefined) {
        vtkErrorMacro$e(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      const numComponents = arr.length / model.numberOfInstances;
      for (let inst = 0; inst < model.numberOfInstances; inst++) {
        const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
        for (let i = 0; i < numComponents; i++) {
          view[ioffset + i] = arr[inst * numComponents + i];
        }
      }
    };
    publicAPI.setAllInstancesFromArrayColorToFloat = (name, arr) => {
      const idx = model._bufferEntryNames.get(name);
      if (idx === undefined) {
        vtkErrorMacro$e(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      const numComponents = arr.length / model.numberOfInstances;
      for (let inst = 0; inst < model.numberOfInstances; inst++) {
        const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
        for (let i = 0; i < numComponents; i++) {
          view[ioffset + i] = arr[inst * numComponents + i] / 255.0;
        }
      }
    };
    publicAPI.setAllInstancesFromArray3x3To4x4 = (name, arr) => {
      const idx = model._bufferEntryNames.get(name);
      if (idx === undefined) {
        vtkErrorMacro$e(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      const numComponents = 9;
      for (let inst = 0; inst < model.numberOfInstances; inst++) {
        const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
        for (let j = 0; j < 3; j++) {
          for (let i = 0; i < 3; i++) {
            view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];
          }
        }
      }
    };
    publicAPI.getSendTime = () => model._sendTime.getMTime();
    publicAPI.getShaderCode = (binding, group) => {
      const lines = [`struct ${model.label}StructEntry\n{`];
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        lines.push(`  ${entry.name}: ${entry.type},`);
      }
      lines.push(`
};
struct ${model.label}Struct
{
  values: array<${model.label}StructEntry>,
};
@binding(${binding}) @group(${group}) var<storage, read> ${model.label}: ${model.label}Struct;
`);
      return lines.join('\n');
    };
    publicAPI.getBindGroupEntry = () => {
      const foo = {
        resource: {
          buffer: model._buffer.getHandle()
        }
      };
      return foo;
    };
    publicAPI.clearData = () => {
      model.numberOfInstances = 0;
      model.sizeInBytes = 0;
      model.bufferEntries = [];
      model._bufferEntryNames = new Map();
      model._buffer = null;
      delete model.arrayBuffer;
      delete model.Float32Array;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$K = {
    bufferEntries: null,
    bufferEntryNames: null,
    sizeInBytes: 0,
    label: null,
    numberOfInstances: 1
  };

  // ----------------------------------------------------------------------------

  function extend$L(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$K, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);

    // Internal objects
    model._bufferEntryNames = new Map();
    model.bufferEntries = [];
    model._sendTime = {};
    macro.obj(model._sendTime, {
      mtime: 0
    });
    model.bindGroupTime = {};
    macro.obj(model.bindGroupTime, {
      mtime: 0
    });

    // default SSBO desc
    model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
      buffer: {
        type: 'read-only-storage'
      }
    };
    macro.get(publicAPI, model, ['bindGroupTime']);
    macro.setGet(publicAPI, model, ['device', 'bindGroupLayoutEntry', 'label', 'numberOfInstances', 'sizeInBytes']);

    // Object methods
    vtkWebGPUStorageBuffer(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$L = macro.newInstance(extend$L, 'vtkWebGPUStorageBuffer');

  // ----------------------------------------------------------------------------

  var vtkWebGPUStorageBuffer$1 = {
    newInstance: newInstance$L,
    extend: extend$L
  };

  const {
    BufferUsage: BufferUsage$3
  } = vtkWebGPUBufferManager$1;
  const {
    vtkErrorMacro: vtkErrorMacro$d
  } = macro;

  // ----------------------------------------------------------------------------
  // vtkWebGPUUniformBuffer methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUUniformBuffer(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUUniformBuffer');
    publicAPI.addEntry = (name, type) => {
      if (model._bufferEntryNames.has(name)) {
        vtkErrorMacro$d(`entry named ${name} already exists`);
        return;
      }
      model.sortDirty = true;
      model._bufferEntryNames.set(name, model.bufferEntries.length);
      model.bufferEntries.push({
        name,
        type,
        sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),
        offset: -1,
        nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),
        packed: false
      });
    };

    // UBOs have layout rules in terms of how memory is aligned so we
    // have to be careful how we order the entries. For example a vec4<f32>
    // must be aligned on a 16 byte offset, etc. See
    // https://gpuweb.github.io/gpuweb/wgsl/#memory-layouts
    // for more details. Right now you can create a situation that would fail
    // in the future we could add dummy spacer entries where needed to
    // handle alignment issues
    publicAPI.sortBufferEntries = () => {
      if (!model.sortDirty) {
        return;
      }
      let currOffset = 0;
      const newEntries = [];

      // compute the max alignment, this is required as WebGPU defines a UBO to have
      // a size that is a multiple of the maxAlignment
      let maxAlignment = 4;
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (entry.sizeInBytes % 16 === 0) {
          maxAlignment = Math.max(16, maxAlignment);
        }
        if (entry.sizeInBytes % 8 === 0) {
          maxAlignment = Math.max(8, maxAlignment);
        }
      }

      // pack anything whose size is a multiple of 16 bytes first
      // this includes a couple types that don't require 16 byte alignment
      // such as mat2x2<f32> but that is OK
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (entry.packed === false && entry.sizeInBytes % 16 === 0) {
          entry.packed = true;
          entry.offset = currOffset;
          newEntries.push(entry);
          currOffset += entry.sizeInBytes;
        }
      }

      // now it gets tough, we have the following common types (f32, i32, u32)
      // - vec2<f32> 8 byte size, 8 byte alignment
      // - vec3<f32> 12 byte size, 16 byte alignment
      // - f32 4 byte size, 4 byte alignment

      // try adding 12 byte, 4 byte pairs
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (entry.packed === false && entry.sizeInBytes === 12) {
          for (let i2 = 0; i2 < model.bufferEntries.length; i2++) {
            const entry2 = model.bufferEntries[i2];
            if (entry2.packed === false && entry2.sizeInBytes === 4) {
              entry.packed = true;
              entry.offset = currOffset;
              newEntries.push(entry);
              currOffset += entry.sizeInBytes;
              entry2.packed = true;
              entry2.offset = currOffset;
              newEntries.push(entry2);
              currOffset += entry2.sizeInBytes;
              break;
            }
          }
        }
      }

      // try adding 8 byte, 8 byte pairs
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (!entry.packed && entry.sizeInBytes % 8 === 0) {
          for (let i2 = i + 1; i2 < model.bufferEntries.length; i2++) {
            const entry2 = model.bufferEntries[i2];
            if (!entry2.packed && entry2.sizeInBytes % 8 === 0) {
              entry.packed = true;
              entry.offset = currOffset;
              newEntries.push(entry);
              currOffset += entry.sizeInBytes;
              entry2.packed = true;
              entry2.offset = currOffset;
              newEntries.push(entry2);
              currOffset += entry2.sizeInBytes;
              break;
            }
          }
        }
      }

      // try adding 8 byte, 4 byte 4 byte triplets
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (!entry.packed && entry.sizeInBytes % 8 === 0) {
          let found = false;
          for (let i2 = 0; !found && i2 < model.bufferEntries.length; i2++) {
            const entry2 = model.bufferEntries[i2];
            if (!entry2.packed && entry2.sizeInBytes === 4) {
              for (let i3 = i2 + 1; i3 < model.bufferEntries.length; i3++) {
                const entry3 = model.bufferEntries[i3];
                if (!entry3.packed && entry3.sizeInBytes === 4) {
                  entry.packed = true;
                  entry.offset = currOffset;
                  newEntries.push(entry);
                  currOffset += entry.sizeInBytes;
                  entry2.packed = true;
                  entry2.offset = currOffset;
                  newEntries.push(entry2);
                  currOffset += entry2.sizeInBytes;
                  entry3.packed = true;
                  entry3.offset = currOffset;
                  newEntries.push(entry3);
                  currOffset += entry3.sizeInBytes;
                  found = true;
                  break;
                }
              }
            }
          }
        }
      }

      // Add anything remaining that is larger than 4 bytes and hope we get lucky.
      // Likely if there is more than one item added here it will result
      // in a failed UBO
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (!entry.packed && entry.sizeInBytes > 4) {
          entry.packed = true;
          entry.offset = currOffset;
          newEntries.push(entry);
          currOffset += entry.sizeInBytes;
        }
      }

      // finally add remaining 4 byte items
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        if (!entry.packed) {
          entry.packed = true;
          entry.offset = currOffset;
          newEntries.push(entry);
          currOffset += entry.sizeInBytes;
        }
      }

      // update entries and entryNames
      model.bufferEntries = newEntries;
      model._bufferEntryNames.clear();
      for (let i = 0; i < model.bufferEntries.length; i++) {
        model._bufferEntryNames.set(model.bufferEntries[i].name, i);
      }
      model.sizeInBytes = currOffset;
      model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);
      model.sortDirty = false;
    };
    publicAPI.sendIfNeeded = device => {
      if (!model.UBO) {
        const req = {
          nativeArray: model.Float32Array,
          usage: BufferUsage$3.UniformArray,
          label: model.label
        };
        model.UBO = device.getBufferManager().getBuffer(req);
        model.bindGroupTime.modified();
        model.sendDirty = false;
      }

      // send data down if needed
      if (model.sendDirty) {
        device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);
        model.sendDirty = false;
      }

      // always updated as mappers depend on this time
      // it is more of a sentIfNeededTime
      model.sendTime.modified();
    };
    publicAPI.createView = type => {
      if (type in model === false) {
        if (!model.arrayBuffer) {
          model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);
        }
        model[type] = macro.newTypedArray(type, model.arrayBuffer);
      }
    };
    publicAPI.setValue = (name, val) => {
      publicAPI.sortBufferEntries();
      const idx = model._bufferEntryNames.get(name);
      if (idx === undefined) {
        vtkErrorMacro$d(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      if (entry.lastValue !== val) {
        view[entry.offset / view.BYTES_PER_ELEMENT] = val;
        model.sendDirty = true;
      }
      entry.lastValue = val;
    };
    publicAPI.setArray = (name, arr) => {
      publicAPI.sortBufferEntries();
      const idx = model._bufferEntryNames.get(name);
      if (idx === undefined) {
        vtkErrorMacro$d(`entry named ${name} not found in UBO`);
        return;
      }
      const entry = model.bufferEntries[idx];
      publicAPI.createView(entry.nativeType);
      const view = model[entry.nativeType];
      let changed = false;
      for (let i = 0; i < arr.length; i++) {
        if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {
          view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];
          changed = true;
        }
      }
      if (changed) {
        model.sendDirty = true;
        entry.lastValue = [...arr];
      }
    };
    publicAPI.getBindGroupEntry = () => {
      const foo = {
        resource: {
          buffer: model.UBO.getHandle()
        }
      };
      return foo;
    };
    publicAPI.getSendTime = () => model.sendTime.getMTime();
    publicAPI.getShaderCode = (binding, group) => {
      // sort the entries
      publicAPI.sortBufferEntries();
      const lines = [`struct ${model.label}Struct\n{`];
      for (let i = 0; i < model.bufferEntries.length; i++) {
        const entry = model.bufferEntries[i];
        lines.push(`  ${entry.name}: ${entry.type},`);
      }
      lines.push(`};\n@binding(${binding}) @group(${group}) var<uniform> ${model.label}: ${model.label}Struct;`);
      return lines.join('\n');
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$J = {
    bufferEntries: null,
    bufferEntryNames: null,
    sizeInBytes: 0,
    label: null,
    bindGroupLayoutEntry: null,
    bindGroupEntry: null
  };

  // ----------------------------------------------------------------------------

  function extend$K(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$J, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);

    // Internal objects
    model._bufferEntryNames = new Map();
    model.bufferEntries = [];

    // default UBO desc
    model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
      buffer: {
        type: 'uniform'
      }
    };
    model.sendTime = {};
    macro.obj(model.sendTime, {
      mtime: 0
    });
    model.bindGroupTime = {};
    macro.obj(model.bindGroupTime, {
      mtime: 0
    });
    model.sendDirty = true;
    model.sortDirty = true;
    macro.get(publicAPI, model, ['binding', 'bindGroupTime']);
    macro.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'device', 'label', 'sizeInBytes']);

    // Object methods
    vtkWebGPUUniformBuffer(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$K = macro.newInstance(extend$K, 'vtkWebGPUUniformBuffer');

  // ----------------------------------------------------------------------------

  var vtkWebGPUUniformBuffer$1 = {
    newInstance: newInstance$K,
    extend: extend$K
  };

  const {
    vtkDebugMacro: vtkDebugMacro$4
  } = macro$1;
  const clearFragColorTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;

  //VTK::RenderEncoder::Impl
  return output;
}
`;
  const clearFragTextureTemplate = `
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);
  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);
  // textureSampleLevel gets rid of some ugly artifacts
  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0.0);
  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
  const _fsqClearMat4 = new Float64Array(16);
  const _tNormalMat4 = new Float64Array(16);

  // Light type index gives either 0, 1, or 2 which indicates what type of light there is.
  // While technically, there are only spot and directional lights, within the CellArrayMapper
  // there is a third, positional light. It is technically just a variant of a spot light with
  // a cone angle of 90 or above, however certain calculations can be skipped if it is treated
  // separately.
  // The mappings are shown below:
  // 0 -> positional light
  // 1 -> directional light
  // 2 -> spot light
  function getLightTypeIndex(light) {
    if (light.getPositional()) {
      if (light.getConeAngle() >= 90) {
        return 0;
      }
      return 2;
    }
    return 1;
  }

  // ----------------------------------------------------------------------------
  // vtkWebGPURenderer methods
  // ----------------------------------------------------------------------------
  /* eslint-disable no-bitwise */

  function vtkWebGPURenderer(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPURenderer');

    // Builds myself.
    publicAPI.buildPass = prepass => {
      if (prepass) {
        if (!model.renderable) {
          return;
        }
        model.camera = model.renderable.getActiveCamera();
        publicAPI.updateLights();
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.camera);
        publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
        publicAPI.removeUnusedNodes();
        model.webgpuCamera = publicAPI.getViewNodeFor(model.camera);
        publicAPI.updateStabilizedMatrix();
      }
    };
    publicAPI.updateStabilizedMatrix = () => {
      // This method is designed to help with floating point
      // issues when rendering datasets that push the limits of
      // resolutions on float.
      //
      // One of the most common cases is when the dataset is located far
      // away from the origin relative to the clipping range we are looking
      // at. For that case we want to perform the floating point sensitive
      // multiplications on the CPU in double. To this end we want the
      // vertex rendering ops to look something like
      //
      // Compute shifted points and load those into the VBO
      // pointCoordsSC = WorldToStabilizedMatrix * pointCoords;
      //
      // In the vertex shader do the following
      // positionVC = StabilizedToDeviceMatrix * ModelToStabilizedMatrix*vertexIn;
      //
      // We use two matrices because it is expensive to change the
      // WorldToStabilized matrix as we have to reupload all pointCoords
      // So that matrix (MCSCMatrix) is fairly static, the Stabilized to
      // Device matrix is the one that gets updated every time the camera
      // changes.
      //
      // The basic idea is that we should translate the data so that
      // when the center of the view frustum moves a lot
      // we recenter it. The center of the view frustum is roughly
      // camPos + dirOfProj*(far + near)*0.5
      const clipRange = model.camera.getClippingRange();
      const pos = model.camera.getPositionByReference();
      const dop = model.camera.getDirectionOfProjectionByReference();
      const center = [];
      const offset = [];
      scale$1(offset, dop, 0.5 * (clipRange[0] + clipRange[1]));
      add$1(center, pos, offset);
      sub(offset, center, model.stabilizedCenter);
      const length = len(offset);
      if (length / (clipRange[1] - clipRange[0]) > model.recenterThreshold) {
        model.stabilizedCenter = center;
        model.stabilizedTime.modified();
      }
    };
    publicAPI.updateLights = () => {
      let count = 0;
      const lights = model.renderable.getLightsByReference();
      for (let index = 0; index < lights.length; ++index) {
        if (lights[index].getSwitch() > 0.0) {
          count++;
        }
      }
      if (!count) {
        vtkDebugMacro$4('No lights are on, creating one.');
        model.renderable.createLight();
      }
      return count;
    };
    publicAPI.updateUBO = () => {
      // make sure the data is up to date
      // has the camera changed?
      const utime = model.UBO.getSendTime();
      if (model._parent.getMTime() > utime || publicAPI.getMTime() > utime || model.camera.getMTime() > utime || model.renderable.getMTime() > utime) {
        const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
        model.UBO.setArray('WCVCMatrix', keyMats.wcvc);
        model.UBO.setArray('SCPCMatrix', keyMats.scpc);
        model.UBO.setArray('PCSCMatrix', keyMats.pcsc);
        model.UBO.setArray('SCVCMatrix', keyMats.scvc);
        model.UBO.setArray('VCPCMatrix', keyMats.vcpc);
        model.UBO.setArray('WCVCNormals', keyMats.normalMatrix);
        model.UBO.setValue('LightCount', model.renderable.getLights().length);
        model.UBO.setValue('MaxEnvironmentMipLevel', model.renderable.getEnvironmentTexture()?.getMipLevel());
        model.UBO.setValue('BackgroundDiffuseStrength', model.renderable.getEnvironmentTextureDiffuseStrength());
        model.UBO.setValue('BackgroundSpecularStrength', model.renderable.getEnvironmentTextureSpecularStrength());
        const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
        model.UBO.setArray('viewportSize', [tsize.usize, tsize.vsize]);
        model.UBO.setValue('cameraParallel', model.camera.getParallelProjection());
        const device = model._parent.getDevice();
        model.UBO.sendIfNeeded(device);
      }
    };
    publicAPI.updateSSBO = () => {
      const lights = model.renderable.getLights();
      const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
      let lightTimeString = `${model.renderable.getMTime()}`;
      for (let i = 0; i < lights.length; i++) {
        lightTimeString += lights[i].getMTime();
      }
      if (lightTimeString !== model.lightTimeString) {
        const lightPosArray = new Float32Array(lights.length * 4);
        const lightDirArray = new Float32Array(lights.length * 4);
        const lightColorArray = new Float32Array(lights.length * 4);
        const lightTypeArray = new Float32Array(lights.length * 4);
        for (let i = 0; i < lights.length; i++) {
          const offset = i * 4;

          // Position
          const viewCoordinatePosition = lights[i].getPosition();
          transformMat4$1(viewCoordinatePosition, viewCoordinatePosition, keyMats.wcvc);
          // viewCoordinatePosition
          lightPosArray[offset] = viewCoordinatePosition[0];
          lightPosArray[offset + 1] = viewCoordinatePosition[1];
          lightPosArray[offset + 2] = viewCoordinatePosition[2];
          lightPosArray[offset + 3] = 0;

          // Rotation (All are negative to correct for -Z being forward)
          lightDirArray[offset] = -lights[i].getDirection()[0];
          lightDirArray[offset + 1] = -lights[i].getDirection()[1];
          lightDirArray[offset + 2] = -lights[i].getDirection()[2];
          lightDirArray[offset + 3] = 0;

          // Color
          lightColorArray[offset] = lights[i].getColor()[0];
          lightColorArray[offset + 1] = lights[i].getColor()[1];
          lightColorArray[offset + 2] = lights[i].getColor()[2];
          lightColorArray[offset + 3] = lights[i].getIntensity() * 5; // arbitrary multiplication to fix the dullness of low value PBR lights

          // Type
          lightTypeArray[offset] = getLightTypeIndex(lights[i]); // Type
          lightTypeArray[offset + 1] = Math.cos(radiansFromDegrees(lights[i].getConeAngle())); // Inner Phi, should probably do some check on these to make sure they dont excede limits
          lightTypeArray[offset + 2] = Math.cos(radiansFromDegrees(lights[i].getConeAngle() + lights[i].getConeFalloff())); // Outer Phi
          lightTypeArray[offset + 3] = 0;
        }

        // Im not sure how correct this is, but this is what the example does
        // https://kitware.github.io/vtk-js/api/Rendering_WebGPU_VolumePassFSQ.html
        model.SSBO.clearData();
        model.SSBO.setNumberOfInstances(lights.length);
        model.SSBO.addEntry('LightPos', 'vec4<f32>'); // Position
        model.SSBO.addEntry('LightDir', 'vec4<f32>'); // Direction
        model.SSBO.addEntry('LightColor', 'vec4<f32>'); // Color (r, g, b, intensity)
        model.SSBO.addEntry('LightData', 'vec4<f32>'); // Other data (type, etc, etc, etc)

        model.SSBO.setAllInstancesFromArray('LightPos', lightPosArray);
        model.SSBO.setAllInstancesFromArray('LightDir', lightDirArray);
        model.SSBO.setAllInstancesFromArray('LightColor', lightColorArray);
        model.SSBO.setAllInstancesFromArray('LightData', lightTypeArray);
        const device = model._parent.getDevice();
        model.SSBO.send(device);
      }
      model.lightTimeString = lightTimeString;
    };
    publicAPI.scissorAndViewport = encoder => {
      const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
      encoder.getHandle().setViewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize, 0.0, 1.0);
      // set scissor
      encoder.getHandle().setScissorRect(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
    };
    publicAPI.bindUBO = renderEncoder => {
      renderEncoder.activateBindGroup(model.bindGroup);
    };

    // Renders myself
    publicAPI.opaquePass = prepass => {
      if (prepass) {
        model.renderEncoder.begin(model._parent.getCommandEncoder());
        publicAPI.updateUBO();
        publicAPI.updateSSBO();
      } else {
        publicAPI.scissorAndViewport(model.renderEncoder);
        publicAPI.clear();
        model.renderEncoder.end();
      }
    };
    publicAPI.clear = () => {
      if (model.renderable.getTransparent() || model.suppressClear) {
        return;
      }
      const device = model._parent.getDevice();
      // Normal Solid Color
      if (!model.clearFSQ) {
        model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
        model.clearFSQ.setDevice(device);
        model.clearFSQ.setPipelineHash('clearfsq');
        model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
        const ubo = vtkWebGPUUniformBuffer$1.newInstance({
          label: 'mapperUBO'
        });
        ubo.addEntry('FSQMatrix', 'mat4x4<f32>');
        ubo.addEntry('BackgroundColor', 'vec4<f32>');
        model.clearFSQ.setUBO(ubo);
        model.backgroundTex = model.renderable.getEnvironmentTexture();
      }
      // Textured Background
      if (model.clearFSQ.getPipelineHash() !== 'clearfsqwithtexture' && model.renderable.getUseEnvironmentTextureAsBackground() && model.backgroundTex?.getImageLoaded()) {
        model.clearFSQ.setFragmentShaderTemplate(clearFragTextureTemplate);
        const ubo = vtkWebGPUUniformBuffer$1.newInstance({
          label: 'mapperUBO'
        });
        ubo.addEntry('FSQMatrix', 'mat4x4<f32>');
        ubo.addEntry('BackgroundColor', 'vec4<f32>');
        model.clearFSQ.setUBO(ubo);
        const environmentTextureHash = device.getTextureManager().getTextureForVTKTexture(model.backgroundTex);
        if (environmentTextureHash.getReady()) {
          const tview = environmentTextureHash.createView(`EnvironmentTexture`);
          model.clearFSQ.setTextureViews([tview]);
          model.backgroundTexLoaded = true;
          const interpolate = model.backgroundTex.getInterpolate() ? 'linear' : 'nearest';
          tview.addSampler(device, {
            addressModeU: 'repeat',
            addressModeV: 'clamp-to-edge',
            addressModeW: 'repeat',
            minFilter: interpolate,
            magFilter: interpolate,
            mipmapFilter: 'linear'
          });
        }
        model.clearFSQ.setPipelineHash('clearfsqwithtexture');
      } else if (model.clearFSQ.getPipelineHash() === 'clearfsqwithtexture' && !model.renderable.getUseEnvironmentTextureAsBackground()) {
        // In case the mode is changed at runtime
        model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
        model.clearFSQ.setDevice(device);
        model.clearFSQ.setPipelineHash('clearfsq');
        model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
        const ubo = vtkWebGPUUniformBuffer$1.newInstance({
          label: 'mapperUBO'
        });
        ubo.addEntry('FSQMatrix', 'mat4x4<f32>');
        ubo.addEntry('BackgroundColor', 'vec4<f32>');
        model.clearFSQ.setUBO(ubo);
      }
      const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
      const background = model.renderable.getBackgroundByReference();
      model.clearFSQ.getUBO().setArray('BackgroundColor', background);
      transpose(_tNormalMat4, keyMats.normalMatrix);
      mul(_fsqClearMat4, keyMats.scvc, keyMats.pcsc);
      mul(_fsqClearMat4, _tNormalMat4, _fsqClearMat4);
      model.clearFSQ.getUBO().setArray('FSQMatrix', _fsqClearMat4);
      model.clearFSQ.getUBO().sendIfNeeded(device);
      model.clearFSQ.prepareAndDraw(model.renderEncoder);
    };
    publicAPI.translucentPass = prepass => {
      if (prepass) {
        model.renderEncoder.begin(model._parent.getCommandEncoder());
      } else {
        publicAPI.scissorAndViewport(model.renderEncoder);
        model.renderEncoder.end();
      }
    };
    publicAPI.volumeDepthRangePass = prepass => {
      if (prepass) {
        model.renderEncoder.begin(model._parent.getCommandEncoder());
      } else {
        publicAPI.scissorAndViewport(model.renderEncoder);
        model.renderEncoder.end();
      }
    };
    publicAPI.getAspectRatio = () => {
      const size = model._parent.getSizeByReference();
      const viewport = model.renderable.getViewportByReference();
      return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
    };
    publicAPI.convertToOpenGLDepth = val => model.webgpuCamera.convertToOpenGLDepth(val);
    publicAPI.getYInvertedTiledSizeAndOrigin = () => {
      const res = publicAPI.getTiledSizeAndOrigin();
      const size = model._parent.getSizeByReference();
      res.lowerLeftV = size[1] - res.vsize - res.lowerLeftV;
      return res;
    };
    publicAPI.getTiledSizeAndOrigin = () => {
      const vport = model.renderable.getViewportByReference();

      // if there is no window assume 0 1
      const tileViewPort = [0.0, 0.0, 1.0, 1.0];

      // find the lower left corner of the viewport, taking into account the
      // lower left boundary of this tile
      const vpu = vport[0] - tileViewPort[0];
      const vpv = vport[1] - tileViewPort[1];

      // store the result as a pixel value
      const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
      const lowerLeftU = Math.round(ndvp[0]);
      const lowerLeftV = Math.round(ndvp[1]);

      // find the upper right corner of the viewport, taking into account the
      // lower left boundary of this tile
      const vpu2 = vport[2] - tileViewPort[0];
      const vpv2 = vport[3] - tileViewPort[1];
      const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);

      // now compute the size of the intersection of the viewport with the
      // current tile
      let usize = Math.round(ndvp2[0]) - lowerLeftU;
      let vsize = Math.round(ndvp2[1]) - lowerLeftV;
      if (usize < 0) {
        usize = 0;
      }
      if (vsize < 0) {
        vsize = 0;
      }
      return {
        usize,
        vsize,
        lowerLeftU,
        lowerLeftV
      };
    };
    publicAPI.getPropFromID = id => {
      for (let i = 0; i < model.children.length; i++) {
        const res = model.children[i].getPropID ? model.children[i].getPropID() : -1;
        if (res === id) {
          return model.children[i];
        }
      }
      return null;
    };
    publicAPI.getStabilizedTime = () => model.stabilizedTime.getMTime();
    publicAPI.releaseGraphicsResources = () => {
      if (model.selector !== null) {
        model.selector.releaseGraphicsResources();
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$I = {
    bindGroup: null,
    selector: null,
    renderEncoder: null,
    recenterThreshold: 20.0,
    suppressClear: false,
    stabilizedCenter: [0.0, 0.0, 0.0]
  };

  // ----------------------------------------------------------------------------

  function extend$J(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$I, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);

    // UBO
    model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
      label: 'rendererUBO'
    });
    model.UBO.addEntry('WCVCMatrix', 'mat4x4<f32>');
    model.UBO.addEntry('SCPCMatrix', 'mat4x4<f32>');
    model.UBO.addEntry('PCSCMatrix', 'mat4x4<f32>');
    model.UBO.addEntry('SCVCMatrix', 'mat4x4<f32>');
    model.UBO.addEntry('VCPCMatrix', 'mat4x4<f32>');
    model.UBO.addEntry('WCVCNormals', 'mat4x4<f32>');
    model.UBO.addEntry('viewportSize', 'vec2<f32>');
    model.UBO.addEntry('LightCount', 'i32');
    model.UBO.addEntry('MaxEnvironmentMipLevel', 'f32');
    model.UBO.addEntry('BackgroundDiffuseStrength', 'f32');
    model.UBO.addEntry('BackgroundSpecularStrength', 'f32');
    model.UBO.addEntry('cameraParallel', 'u32');

    // SSBO (Light data)
    model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
      label: 'rendererLightSSBO'
    });
    model.lightTimeString = '';
    model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
      label: 'rendererBG'
    });
    model.bindGroup.setBindables([model.UBO, model.SSBO]);
    model.tmpMat4 = identity$3(new Float64Array(16));
    model.stabilizedTime = {};
    obj(model.stabilizedTime, {
      mtime: 0
    });

    // Build VTK API
    get$1(publicAPI, model, ['bindGroup', 'stabilizedTime']);
    getArray(publicAPI, model, ['stabilizedCenter']);
    setGet(publicAPI, model, ['renderEncoder', 'selector', 'suppressClear', 'UBO']);

    // Object methods
    vtkWebGPURenderer(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$J = newInstance$1I(extend$J, 'vtkWebGPURenderer');

  // Register ourself to WebGPU backend if imported
  registerOverride('vtkRenderer', newInstance$J);

  const {
    CoordinateSystem: CoordinateSystem$2
  } = vtkProp$1;

  // ----------------------------------------------------------------------------
  // vtkWebGPUActor methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUActor(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUActor');

    // Builds myself.
    publicAPI.buildPass = prepass => {
      if (prepass) {
        model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
        model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow');
        if (model.propID === undefined) {
          model.propID = model.WebGPURenderWindow.getUniquePropID();
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.renderable.getMapper());
        publicAPI.removeUnusedNodes();
      }
    };

    // we draw textures, then mapper, then post pass textures
    publicAPI.traverseOpaquePass = renderPass => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      if (model.children[0]) {
        model.children[0].traverse(renderPass);
      }
      publicAPI.apply(renderPass, false);
    };

    // we draw textures, then mapper, then post pass textures
    publicAPI.traverseTranslucentPass = renderPass => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      if (model.children[0]) {
        model.children[0].traverse(renderPass);
      }
      publicAPI.apply(renderPass, false);
    };
    publicAPI.queryPass = (prepass, renderPass) => {
      if (prepass) {
        if (!model.renderable || !model.renderable.getVisibility()) {
          return;
        }
        if (model.renderable.getIsOpaque()) {
          renderPass.incrementOpaqueActorCount();
        } else {
          renderPass.incrementTranslucentActorCount();
        }
      }
    };
    publicAPI.getBufferShift = wgpuRen => {
      publicAPI.getKeyMatrices(wgpuRen);
      return model.bufferShift;
    };
    publicAPI.getKeyMatrices = wgpuRen => {
      // has the actor or stabilization center changed?
      if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
        model.renderable.computeMatrix();
        const mcwc = model.renderable.getMatrix();

        // compute the net shift, only apply stabilized coords with world coordinates
        model.bufferShift[0] = mcwc[3];
        model.bufferShift[1] = mcwc[7];
        model.bufferShift[2] = mcwc[11];
        const center = wgpuRen.getStabilizedCenterByReference();
        if (model.renderable.getCoordinateSystem() === CoordinateSystem$2.WORLD) {
          model.bufferShift[0] -= center[0];
          model.bufferShift[1] -= center[1];
          model.bufferShift[2] -= center[2];
        }
        transpose(model.keyMatrices.bcwc, mcwc);
        if (model.renderable.getIsIdentity()) {
          identity$3(model.keyMatrices.normalMatrix);
        } else {
          // we use bcwc BEFORE the translate below (just to get transposed mcvc)
          copy$1(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
          // zero out translation
          model.keyMatrices.normalMatrix[3] = 0.0;
          model.keyMatrices.normalMatrix[7] = 0.0;
          model.keyMatrices.normalMatrix[11] = 0.0;
          invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
          transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        }

        // only need the buffer shift to get to world
        translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);

        // to get to stabilized we also need the center
        if (model.renderable.getCoordinateSystem() === CoordinateSystem$2.WORLD) {
          translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
        } else {
          copy$1(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
        }
        model.keyMatricesTime.modified();
      }
      return model.keyMatrices;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$H = {
    keyMatricesTime: null,
    keyMatrices: null,
    propID: undefined,
    bufferShift: undefined
  };

  // ----------------------------------------------------------------------------

  function extend$I(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$H, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.keyMatricesTime = {};
    macro.obj(model.keyMatricesTime, {
      mtime: 0
    });
    model.keyMatrices = {
      normalMatrix: new Float64Array(16),
      bcwc: new Float64Array(16),
      bcsc: new Float64Array(16)
    };
    macro.get(publicAPI, model, ['propID', 'keyMatricesTime']);
    model.bufferShift = [0, 0, 0, 0];

    // Object methods
    vtkWebGPUActor(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$I = macro.newInstance(extend$I);

  // Register ourself to WebGPU backend if imported
  registerOverride('vtkActor', newInstance$I);

  const {
    CoordinateSystem: CoordinateSystem$1
  } = vtkProp$1;

  // ----------------------------------------------------------------------------
  // vtkWebGPUActor methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUActor2D(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUActor2D');

    // Builds myself.
    publicAPI.buildPass = prepass => {
      if (prepass) {
        model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
        model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow');
        if (model.propID === undefined) {
          model.propID = model.WebGPURenderWindow.getUniquePropID();
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.renderable.getMapper());
        publicAPI.removeUnusedNodes();
      }
    };

    // we draw textures, then mapper, then post pass textures
    publicAPI.traverseOpaquePass = renderPass => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      if (model.children[0]) {
        model.children[0].traverse(renderPass);
      }
      publicAPI.apply(renderPass, false);
    };

    // we draw textures, then mapper, then post pass textures
    publicAPI.traverseTranslucentPass = renderPass => {
      if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
        return;
      }
      publicAPI.apply(renderPass, true);
      if (model.children[0]) {
        model.children[0].traverse(renderPass);
      }
      publicAPI.apply(renderPass, false);
    };
    publicAPI.queryPass = (prepass, renderPass) => {
      if (prepass) {
        if (!model.renderable || !model.renderable.getVisibility()) {
          return;
        }
        if (model.renderable.getIsOpaque()) {
          renderPass.incrementOpaqueActorCount();
        } else {
          renderPass.incrementTranslucentActorCount();
        }
      }
    };
    publicAPI.getBufferShift = wgpuRen => {
      publicAPI.getKeyMatrices(wgpuRen);
      return model.bufferShift;
    };
    publicAPI.getKeyMatrices = wgpuRen => {
      // has the actor or stabilization center changed?
      if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
        // compute the net shift, only apply stabilized coords with world coordinates
        model.bufferShift[0] = 0.0;
        model.bufferShift[1] = 0.0;
        model.bufferShift[2] = 0.0;
        const center = wgpuRen.getStabilizedCenterByReference();
        if (model.renderable.getCoordinateSystem() === CoordinateSystem$1.WORLD) {
          model.bufferShift[0] -= center[0];
          model.bufferShift[1] -= center[1];
          model.bufferShift[2] -= center[2];
        }
        identity$3(model.keyMatrices.bcwc);
        identity$3(model.keyMatrices.normalMatrix);

        // only meed the buffer shift to get to world
        translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);

        // to get to stabilized we also need the center
        if (model.renderable.getCoordinateSystem() === CoordinateSystem$1.WORLD) {
          translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
        } else {
          copy$1(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
        }
        model.keyMatricesTime.modified();
      }
      return model.keyMatrices;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$G = {
    keyMatricesTime: null,
    keyMatrices: null,
    propID: undefined,
    bufferShift: undefined
  };

  // ----------------------------------------------------------------------------

  function extend$H(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$G, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.keyMatricesTime = {};
    macro.obj(model.keyMatricesTime, {
      mtime: 0
    });
    model.keyMatrices = {
      normalMatrix: new Float64Array(16),
      bcwc: new Float64Array(16),
      bcsc: new Float64Array(16)
    };
    macro.get(publicAPI, model, ['propID', 'keyMatricesTime']);
    model.bufferShift = [0, 0, 0, 0];

    // Object methods
    vtkWebGPUActor2D(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$H = macro.newInstance(extend$H);

  // Register ourself to WebGPU backend if imported
  registerOverride('vtkActor2D', newInstance$H);

  // ----------------------------------------------------------------------------
  // vtkWebGPUCubeAxesActor methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUCubeAxesActor(publicAPI, model) {
    model.classHierarchy.push('vtkWebGPUCubeAxesActor');

    // Builds myself.
    publicAPI.buildPass = prepass => {
      if (prepass) {
        model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
        model.WebGPURenderWindow = model.WebGPURenderer.getParent();
        if (!model.CubeAxesActorHelper.getRenderable()) {
          model.CubeAxesActorHelper.setRenderable(model.renderable);
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
        publicAPI.addMissingNode(model.renderable.getGridActor());
        publicAPI.removeUnusedNodes();
      }
    };
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass) {
        const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
        const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
        model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$F = {};

  // ----------------------------------------------------------------------------

  function extend$G(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$F, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();

    // Object methods
    vtkWebGPUCubeAxesActor(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$G = newInstance$1I(extend$G, 'vtkWebGPUCubeAxesActor');

  // Register ourself to WebGPU backend if imported
  registerOverride('vtkCubeAxesActor', newInstance$G);

  const {
    DisplayLocation: DisplayLocation$1
  } = Constants$3;

  // ----------------------------------------------------------------------------
  // vtkProperty2D methods
  // ----------------------------------------------------------------------------

  function vtkProperty2D(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkProperty2D');
    publicAPI.setDisplayLocationToBackground = () => publicAPI.setDisplayLocation(DisplayLocation$1.BACKGROUND);
    publicAPI.setDisplayLocationToForeground = () => publicAPI.setDisplayLocation(DisplayLocation$1.FOREGROUND);
    publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation$6.WIREFRAME);
    publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation$6.SURFACE);
    publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation$6.POINTS);
    publicAPI.getRepresentationAsString = () => macro.enumToString(Representation$6, model.representation);
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------
  const DEFAULT_VALUES$E = {
    color: [1, 1, 1],
    opacity: 1,
    pointSize: 1,
    lineWidth: 1,
    representation: Representation$6.SURFACE,
    displayLocation: DisplayLocation$1.FOREGROUND
  };

  // ----------------------------------------------------------------------------

  function extend$F(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$E, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ['opacity', 'lineWidth', 'pointSize', 'displayLocation', 'representation']);
    macro.setGetArray(publicAPI, model, ['color'], 3);

    // Object methods
    vtkProperty2D(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$F = macro.newInstance(extend$F, 'vtkProperty2D');

  // ----------------------------------------------------------------------------

  var vtkProperty2D$1 = {
    newInstance: newInstance$F,
    extend: extend$F,
    ...Constants$3
  };

  const {
    BufferUsage: BufferUsage$2,
    PrimitiveTypes: PrimitiveTypes$3
  } = vtkWebGPUBufferManager$1;
  const {
    Representation: Representation$2
  } = vtkProperty$1;
  const {
    ScalarMode
  } = vtkMapper$1;
  const {
    CoordinateSystem
  } = vtkProp$1;
  const {
    DisplayLocation
  } = vtkProperty2D$1;
  const vtkWebGPUPolyDataVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
  const vtkWebGPUPolyDataFS = `
struct PBRData {
  diffuse: vec3<f32>,
  specular: vec3<f32>,
}

// Dot product with the max already in it
fn mdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  return max(0.0, dot(a, b));
}
// Dot product with a max in it that does not allow for negative values
// Physically based rendering is accurate as long as normals are accurate,
// however this is pretty often not the case. In order to prevent negative
// values from ruining light calculations and creating zones of zero light,
// this remapping is used, which smoothly clamps the dot product between
// zero and one while still maintaining a good amount of accuracy.
fn cdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  var d: f32 = max(0.0, dot(a, b));
  d = pow((d + 1.0) / 2.0, 2.6);
  return d;
}

// Lambertian diffuse model
fn lambertDiffuse(base: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> vec3<f32> {
  var pi: f32 = 3.14159265359; 
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5);
  return (base/pi)*NdotL;
}

// Yasuhiro Fujii improvement on the Oren-Nayar model
// https://mimosa-pudica.net/improved-oren-nayar.html
// p is surface color, o is roughness
fn fujiiOrenNayar(p: vec3<f32>, o: f32, N: vec3<f32>, L: vec3<f32>, V: vec3<f32>) -> vec3<f32> {
  var invpi: f32 = 0.31830988618; // 1/pi

  var o2 = o*o;
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5); // Less physically accurate, but hides the "seams" between lights better

  var NdotV: f32 = mdot(N, V);
  var LdotV: f32 = mdot(L, V);

  var s: f32 = LdotV - NdotL*NdotV;
  var t: f32 = mix(1.0, max(NdotL, NdotV), step(0.0, s)); // Mix with step is the equivalent of an if statement
  var A: vec3<f32> = 0.5*(o2 / (o2 + 0.33)) + 0.17*p*(o2 / (o2 + 0.13));
  A = invpi*(1 - A);
  var B: f32 = 0.45*(o2 / (o2 + 0.09));
  B = invpi*B;

  return p*NdotL*(A + B*(s/t));
}

// Fresnel portion of BRDF (IOR only, simplified)
fn schlickFresnelIOR(V: vec3<f32>, N: vec3<f32>, ior: f32, k: f32) -> f32 {
  var NdotV: f32 = mdot(V, N);
  var F0: f32 = (pow((ior - 1.0), 2.0) + k*k) / (pow((ior + 1.0), 2.0) + k*k); // This takes into account the roughness, which the other one does not
  return F0 + (1.0 - F0) * pow((1.0-NdotV), 5.0);
}

// Fresnel portion of BRDF (Color ior, better)
fn schlickFresnelRGB(V: vec3<f32>, N: vec3<f32>, F0: vec3<f32>) -> vec3<f32> {
  var NdotV: f32 = mdot(V, N);
  return F0 + (1.0 - F0) * pow((1-NdotV), 5.0);
}

// Normal portion of BRDF
// https://learnopengl.com/PBR/Theory
// Trowbridge-Reitz GGX functions: normal, halfway, roughness^2
fn trGGX(N: vec3<f32>, H: vec3<f32>, a: f32) -> f32 {
  var pi: f32 = 3.14159265359; 

  var a2: f32 = a*a;
  var NdotH = mdot(N, H);
  var NdotH2 = NdotH*NdotH;
  
  var denom: f32 = NdotH2 * (a2 - 1.0) + 1.0;

  return a2 / max((pi*denom*denom), 0.000001);
}

// A VERY bad approximation of anisotropy. Real anisotropic calculations require tangent and bitangent
fn anisotrophicTrGGX(N: vec3<f32>, H: vec3<f32>, O: vec3<f32>, s: f32, a: f32) -> f32 {
  var Op: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(O) * s, 0.)).xyz;

  var ggx1: f32 = trGGX(N + Op*s, H, a);
  var ggx2: f32 = trGGX(N - Op*s, H, a);
  return (0.5 * ggx1 + 0.5 * ggx2);
}

// Geometry portion of BRDF
fn schlickGGX(N: vec3<f32>, X: vec3<f32>, k: f32) -> f32 {
  var NdotX = cdot(N, X);
  return NdotX / max(0.000001, (NdotX*(1.0-k) + k));
}

fn smithSurfaceRoughness(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, k: f32) -> f32 {
  var ggx1: f32 = min(1.0, schlickGGX(N, V, k));
  var ggx2: f32 = min(1.0, schlickGGX(N, L, k));
  return ggx1*ggx2;
}

// BRDF Combination
fn cookTorrance(D: f32, F: f32, G: f32, N: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> f32 {
  var num: f32 = D*F*G;
  var denom: f32 = 4*cdot(V, N)*cdot(L, N);

  return num / max(denom, 0.000001);
}

// Different lighting calculations for different light sources
fn calcDirectionalLight(N: vec3<f32>, V: vec3<f32>, ior: f32, roughness: f32, metallic: f32, direction: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {  
  var L: vec3<f32> = normalize(direction); // Light Vector
  var H: vec3<f32> = normalize(L + V); // Halfway Vector

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2;

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L); // Fresnel term is replaced with 1 because it is added later
  var incoming: vec3<f32> = color;
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5);

  var specular: vec3<f32> = brdf*incoming*angle;
  // Oren-Nayar gives a clay-like effect when fully rough which some people may not want, so it might be better to give a separate
  // control property for the diffuse vs specular roughness
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V); 
  // Stores the specular and diffuse separately to allow for finer post processing
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// TODO: find some way to reduce the number of arguments going in here
fn calcPointLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {
  var L: vec3<f32> = normalize(position - fragPos); // Light Vector
  var H: vec3<f32> = normalize(L + V); // Halfway Vector
  var dist = distance(position, fragPos);

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);
  var incoming: vec3<f32> = color * (1.0 / (dist*dist));
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" bewteen light sources

  var specular: vec3<f32> = brdf*incoming*angle;
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);

  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// For a reason unknown to me, spheres dont seem to behave propperly with head-on spot lights
fn calcSpotLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, ior: f32, roughness: f32, metallic: f32, position: vec3<f32>, direction: vec3<f32>, cones: vec2<f32>, color: vec3<f32>, base: vec3<f32>) -> PBRData {
  var L: vec3<f32> = normalize(position - fragPos);
  var H: vec3<f32> = normalize(L + V); // Halfway Vector
  var dist = distance(position, fragPos);

  var alpha = roughness*roughness;
  var k: f32 = alpha*alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);
  
  // Cones.x is the inner phi and cones.y is the outer phi
  var theta: f32 = mdot(normalize(direction), L);
  var epsilon: f32 = cones.x - cones.y;
  var intensity: f32 = (theta - cones.y) / epsilon;
  intensity = clamp(intensity, 0.0, 1.0);
  intensity /= dist*dist;

  var incoming: vec3<f32> = color * intensity;

  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" bewteen light sources

  var specular: vec3<f32> = brdf*incoming*angle;
  var diffuse: vec3<f32> = incoming*fujiiOrenNayar(base, roughness, N, L, V);

  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);
  
  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// Environment mapping stuff
// Takes in a vector and converts it to an equivalent coordinate in a rectilinear texture. Should be replaced with cubemaps at some point
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::TCoord::Dec

// optional surface normal declaration
//VTK::Normal::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  // Temporary ambient, diffuse, and opacity
  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;
  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;
  var opacity: f32 = mapperUBO.Opacity;

  // This should be declared somewhere else
  var _diffuseMap: vec4<f32> = vec4<f32>(1.0);
  var _roughnessMap: vec4<f32> = vec4<f32>(1.0);
  var _metallicMap: vec4<f32> = vec4<f32>(1.0);
  var _normalMap: vec4<f32> = vec4<f32>(0.0, 0.0, 1.0, 0.0); // normal map was setting off the normal vector detection in fragment
  var _ambientOcclusionMap: vec4<f32> = vec4<f32>(1.);
  var _emissionMap: vec4<f32> = vec4<f32>(0.);

  //VTK::Color::Impl

  //VTK::TCoord::Impl

  //VTK::Normal::Impl

  var computedColor: vec4<f32> = vec4<f32>(diffuseColor.rgb, 1.0);

  //VTK::Light::Impl

  //VTK::Select::Impl

  if (computedColor.a == 0.0) { discard; };

  //VTK::Position::Impl

  //VTK::RenderEncoder::Impl

  return output;
}
`;
  function isEdges(hash) {
    // edge pipelines have "edge" in them
    return hash.indexOf('edge') >= 0;
  }

  // ----------------------------------------------------------------------------
  // vtkWebGPUCellArrayMapper methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUCellArrayMapper(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUCellArrayMapper');
    publicAPI.buildPass = prepass => {
      if (prepass) {
        if (model.is2D) {
          model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor2D');
          model.forceZValue = true;
        } else {
          model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor');
          model.forceZValue = false;
        }
        model.coordinateSystem = model.WebGPUActor.getRenderable().getCoordinateSystem();
        model.useRendererMatrix = model.coordinateSystem !== CoordinateSystem.DISPLAY;
        model.WebGPURenderer = model.WebGPUActor.getFirstAncestorOfType('vtkWebGPURenderer');
        model.WebGPURenderWindow = model.WebGPURenderer.getParent();
        model.device = model.WebGPURenderWindow.getDevice();
      }
    };

    // Renders myself
    publicAPI.translucentPass = prepass => {
      if (prepass) {
        publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
        model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
      }
    };
    publicAPI.opaquePass = prepass => {
      if (prepass) {
        publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
        model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
      }
    };
    publicAPI.updateUBO = () => {
      // make sure the data is up to date
      const actor = model.WebGPUActor.getRenderable();
      const ppty = actor.getProperty();
      const utime = model.UBO.getSendTime();
      if (publicAPI.getMTime() > utime || ppty.getMTime() > utime || model.renderable.getMTime() > utime) {
        // Matricies
        const keyMats = model.WebGPUActor.getKeyMatrices(model.WebGPURenderer);
        model.UBO.setArray('BCWCMatrix', keyMats.bcwc);
        model.UBO.setArray('BCSCMatrix', keyMats.bcsc);
        model.UBO.setArray('MCWCNormals', keyMats.normalMatrix);
        if (model.is2D) {
          model.UBO.setValue('ZValue', model.WebGPUActor.getRenderable().getProperty().getDisplayLocation() === DisplayLocation.FOREGROUND ? 1.0 : 0.0);
          const aColor = ppty.getColorByReference();
          model.UBO.setValue('AmbientIntensity', 1.0);
          model.UBO.setArray('DiffuseColor', [aColor[0], aColor[1], aColor[2], 1.0]);
          model.UBO.setValue('DiffuseIntensity', 0.0);
          model.UBO.setValue('SpecularIntensity', 0.0);
        } else {
          // Base Colors
          let aColor = ppty.getAmbientColorByReference();
          model.UBO.setValue('AmbientIntensity', ppty.getAmbient());
          model.UBO.setArray('AmbientColor', [aColor[0], aColor[1], aColor[2], 1.0]);
          model.UBO.setValue('DiffuseIntensity', ppty.getDiffuse());
          aColor = ppty.getDiffuseColorByReference();
          model.UBO.setArray('DiffuseColor', [aColor[0], aColor[1], aColor[2], 1.0]);
          // Roughness
          model.UBO.setValue('Roughness', ppty.getRoughness());
          model.UBO.setValue('BaseIOR', ppty.getBaseIOR());
          // Metallic
          model.UBO.setValue('Metallic', ppty.getMetallic());
          // Normal
          model.UBO.setValue('NormalStrength', ppty.getNormalStrength());
          // Emission
          model.UBO.setValue('Emission', ppty.getEmission());
          // Specular
          model.UBO.setValue('SpecularIntensity', ppty.getSpecular());
          aColor = ppty.getSpecularColorByReference();
          model.UBO.setArray('SpecularColor', [aColor[0], aColor[1], aColor[2], 1.0]);
        }
        // Edge and line rendering
        const aColor = ppty.getEdgeColorByReference?.();
        if (aColor) {
          model.UBO.setArray('EdgeColor', [aColor[0], aColor[1], aColor[2], 1.0]);
        }
        model.UBO.setValue('LineWidth', ppty.getLineWidth());
        model.UBO.setValue('Opacity', ppty.getOpacity());
        model.UBO.setValue('PropID', model.WebGPUActor.getPropID());
        const device = model.WebGPURenderWindow.getDevice();
        model.UBO.sendIfNeeded(device);
      }
    };
    publicAPI.haveWideLines = () => {
      const actor = model.WebGPUActor.getRenderable();
      const representation = actor.getProperty().getRepresentation();
      if (actor.getProperty().getLineWidth() <= 1.0) {
        return false;
      }
      if (model.primitiveType === PrimitiveTypes$3.Verts) {
        return false;
      }
      if (model.primitiveType === PrimitiveTypes$3.Triangles || model.primitiveType === PrimitiveTypes$3.TriangleStrips) {
        return representation === Representation$2.WIREFRAME;
      }
      return true;
    };
    publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
      const vDesc = pipeline.getShaderDescription('vertex');
      vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');
      if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');
      let code = vDesc.getCode();
      if (model.useRendererMatrix) {
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;', '    output.vertexVC = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);', '//VTK::Position::Impl']).result;
        if (model.forceZValue) {
          code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Position::Impl', ['pCoord = vec4<f32>(pCoord.xyz/pCoord.w, 1.0);', 'pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;
        }
      } else {
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Position::Impl', ['    var pCoord: vec4<f32> = mapperUBO.BCSCMatrix*vertexBC;', '    pCoord.x = 2.0* pCoord.x / rendererUBO.viewportSize.x - 1.0;', '    pCoord.y = 2.0* pCoord.y / rendererUBO.viewportSize.y - 1.0;', '    pCoord.z = 0.5 - 0.5 * pCoord.z;', '//VTK::Position::Impl']).result;
        if (model.forceZValue) {
          code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Position::Impl', ['    pCoord.z = mapperUBO.ZValue;', '//VTK::Position::Impl']).result;
        }
      }
      if (publicAPI.haveWideLines()) {
        vDesc.addBuiltinInput('u32', '@builtin(instance_index) instanceIndex');
        // widen the edge
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Position::Impl', ['    var tmpPos: vec4<f32> = pCoord;', '    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);', '    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;', '    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;', '    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;', '    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;', '    tmpPos2.z = min(1.0, tmpPos2.z + 0.00001);',
        // could become a setting
        '    pCoord = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '//VTK::Position::Impl']).result;
      }
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Position::Impl', ['    output.Position = pCoord;']).result;
      vDesc.setCode(code);
    };
    model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);
    publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {
      const normalBuffer = vertexInput.getBuffer('normalMC');
      const actor = model.WebGPUActor.getRenderable();
      if (normalBuffer) {
        const vDesc = pipeline.getShaderDescription('vertex');
        if (!vDesc.hasOutput('normalVC')) {
          vDesc.addOutput('vec3<f32>', 'normalVC', normalBuffer.getArrayInformation()[0].interpolation);
        }
        if (!vDesc.hasOutput('tangentVC')) {
          vDesc.addOutput('vec3<f32>', 'tangentVC', normalBuffer.getArrayInformation()[0].interpolation);
        }
        if (!vDesc.hasOutput('bitangentVC')) {
          vDesc.addOutput('vec3<f32>', 'bitangentVC', normalBuffer.getArrayInformation()[0].interpolation);
        }
        let code = vDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Normal::Impl', ['  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);',
        // This is just an approximation, but it happens to work extremely well
        // It only works well for normals that are head on and not super angled though
        // Definitely needs to be replaced
        '  var c1: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 0, 1));', '  var c2: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 1, 0));', '  var tangent: vec3<f32> = mix(c1, c2, distance(c1, c2));', '  output.tangentVC = normalize(tangent);', '  output.bitangentVC = normalize(cross(output.normalVC, tangent));']).result;
        vDesc.setCode(code);
        const fDesc = pipeline.getShaderDescription('fragment');
        code = fDesc.getCode();
        if (actor.getProperty().getNormalTexture()) {
          code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  var tangent: vec3<f32> = input.tangentVC;', '  var bitangent: vec3<f32> = input.bitangentVC;', '  var TCVCMatrix: mat3x3<f32> = mat3x3<f32>(', '    tangent.x, bitangent.x, normal.x,', '    tangent.y, bitangent.y, normal.y,', '    tangent.z, bitangent.z, normal.z,', '  );', '  var mappedNormal: vec3<f32> = TCVCMatrix * (_normalMap.xyz * 2 - 1);', '  normal = mix(normal, mappedNormal, mapperUBO.NormalStrength);', '  normal = normalize(normal);']).result;
        } else {
          code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Normal::Impl', ['  var normal: vec3<f32> = input.normalVC;', '  if (!input.frontFacing) { normal = -normal; }', '  normal = normalize(normal);']).result;
        }
        fDesc.setCode(code);
      }
    };
    model.shaderReplacements.set('replaceShaderNormal', publicAPI.replaceShaderNormal);

    // we only apply lighting when there is a "var normal" declaration in the
    // fragment shader code. That is the lighting trigger.
    publicAPI.replaceShaderLight = (hash, pipeline, vertexInput) => {
      if (hash.includes('sel')) return;
      const vDesc = pipeline.getShaderDescription('vertex');
      if (!vDesc.hasOutput('vertexVC')) vDesc.addOutput('vec4<f32>', 'vertexVC');
      const renderer = model.WebGPURenderer.getRenderable();
      const fDesc = pipeline.getShaderDescription('fragment');
      let code = fDesc.getCode();

      // Code that runs if the fragment shader includes normals
      if (code.includes('var normal:') && model.useRendererMatrix && !isEdges(hash) && !model.is2D && !hash.includes('sel')) {
        const lightingCode = [
        // Constants
        '  var pi: f32 = 3.14159265359;',
        // Vectors needed for light calculations
        '  var fragPos: vec3<f32> = vec3<f32>(input.vertexVC.xyz);', '  var V: vec3<f32> = mix(normalize(-fragPos), vec3<f32>(0, 0, 1), f32(rendererUBO.cameraParallel)); // View Vector',
        // Values needed for light calculations
        '  var baseColor: vec3<f32> = _diffuseMap.rgb * diffuseColor.rgb;', '  var roughness: f32 = max(0.000001, mapperUBO.Roughness * _roughnessMap.r);',
        // Need to have a different way of sampling greyscale values aside from .r
        '  var metallic: f32 = mapperUBO.Metallic * _metallicMap.r;', '  var alpha: f32 = roughness*roughness;', '  var ior: f32 = mapperUBO.BaseIOR;', '  var k: f32 = alpha*alpha / 2;',
        // Split diffuse and specular components
        '  var diffuse: vec3<f32> = vec3<f32>(0.);', '  var specular: vec3<f32> = vec3<f32>(0.);', '  var emission: vec3<f32> = _emissionMap.rgb * mapperUBO.Emission;',
        // Summing diffuse and specular components of directional lights
        '  {', '    var i: i32 = 0;', '    loop {', '      if !(i < rendererUBO.LightCount) { break; }', '      switch (i32(rendererLightSSBO.values[i].LightData.x)) {', '         // Point Light', '         case 0 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var calculated: PBRData = calcPointLight(normal, V, fragPos, ior, roughness, metallic, pos, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '          }', '         // Directional light', '         case 1 {', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var calculated: PBRData = calcDirectionalLight(normal, V, ior, roughness, metallic, dir, color, baseColor); // diffuseColor.rgb needs to be fixed with a more dynamic diffuse color', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         // Spot Light', '         case 2 {', '           var color: vec3<f32> = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;', '           var pos: vec3<f32> = (rendererLightSSBO.values[i].LightPos).xyz;', '           var dir: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz;', '           dir = normalize(dir);', '           var cones: vec2<f32> = vec2<f32>(rendererLightSSBO.values[i].LightData.y, rendererLightSSBO.values[i].LightData.z);', '           var calculated: PBRData = calcSpotLight(normal, V, fragPos, ior, roughness, metallic, pos, dir, cones, color, baseColor);', '           diffuse += max(vec3<f32>(0), calculated.diffuse);', '           specular += max(vec3<f32>(0), calculated.specular);', '         }', '         default { continue; }', '       }', '      continuing { i++; }', '    }', '  }',
        // Final variables for combining specular and diffuse
        '  var fresnel: f32 = schlickFresnelIOR(V, normal, ior, k); // Fresnel', '  fresnel = min(1.0, fresnel);', '  // This could be controlled with its own variable (that isnt base color) for better artistic control', '  var fresnelMetallic: vec3<f32> = schlickFresnelRGB(V, normal, baseColor); // Fresnel for metal, takes color into account', '  var kS: vec3<f32> = mix(vec3<f32>(fresnel), fresnelMetallic, metallic);', '  kS = min(vec3<f32>(1.0), kS);', '  var kD: vec3<f32> = (1.0 - kS) * (1.0 - metallic);', '  var PBR: vec3<f32> = mapperUBO.DiffuseIntensity*kD*diffuse + kS*specular;', '  PBR += emission;', '  computedColor = vec4<f32>(PBR, mapperUBO.Opacity);'];
        if (renderer.getEnvironmentTexture()?.getImageLoaded()) {
          lightingCode.push('  // To get diffuse IBL, the texture is sampled with normals in worldspace', '  var diffuseIBLCoords: vec3<f32> = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(normal, 1.)).xyz;', '  var diffuseCoords: vec2<f32> = vecToRectCoord(diffuseIBLCoords);', '  // To get specular IBL, the texture is sampled as the worldspace reflection between the normal and view vectors', '  // Reflections are first calculated in viewspace, then converted to worldspace to sample the environment', '  var VreflN: vec3<f32> = normalize(reflect(-V, normal));', '  var reflectionIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(VreflN, 1.)).xyz;', '  var specularCoords: vec2<f32> = vecToRectCoord(reflectionIBLCoords);', '  var diffuseIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, diffuseCoords, rendererUBO.MaxEnvironmentMipLevel);',
          // Level multiplier should be set by UBO
          '  var level = roughness * rendererUBO.MaxEnvironmentMipLevel;', '  var specularIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, specularCoords, level);',
          // Manual mip smoothing since not all formats support smooth level sampling
          '  var specularIBLContribution: vec3<f32> = specularIBL.rgb*rendererUBO.BackgroundSpecularStrength;', '  computedColor += vec4<f32>(specularIBLContribution*kS, 0);', '  var diffuseIBLContribution: vec3<f32> = diffuseIBL.rgb*rendererUBO.BackgroundDiffuseStrength;', '  diffuseIBLContribution *= baseColor * _ambientOcclusionMap.rgb;',
          // Multipy by baseColor may be changed
          '  computedColor += vec4<f32>(diffuseIBLContribution*kD, 0);');
        }
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Light::Impl', lightingCode).result;
        fDesc.setCode(code);
        // If theres no normals, just set the specular color to be flat
      } else {
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Light::Impl', ['  var diffuse: vec3<f32> = diffuseColor.rgb;', '  var specular: vec3<f32> = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;', '  computedColor = vec4<f32>(diffuse * _diffuseMap.rgb, mapperUBO.Opacity);']).result;
        fDesc.setCode(code);
      }
    };
    model.shaderReplacements.set('replaceShaderLight', publicAPI.replaceShaderLight);
    publicAPI.replaceShaderColor = (hash, pipeline, vertexInput) => {
      // By default, set the colors to be flat
      if (isEdges(hash)) {
        const fDesc = pipeline.getShaderDescription('fragment');
        let code = fDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Color::Impl', ['ambientColor = mapperUBO.EdgeColor;', 'diffuseColor = mapperUBO.EdgeColor;']).result;
        fDesc.setCode(code);
        return;
      }

      // If there's no vertex color buffer return the shader as is
      const colorBuffer = vertexInput.getBuffer('colorVI');
      if (!colorBuffer) return;

      // Modifies the vertex shader to include the vertex colors and interpolation in the outputs
      const vDesc = pipeline.getShaderDescription('vertex');
      vDesc.addOutput('vec4<f32>', 'color', colorBuffer.getArrayInformation()[0].interpolation);
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Color::Impl', ['  output.color = colorVI;']).result;
      vDesc.setCode(code);

      // Sets the fragment shader to accept the color inputs from the vertex shader
      const fDesc = pipeline.getShaderDescription('fragment');
      code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Color::Impl', ['ambientColor = input.color;', 'diffuseColor = input.color;', 'opacity = mapperUBO.Opacity * input.color.a;']).result;
      fDesc.setCode(code);
    };
    model.shaderReplacements.set('replaceShaderColor', publicAPI.replaceShaderColor);
    publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
      if (!vertexInput.hasAttribute('tcoord')) return;
      const vDesc = pipeline.getShaderDescription('vertex');
      const tcoords = vertexInput.getBuffer('tcoord');
      const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
      let code = vDesc.getCode();
      vDesc.addOutput(`vec${numComp}<f32>`, 'tcoordVS');
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::TCoord::Impl', ['  output.tcoordVS = tcoord;']).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription('fragment');
      code = fDesc.getCode();
      const actor = model.WebGPUActor.getRenderable();
      const checkDims = texture => {
        if (!texture) return false;
        const dims = texture.getDimensionality();
        return dims === numComp;
      };
      const usedTextures = [];
      if (actor.getProperty().getDiffuseTexture?.()?.getImageLoaded() || actor.getTextures()[0] || model.colorTexture) {
        if (
        // Chained or statements here are questionable
        checkDims(actor.getProperty().getDiffuseTexture?.()) || checkDims(actor.getTextures()[0]) || checkDims(model.colorTexture)) {
          usedTextures.push('_diffuseMap = textureSample(DiffuseTexture, DiffuseTextureSampler, input.tcoordVS);');
        }
      }
      if (actor.getProperty().getRoughnessTexture?.()?.getImageLoaded()) {
        if (checkDims(actor.getProperty().getRoughnessTexture())) {
          usedTextures.push('_roughnessMap = textureSample(RoughnessTexture, RoughnessTextureSampler, input.tcoordVS);');
        }
      }
      if (actor.getProperty().getMetallicTexture?.()?.getImageLoaded()) {
        if (checkDims(actor.getProperty().getMetallicTexture())) {
          usedTextures.push('_metallicMap = textureSample(MetallicTexture, MetallicTextureSampler, input.tcoordVS);');
        }
      }
      if (actor.getProperty().getNormalTexture?.()?.getImageLoaded()) {
        if (checkDims(actor.getProperty().getNormalTexture())) {
          usedTextures.push('_normalMap = textureSample(NormalTexture, NormalTextureSampler, input.tcoordVS);');
        }
      }
      if (actor.getProperty().getAmbientOcclusionTexture?.()?.getImageLoaded()) {
        if (checkDims(actor.getProperty().getAmbientOcclusionTexture())) {
          usedTextures.push('_ambientOcclusionMap = textureSample(AmbientOcclusionTexture, AmbientOcclusionTextureSampler, input.tcoordVS);');
        }
      }
      if (actor.getProperty().getEmissionTexture?.()?.getImageLoaded()) {
        if (checkDims(actor.getProperty().getEmissionTexture())) {
          usedTextures.push('_emissionMap = textureSample(EmissionTexture, EmissionTextureSampler, input.tcoordVS);');
        }
      }
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::TCoord::Impl', usedTextures).result;
      fDesc.setCode(code);
    };
    model.shaderReplacements.set('replaceShaderTCoord', publicAPI.replaceShaderTCoord);
    publicAPI.replaceShaderSelect = (hash, pipeline, vertexInput) => {
      if (hash.includes('sel')) {
        const fDesc = pipeline.getShaderDescription('fragment');
        let code = fDesc.getCode();
        // by default there are no composites, so just 0
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Select::Impl', ['  var compositeID: u32 = 0u;']).result;
        fDesc.setCode(code);
      }
    };
    model.shaderReplacements.set('replaceShaderSelect', publicAPI.replaceShaderSelect);
    publicAPI.getUsage = (rep, i) => {
      if (rep === Representation$2.POINTS || i === PrimitiveTypes$3.Points) {
        return BufferUsage$2.Verts;
      }
      if (i === PrimitiveTypes$3.Lines) {
        return BufferUsage$2.Lines;
      }
      if (rep === Representation$2.WIREFRAME) {
        if (i === PrimitiveTypes$3.Triangles) {
          return BufferUsage$2.LinesFromTriangles;
        }
        return BufferUsage$2.LinesFromStrips;
      }
      if (i === PrimitiveTypes$3.Triangles) {
        return BufferUsage$2.Triangles;
      }
      if (i === PrimitiveTypes$3.TriangleStrips) {
        return BufferUsage$2.Strips;
      }
      if (i === PrimitiveTypes$3.TriangleEdges) {
        return BufferUsage$2.LinesFromTriangles;
      }

      // only strip edges left which are lines
      return BufferUsage$2.LinesFromStrips;
    };
    publicAPI.getHashFromUsage = usage => `pt${usage}`;
    publicAPI.getTopologyFromUsage = usage => {
      switch (usage) {
        case BufferUsage$2.Triangles:
          return 'triangle-list';
        case BufferUsage$2.Verts:
          return 'point-list';
        case BufferUsage$2.Lines:
        default:
          return 'line-list';
      }
    };

    // TODO: calculate tangents
    publicAPI.buildVertexInput = () => {
      const pd = model.currentInput;
      const cells = model.cellArray;
      const primType = model.primitiveType;
      const actor = model.WebGPUActor.getRenderable();
      let representation = actor.getProperty().getRepresentation();
      const device = model.WebGPURenderWindow.getDevice();
      let edges = false;
      if (primType === PrimitiveTypes$3.TriangleEdges) {
        edges = true;
        representation = Representation$2.WIREFRAME;
      }
      const vertexInput = model.vertexInput;
      const points = pd.getPoints();
      let indexBuffer;

      // get the flat mapping indexBuffer for the cells
      if (cells) {
        const buffRequest = {
          hash: `R${representation}P${primType}${cells.getMTime()}`,
          usage: BufferUsage$2.Index,
          cells,
          numberOfPoints: points.getNumberOfPoints(),
          primitiveType: primType,
          representation
        };
        indexBuffer = device.getBufferManager().getBuffer(buffRequest);
        vertexInput.setIndexBuffer(indexBuffer);
      } else {
        vertexInput.setIndexBuffer(null);
      }

      // hash = all things that can change the values on the buffer
      // since mtimes are unique we can use
      // - indexBuffer mtime - because cells drive how we pack
      // - relevant dataArray mtime - the source data
      // - shift - not currently captured
      // - scale - not currently captured
      // - format
      // - usage
      // - packExtra - covered by format

      // points
      if (points) {
        const shift = model.WebGPUActor.getBufferShift(model.WebGPURenderer);
        const buffRequest = {
          hash: `${points.getMTime()}I${indexBuffer.getMTime()}${shift.join()}float32x4`,
          usage: BufferUsage$2.PointArray,
          format: 'float32x4',
          dataArray: points,
          indexBuffer,
          shift,
          packExtra: true
        };
        const buff = device.getBufferManager().getBuffer(buffRequest);
        vertexInput.addBuffer(buff, ['vertexBC']);
      } else {
        vertexInput.removeBufferIfPresent('vertexBC');
      }

      // normals, only used for surface rendering
      const usage = publicAPI.getUsage(representation, primType);
      model._usesCellNormals = false;
      if (!model.is2D && (
      // no lighting on Property2D
      usage === BufferUsage$2.Triangles || usage === BufferUsage$2.Strips)) {
        const normals = pd.getPointData().getNormals();
        // https://vtk.org/doc/nightly/html/classvtkPolyDataTangents.html
        // Need to find some way of using precomputed tangents (or computing new ones)
        const buffRequest = {
          format: 'snorm8x4',
          indexBuffer,
          packExtra: true,
          shift: 0,
          scale: 127
        };
        if (normals) {
          buffRequest.hash = `${normals.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
          buffRequest.dataArray = normals;
          buffRequest.usage = BufferUsage$2.PointArray;
          const buff = device.getBufferManager().getBuffer(buffRequest);
          vertexInput.addBuffer(buff, ['normalMC']);
        } else if (primType === PrimitiveTypes$3.Triangles) {
          model._usesCellNormals = true;
          buffRequest.hash = `PFN${points.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
          buffRequest.dataArray = points;
          buffRequest.cells = cells;
          buffRequest.usage = BufferUsage$2.NormalsFromPoints;
          const buff = device.getBufferManager().getBuffer(buffRequest);
          vertexInput.addBuffer(buff, ['normalMC']);
        } else {
          vertexInput.removeBufferIfPresent('normalMC');
        }
      } else {
        vertexInput.removeBufferIfPresent('normalMC');
      }

      // deal with colors but only if modified
      let haveColors = false;
      if (model.renderable.getScalarVisibility()) {
        const c = model.renderable.getColorMapColors();
        if (c && !edges) {
          const scalarMode = model.renderable.getScalarMode();
          let haveCellScalars = false;
          // We must figure out how the scalars should be mapped to the polydata.
          if ((scalarMode === ScalarMode.USE_CELL_DATA || scalarMode === ScalarMode.USE_CELL_FIELD_DATA || scalarMode === ScalarMode.USE_FIELD_DATA || !pd.getPointData().getScalars()) && scalarMode !== ScalarMode.USE_POINT_FIELD_DATA && c) {
            haveCellScalars = true;
          }
          const buffRequest = {
            usage: BufferUsage$2.PointArray,
            format: 'unorm8x4',
            hash: `${haveCellScalars}${c.getMTime()}I${indexBuffer.getMTime()}unorm8x4`,
            dataArray: c,
            indexBuffer,
            cellData: haveCellScalars,
            cellOffset: 0
          };
          const buff = device.getBufferManager().getBuffer(buffRequest);
          vertexInput.addBuffer(buff, ['colorVI']);
          haveColors = true;
        }
      }
      if (!haveColors) {
        vertexInput.removeBufferIfPresent('colorVI');
      }
      let tcoords = null;
      if (model.renderable.getInterpolateScalarsBeforeMapping?.() && model.renderable.getColorCoordinates()) {
        tcoords = model.renderable.getColorCoordinates();
      } else {
        tcoords = pd.getPointData().getTCoords();
      }
      if (tcoords && !edges) {
        const buff = device.getBufferManager().getBufferForPointArray(tcoords, vertexInput.getIndexBuffer());
        vertexInput.addBuffer(buff, ['tcoord']);
      } else {
        vertexInput.removeBufferIfPresent('tcoord');
      }
    };
    publicAPI.updateTextures = () => {
      // we keep track of new and used textures so
      // that we can clean up any unused textures so we don't hold onto them
      const usedTextures = [];
      const newTextures = [];

      // do we have a scalar color texture
      const idata = model.renderable.getColorTextureMap?.();
      if (idata) {
        if (!model.colorTexture) {
          model.colorTexture = vtkTexture$1.newInstance({
            label: 'polyDataColor'
          });
        }
        model.colorTexture.setInputData(idata);
        newTextures.push(['Diffuse', model.colorTexture]);
      }

      // actor textures?
      const actor = model.WebGPUActor.getRenderable();
      const renderer = model.WebGPURenderer.getRenderable();

      // Reusing the old code for new and old textures, just loading in from properties instead of actor.getTextures()
      const textures = [];

      // Feels like there should be a better way than individually adding all
      if (actor.getProperty().getDiffuseTexture?.()) {
        const pair = ['Diffuse', actor.getProperty().getDiffuseTexture()];
        textures.push(pair);
      }
      if (actor.getTextures()[0]) {
        const pair = ['Diffuse', actor.getTextures()[0]];
        textures.push(pair);
      }
      if (model.colorTexture) {
        const pair = ['Diffuse', model.colorTexture];
        textures.push(pair);
      }
      if (actor.getProperty().getRoughnessTexture?.()) {
        const pair = ['Roughness', actor.getProperty().getRoughnessTexture()];
        textures.push(pair);
      }
      if (actor.getProperty().getMetallicTexture?.()) {
        const pair = ['Metallic', actor.getProperty().getMetallicTexture()];
        textures.push(pair);
      }
      if (actor.getProperty().getNormalTexture?.()) {
        const pair = ['Normal', actor.getProperty().getNormalTexture()];
        textures.push(pair);
      }
      if (actor.getProperty().getAmbientOcclusionTexture?.()) {
        const pair = ['AmbientOcclusion', actor.getProperty().getAmbientOcclusionTexture()];
        textures.push(pair);
      }
      if (actor.getProperty().getEmissionTexture?.()) {
        const pair = ['Emission', actor.getProperty().getEmissionTexture()];
        textures.push(pair);
      }
      if (renderer.getEnvironmentTexture?.()) {
        const pair = ['Environment', renderer.getEnvironmentTexture()];
        textures.push(pair);
      }
      for (let i = 0; i < textures.length; i++) {
        if (textures[i][1].getInputData() || textures[i][1].getJsImageData() || textures[i][1].getCanvas()) {
          newTextures.push(textures[i]);
        }
        if (textures[i][1].getImage() && textures[i][1].getImageLoaded()) {
          newTextures.push(textures[i]);
        }
      }
      for (let i = 0; i < newTextures.length; i++) {
        const srcTexture = newTextures[i][1];
        const textureName = newTextures[i][0];
        const newTex = model.device.getTextureManager().getTextureForVTKTexture(srcTexture); // Generates hash
        if (newTex.getReady()) {
          // is this a new texture
          let found = false;
          for (let t = 0; t < model.textures.length; t++) {
            if (model.textures[t] === newTex) {
              found = true;
              usedTextures[t] = true;
            }
          }
          if (!found) {
            usedTextures[model.textures.length] = true;
            const tview = newTex.createView(`${textureName}Texture`);
            model.textures.push(newTex);
            model.textureViews.push(tview);
            const interpolate = srcTexture.getInterpolate() ? 'linear' : 'nearest';
            let addressMode = null;
            if (!addressMode && srcTexture.getEdgeClamp() && srcTexture.getRepeat()) addressMode = 'mirror-repeat';
            if (!addressMode && srcTexture.getEdgeClamp()) addressMode = 'clamp-to-edge';
            if (!addressMode && srcTexture.getRepeat()) addressMode = 'repeat';
            if (textureName !== 'Environment') {
              tview.addSampler(model.device, {
                addressModeU: addressMode,
                addressModeV: addressMode,
                addressModeW: addressMode,
                minFilter: interpolate,
                magFilter: interpolate
              });
            } else {
              tview.addSampler(model.device, {
                addressModeU: 'repeat',
                addressModeV: 'clamp-to-edge',
                addressModeW: 'repeat',
                minFilter: interpolate,
                magFilter: interpolate,
                mipmapFilter: 'linear'
              });
            }
          }
        }
      }

      // remove unused textures
      for (let i = model.textures.length - 1; i >= 0; i--) {
        if (!usedTextures[i]) {
          model.textures.splice(i, 1);
          model.textureViews.splice(i, 1);
        }
      }
    };

    // compute a unique hash for a pipeline, this needs to be unique enough to
    // capture any pipeline code changes (which includes shader changes)
    // or vertex input changes/ bind groups/ etc
    publicAPI.computePipelineHash = () => {
      let pipelineHash = `pd${model.useRendererMatrix ? 'r' : ''}${model.forceZValue ? 'z' : ''}`;
      if (model.primitiveType === PrimitiveTypes$3.TriangleEdges || model.primitiveType === PrimitiveTypes$3.TriangleStripEdges) {
        pipelineHash += 'edge';
      } else {
        if (model.vertexInput.hasAttribute(`normalMC`)) {
          pipelineHash += `n`;
        }
        if (model.vertexInput.hasAttribute(`colorVI`)) {
          pipelineHash += `c`;
        }
        if (model.vertexInput.hasAttribute(`tcoord`)) {
          const tcoords = model.vertexInput.getBuffer('tcoord');
          const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
          pipelineHash += `t${numComp}`;
        }
        if (model.textures.length) {
          pipelineHash += `tx${model.textures.length}`;
        }
      }
      if (model._usesCellNormals) {
        pipelineHash += `cn`;
      }
      if (model.SSBO) {
        pipelineHash += `ssbo`;
      }
      const uhash = publicAPI.getHashFromUsage(model.usage);
      pipelineHash += uhash;
      pipelineHash += model.renderEncoder.getPipelineHash();
      model.pipelineHash = pipelineHash;
    };
    publicAPI.updateBuffers = () => {
      // handle textures if not edges
      if (model.primitiveType !== PrimitiveTypes$3.TriangleEdges && model.primitiveType !== PrimitiveTypes$3.TriangleStripEdges) {
        publicAPI.updateTextures();
      }
      const actor = model.WebGPUActor.getRenderable();
      const rep = actor.getProperty().getRepresentation();

      // handle per primitive type
      model.usage = publicAPI.getUsage(rep, model.primitiveType);
      publicAPI.buildVertexInput();
      const vbo = model.vertexInput.getBuffer('vertexBC');
      publicAPI.setNumberOfVertices(vbo.getSizeInBytes() / vbo.getStrideInBytes());
      publicAPI.setTopology(publicAPI.getTopologyFromUsage(model.usage));
      publicAPI.updateUBO();
      if (publicAPI.haveWideLines()) {
        const ppty = actor.getProperty();
        publicAPI.setNumberOfInstances(Math.ceil(ppty.getLineWidth() * 2.0));
      } else {
        publicAPI.setNumberOfInstances(1);
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$D = {
    is2D: false,
    cellArray: null,
    currentInput: null,
    cellOffset: 0,
    primitiveType: 0,
    colorTexture: null,
    renderEncoder: null,
    textures: null
  };

  // ----------------------------------------------------------------------------

  function extend$E(publicAPI, model) {
    let initiaLalues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$D, initiaLalues);

    // Inheritance
    vtkWebGPUSimpleMapper$1.extend(publicAPI, model, initiaLalues);
    model.fragmentShaderTemplate = vtkWebGPUPolyDataFS;
    model.vertexShaderTemplate = vtkWebGPUPolyDataVS;
    model._tmpMat3 = identity$4(new Float64Array(9));
    model._tmpMat4 = identity$3(new Float64Array(16));

    // UBO
    model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
      label: 'mapperUBO'
    });
    model.UBO.addEntry('BCWCMatrix', 'mat4x4<f32>');
    model.UBO.addEntry('BCSCMatrix', 'mat4x4<f32>');
    model.UBO.addEntry('MCWCNormals', 'mat4x4<f32>');
    model.UBO.addEntry('AmbientColor', 'vec4<f32>');
    model.UBO.addEntry('DiffuseColor', 'vec4<f32>');
    model.UBO.addEntry('EdgeColor', 'vec4<f32>');
    model.UBO.addEntry('SpecularColor', 'vec4<f32>');
    model.UBO.addEntry('AmbientIntensity', 'f32');
    model.UBO.addEntry('DiffuseIntensity', 'f32');
    model.UBO.addEntry('Roughness', 'f32');
    model.UBO.addEntry('Metallic', 'f32');
    model.UBO.addEntry('Ambient', 'f32');
    model.UBO.addEntry('Normal', 'f32');
    model.UBO.addEntry('Emission', 'f32');
    model.UBO.addEntry('NormalStrength', 'f32');
    model.UBO.addEntry('BaseIOR', 'f32');
    model.UBO.addEntry('SpecularIntensity', 'f32');
    model.UBO.addEntry('LineWidth', 'f32');
    model.UBO.addEntry('Opacity', 'f32');
    model.UBO.addEntry('ZValue', 'f32');
    model.UBO.addEntry('PropID', 'u32');
    model.UBO.addEntry('ClipNear', 'f32');
    model.UBO.addEntry('ClipFar', 'f32');
    model.UBO.addEntry('Time', 'u32');

    // Build VTK API
    setGet(publicAPI, model, ['cellArray', 'currentInput', 'cellOffset', 'is2D', 'primitiveType', 'renderEncoder']);
    model.textures = [];

    // Object methods
    vtkWebGPUCellArrayMapper(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$E = newInstance$1I(extend$E, 'vtkWebGPUCellArrayMapper');

  // ----------------------------------------------------------------------------

  var vtkWebGPUCellArrayMapper$1 = {
    newInstance: newInstance$E,
    extend: extend$E
  };

  const {
    PrimitiveTypes: PrimitiveTypes$2
  } = vtkWebGPUBufferManager$1;

  // ----------------------------------------------------------------------------
  // vtkWebGPUPolyDataMapper methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUPolyDataMapper(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUPolyDataMapper');
    publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
    publicAPI.buildPass = prepass => {
      if (prepass) {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor');
        if (!model.renderable.getStatic()) {
          model.renderable.update();
        }
        const poly = model.renderable.getInputData();
        model.renderable.mapScalars(poly, 1.0);
        publicAPI.updateCellArrayMappers(poly);
      }
    };
    publicAPI.updateCellArrayMappers = poly => {
      const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];

      // we instantiate a cell array mapper for each cellArray that has cells
      // and they handle the rendering of that cell array
      const cellMappers = [];
      let cellOffset = 0;
      for (let i = PrimitiveTypes$2.Points; i <= PrimitiveTypes$2.Triangles; i++) {
        if (prims[i].getNumberOfValues() > 0) {
          if (!model.primitives[i]) {
            model.primitives[i] = publicAPI.createCellArrayMapper();
          }
          const cellMapper = model.primitives[i];
          cellMapper.setCellArray(prims[i]);
          cellMapper.setCurrentInput(poly);
          cellMapper.setCellOffset(cellOffset);
          cellMapper.setPrimitiveType(i);
          cellMapper.setRenderable(model.renderable);
          cellOffset += prims[i].getNumberOfCells();
          cellMappers.push(cellMapper);
        } else {
          model.primitives[i] = null;
        }
      }
      if (model.WebGPUActor.getRenderable().getProperty().getEdgeVisibility()) {
        for (let i = PrimitiveTypes$2.TriangleEdges; i <= PrimitiveTypes$2.TriangleStripEdges; i++) {
          if (prims[i - 2].getNumberOfValues() > 0) {
            if (!model.primitives[i]) {
              model.primitives[i] = publicAPI.createCellArrayMapper();
            }
            const cellMapper = model.primitives[i];
            cellMapper.setCellArray(prims[i - 2]);
            cellMapper.setCurrentInput(poly);
            cellMapper.setCellOffset(model.primitives[i - 2].getCellOffset());
            cellMapper.setPrimitiveType(i);
            cellMapper.setRenderable(model.renderable);
            cellMappers.push(cellMapper);
          } else {
            model.primitives[i] = null;
          }
        }
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingChildren(cellMappers);
      publicAPI.removeUnusedNodes();
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$C = {
    primitives: null
  };

  // ----------------------------------------------------------------------------

  function extend$D(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$C, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.primitives = [];

    // Object methods
    vtkWebGPUPolyDataMapper(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$D = newInstance$1I(extend$D, 'vtkWebGPUPolyDataMapper');

  // Register ourself to WebGPU backend if imported
  registerOverride('vtkMapper', newInstance$D);

  const {
    PrimitiveTypes: PrimitiveTypes$1
  } = vtkWebGPUBufferManager$1;

  // ----------------------------------------------------------------------------
  // vtkWebGPUPolyDataMapper methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUPolyDataMapper2D(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUPolyDataMapper2D');
    publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
    publicAPI.buildPass = prepass => {
      if (prepass) {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType('vtkWebGPUActor2D');
        if (!model.renderable.getStatic()) {
          model.renderable.update();
        }
        const poly = model.renderable.getInputData();
        model.renderable.mapScalars(poly, 1.0);
        publicAPI.updateCellArrayMappers(poly);
      }
    };
    publicAPI.updateCellArrayMappers = poly => {
      const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];

      // we instantiate a cell array mapper for each cellArray that has cells
      // and they handle the rendering of that cell array
      const cellMappers = [];
      let cellOffset = 0;
      for (let i = PrimitiveTypes$1.Points; i <= PrimitiveTypes$1.Triangles; i++) {
        if (prims[i].getNumberOfValues() > 0) {
          if (!model.primitives[i]) {
            model.primitives[i] = publicAPI.createCellArrayMapper();
          }
          const cellMapper = model.primitives[i];
          cellMapper.setCellArray(prims[i]);
          cellMapper.setCurrentInput(poly);
          cellMapper.setCellOffset(cellOffset);
          cellMapper.setPrimitiveType(i);
          cellMapper.setRenderable(model.renderable);
          cellMapper.setIs2D(true);
          cellOffset += prims[i].getNumberOfCells();
          cellMappers.push(cellMapper);
        } else {
          model.primitives[i] = null;
        }
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingChildren(cellMappers);
      publicAPI.removeUnusedNodes();
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  function defaultValues(initialValues) {
    return {
      primitives: [],
      ...initialValues
    };
  }

  // ----------------------------------------------------------------------------
  function extend$C(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, defaultValues(initialValues));

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.primitives = [];

    // Object methods
    vtkWebGPUPolyDataMapper2D(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$C = newInstance$1I(extend$C, 'vtkWebGPUPolyDataMapper2D');

  // Register ourself to WebGPU backend if imported
  registerOverride('vtkMapper2D', newInstance$C);

  // ----------------------------------------------------------------------------
  // vtkWebGPUScalarBarActor methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUScalarBarActor(publicAPI, model) {
    model.classHierarchy.push('vtkWebGPUScalarBarActor');

    // Builds myself.
    publicAPI.buildPass = prepass => {
      if (prepass) {
        model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
        model.WebGPURenderWindow = model.WebGPURenderer.getParent();
        if (!model.scalarBarActorHelper.getRenderable()) {
          model.scalarBarActorHelper.setRenderable(model.renderable);
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
        publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
        publicAPI.removeUnusedNodes();
      }
    };
    publicAPI.opaquePass = (prepass, renderPass) => {
      if (prepass) {
        const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
        const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
        model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$B = {};

  // ----------------------------------------------------------------------------

  function extend$B(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$B, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);
    model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();

    // Object methods
    vtkWebGPUScalarBarActor(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$B = newInstance$1I(extend$B, 'vtkWebGPUScalarBarActor');

  // Register ourself to WebGPU backend if imported
  registerOverride('vtkScalarBarActor', newInstance$B);

  /* eslint-disable no-bitwise */

  // ----------------------------------------------------------------------------
  // vtkWebGPUSampler methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUSampler(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUSampler');
    publicAPI.create = function (device) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      model.device = device;
      model.options.addressModeU = options.addressModeU ? options.addressModeU : 'clamp-to-edge';
      model.options.addressModeV = options.addressModeV ? options.addressModeV : 'clamp-to-edge';
      model.options.addressModeW = options.addressModeW ? options.addressModeW : 'clamp-to-edge';
      model.options.magFilter = options.magFilter ? options.magFilter : 'nearest';
      model.options.minFilter = options.minFilter ? options.minFilter : 'nearest';
      model.options.mipmapFilter = options.mipmapFilter ? options.mipmapFilter : 'nearest';
      model.options.label = model.label;
      model.handle = model.device.getHandle().createSampler(model.options);
      model.bindGroupTime.modified();
    };
    publicAPI.getShaderCode = (binding, group) => {
      const result = `@binding(${binding}) @group(${group}) var ${model.label}: sampler;`;
      return result;
    };
    publicAPI.getBindGroupEntry = () => {
      const foo = {
        resource: model.handle
      };
      return foo;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$A = {
    device: null,
    handle: null,
    label: null,
    options: null
  };

  // ----------------------------------------------------------------------------

  function extend$A(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$A, initialValues);

    // Object methods
    macro.obj(publicAPI, model);
    model.options = {};
    model.bindGroupLayoutEntry = {
      /* eslint-disable no-undef */
      visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
      /* eslint-enable no-undef */
      sampler: {
        // type: 'filtering',
      }
    };
    model.bindGroupTime = {};
    macro.obj(model.bindGroupTime, {
      mtime: 0
    });
    macro.get(publicAPI, model, ['bindGroupTime', 'handle', 'options']);
    macro.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'device', 'label']);
    vtkWebGPUSampler(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$A = macro.newInstance(extend$A);

  // ----------------------------------------------------------------------------

  var vtkWebGPUSampler$1 = {
    newInstance: newInstance$A,
    extend: extend$A
  };

  // ----------------------------------------------------------------------------
  // vtkWebGPUTextureView methods
  // ----------------------------------------------------------------------------

  /* eslint-disable no-bitwise */

  function vtkWebGPUTextureView(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUTextureView');
    publicAPI.create = (texture, options) => {
      model.texture = texture;
      model.options = options;
      model.options.dimension = model.options.dimension || '2d';
      model.options.label = model.label;
      model.textureHandle = texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.texture.getFormat());
      model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
    };
    publicAPI.createFromTextureHandle = (textureHandle, options) => {
      model.texture = null;
      model.options = options;
      model.options.dimension = model.options.dimension || '2d';
      model.options.label = model.label;
      model.textureHandle = textureHandle;
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(options.format);
      model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
      model.bindGroupTime.modified();
    };
    publicAPI.getBindGroupEntry = () => {
      const foo = {
        resource: publicAPI.getHandle()
      };
      return foo;
    };
    publicAPI.getShaderCode = (binding, group) => {
      let ttype = 'f32';
      if (model.bindGroupLayoutEntry.texture.sampleType === 'sint') {
        ttype = 'i32';
      } else if (model.bindGroupLayoutEntry.texture.sampleType === 'uint') {
        ttype = 'u32';
      }
      let result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_${model.options.dimension}<${ttype}>;`;
      if (model.bindGroupLayoutEntry.texture.sampleType === 'depth') {
        result = `@binding(${binding}) @group(${group}) var ${model.label}: texture_depth_${model.options.dimension};`;
      }
      return result;
    };
    publicAPI.addSampler = (device, options) => {
      const newSamp = vtkWebGPUSampler$1.newInstance({
        label: `${model.label}Sampler`
      });
      newSamp.create(device, options);
      publicAPI.setSampler(newSamp);
    };
    publicAPI.getBindGroupTime = () => {
      // check if the handle changed
      if (model.texture && model.texture.getHandle() !== model.textureHandle) {
        model.textureHandle = model.texture.getHandle();
        model.handle = model.textureHandle.createView(model.options);
        model.bindGroupTime.modified();
      }
      return model.bindGroupTime;
    };

    // if the texture has changed then get a new view
    publicAPI.getHandle = () => {
      if (model.texture && model.texture.getHandle() !== model.textureHandle) {
        model.textureHandle = model.texture.getHandle();
        model.handle = model.textureHandle.createView(model.options);
        model.bindGroupTime.modified();
      }
      return model.handle;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$z = {
    texture: null,
    handle: null,
    sampler: null,
    label: null
  };

  // ----------------------------------------------------------------------------

  function extend$z(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$z, initialValues);

    // Object methods
    macro.obj(publicAPI, model);
    model.bindGroupLayoutEntry = {
      /* eslint-disable no-undef */
      visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
      /* eslint-enable no-undef */
      texture: {
        sampleType: 'float',
        viewDimension: '2d'
        // multisampled: false,
      }
    };

    model.bindGroupTime = {};
    macro.obj(model.bindGroupTime, {
      mtime: 0
    });
    macro.get(publicAPI, model, ['bindGroupTime', 'texture']);
    macro.setGet(publicAPI, model, ['bindGroupLayoutEntry', 'label', 'sampler']);
    vtkWebGPUTextureView(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$z = macro.newInstance(extend$z);

  // ----------------------------------------------------------------------------

  var vtkWebGPUTextureView$1 = {
    newInstance: newInstance$z,
    extend: extend$z
  };

  const {
    BufferUsage: BufferUsage$1
  } = vtkWebGPUBufferManager$1;

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  // ----------------------------------------------------------------------------
  // vtkWebGPUTexture methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUTexture(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUTexture');
    publicAPI.create = (device, options) => {
      model.device = device;
      model.width = options.width;
      model.height = options.height;
      model.depth = options.depth ? options.depth : 1;
      const dimension = model.depth === 1 ? '2d' : '3d';
      model.format = options.format ? options.format : 'rgba8unorm';
      model.mipLevel = options.mipLevel ? options.mipLevel : 0;
      /* eslint-disable no-undef */
      /* eslint-disable no-bitwise */
      model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
      /* eslint-enable no-undef */
      /* eslint-enable no-bitwise */
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        // 'rgba8unorm',
        usage: model.usage,
        label: model.label,
        dimension,
        mipLevelCount: model.mipLevel + 1
      });
    };
    publicAPI.assignFromHandle = (device, handle, options) => {
      model.device = device;
      model.handle = handle;
      model.width = options.width;
      model.height = options.height;
      model.depth = options.depth ? options.depth : 1;
      model.format = options.format ? options.format : 'rgba8unorm';
      /* eslint-disable no-undef */
      /* eslint-disable no-bitwise */
      model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
      /* eslint-enable no-undef */
      /* eslint-enable no-bitwise */
    };

    publicAPI.writeImageData = req => {
      let nativeArray = [];
      if (req.canvas) {
        model.device.getHandle().queue.copyExternalImageToTexture({
          source: req.canvas,
          flipY: req.flip
        }, {
          texture: model.handle,
          premultipliedAlpha: true
        }, [model.width, model.height, model.depth]);
        model.ready = true;
        return;
      }
      if (req.jsImageData && !req.nativeArray) {
        req.width = req.jsImageData.width;
        req.height = req.jsImageData.height;
        req.depth = 1;
        req.format = 'rgba8unorm';
        req.flip = true;
        req.nativeArray = req.jsImageData.data;
      }
      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
      let bufferBytesPerRow = model.width * tDetails.stride;
      const fixAll = (arr, height, depth) => {
        // bytesPerRow must be a multiple of 256 so we might need to rebuild
        // the data here before passing to the buffer. e.g. if it is unorm8x4 then
        // we need to have width be a multiple of 64
        const inWidthInBytes = arr.length / (height * depth) * arr.BYTES_PER_ELEMENT;

        // is this a half float texture?
        const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';

        // if we need to copy the data
        if (halfFloat || inWidthInBytes % 256) {
          const inArray = arr;
          const inWidth = inWidthInBytes / inArray.BYTES_PER_ELEMENT;
          const outBytesPerElement = tDetails.elementSize;
          const outWidthInBytes = 256 * Math.floor((inWidth * outBytesPerElement + 255) / 256);
          const outWidth = outWidthInBytes / outBytesPerElement;
          const outArray = macro.newTypedArray(halfFloat ? 'Uint16Array' : inArray.constructor.name, outWidth * height * depth);
          for (let v = 0; v < height * depth; v++) {
            if (halfFloat) {
              for (let i = 0; i < inWidth; i++) {
                outArray[v * outWidth + i] = HalfFloat.toHalf(inArray[v * inWidth + i]);
              }
            } else {
              outArray.set(inArray.subarray(v * inWidth, (v + 1) * inWidth), v * outWidth);
            }
          }
          return [outArray, outWidthInBytes];
        }
        return [arr, inWidthInBytes];
      };
      if (req.nativeArray) {
        nativeArray = req.nativeArray;
      }
      if (req.image) {
        const canvas = document.createElement('canvas');
        canvas.width = req.image.width;
        canvas.height = req.image.height;
        const ctx = canvas.getContext('2d');
        ctx.translate(0, canvas.height);
        ctx.scale(1, -1);
        ctx.drawImage(req.image, 0, 0, req.image.width, req.image.height, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, req.image.width, req.image.height);
        nativeArray = imageData.data;
      }
      const cmdEnc = model.device.createCommandEncoder();
      if (publicAPI.getDimensionality() !== 3) {
        // Non-3D, supports mipmaps
        const mips = vtkTexture$1.generateMipmaps(nativeArray, model.width, model.height, model.mipLevel);
        let currentWidth = model.width;
        let currentHeight = model.height;
        for (let m = 0; m <= model.mipLevel; m++) {
          const fix = fixAll(mips[m], currentHeight, 1);
          bufferBytesPerRow = fix[1];
          const buffRequest = {
            dataArray: req.dataArray ? req.dataArray : null,
            nativeArray: fix[0],
            /* eslint-disable no-undef */
            usage: BufferUsage$1.Texture
            /* eslint-enable no-undef */
          };

          const buff = model.device.getBufferManager().getBuffer(buffRequest);
          cmdEnc.copyBufferToTexture({
            buffer: buff.getHandle(),
            offset: 0,
            bytesPerRow: bufferBytesPerRow,
            rowsPerImage: currentHeight
          }, {
            texture: model.handle,
            mipLevel: m
          }, [currentWidth, currentHeight, 1]);
          currentWidth /= 2;
          currentHeight /= 2;
        }
        model.device.submitCommandEncoder(cmdEnc);
        model.ready = true;
      } else {
        // 3D, no mipmaps
        const fix = fixAll(nativeArray, model.height, model.depth);
        bufferBytesPerRow = fix[1];
        const buffRequest = {
          dataArray: req.dataArray ? req.dataArray : null,
          /* eslint-disable no-undef */
          usage: BufferUsage$1.Texture
          /* eslint-enable no-undef */
        };

        buffRequest.nativeArray = fix[0];
        const buff = model.device.getBufferManager().getBuffer(buffRequest);
        cmdEnc.copyBufferToTexture({
          buffer: buff.getHandle(),
          offset: 0,
          bytesPerRow: bufferBytesPerRow,
          rowsPerImage: model.height
        }, {
          texture: model.handle
        }, [model.width, model.height, model.depth]);
        model.device.submitCommandEncoder(cmdEnc);
        model.ready = true;
      }
    };

    // when data is pulled out of this texture what scale must be applied to
    // get back to the original source data. For formats such as r8unorm we
    // have to multiply by 255.0, for formats such as r16float it is 1.0
    publicAPI.getScale = () => {
      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
      const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';
      return halfFloat ? 1.0 : 255.0;
    };
    publicAPI.getNumberOfComponents = () => {
      const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
      return tDetails.numComponents;
    };
    publicAPI.getDimensionality = () => {
      let dims = 0;
      if (model.width > 1) dims++;
      if (model.height > 1) dims++;
      if (model.depth > 1) dims++;
      return dims;
    };
    publicAPI.resizeToMatch = tex => {
      if (tex.getWidth() !== model.width || tex.getHeight() !== model.height || tex.getDepth() !== model.depth) {
        model.width = tex.getWidth();
        model.height = tex.getHeight();
        model.depth = tex.getDepth();
        model.handle = model.device.getHandle().createTexture({
          size: [model.width, model.height, model.depth],
          format: model.format,
          usage: model.usage,
          label: model.label
        });
      }
    };
    publicAPI.resize = function (width, height) {
      let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      if (width !== model.width || height !== model.height || depth !== model.depth) {
        model.width = width;
        model.height = height;
        model.depth = depth;
        model.handle = model.device.getHandle().createTexture({
          size: [model.width, model.height, model.depth],
          format: model.format,
          usage: model.usage,
          label: model.label
        });
      }
    };
    publicAPI.createView = function (label) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // if options is missing values try to add them in
      if (!options.dimension) {
        options.dimension = model.depth === 1 ? '2d' : '3d';
      }
      const view = vtkWebGPUTextureView$1.newInstance({
        label
      });
      view.create(publicAPI, options);
      return view;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$y = {
    device: null,
    handle: null,
    buffer: null,
    ready: false,
    label: null
  };

  // ----------------------------------------------------------------------------

  function extend$y(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$y, initialValues);

    // Object methods
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ['handle', 'ready', 'width', 'height', 'depth', 'format', 'usage']);
    macro.setGet(publicAPI, model, ['device', 'label']);
    vtkWebGPUTexture(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$y = macro.newInstance(extend$y);

  // ----------------------------------------------------------------------------

  var vtkWebGPUTexture$1 = {
    newInstance: newInstance$y,
    extend: extend$y
  };

  // ----------------------------------------------------------------------------
  // vtkWebGPUPixelSpaceCallbackMapper methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model) {
    model.classHierarchy.push('vtkWebGPUPixelSpaceCallbackMapper');
    publicAPI.opaquePass = (prepass, renderPass) => {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      const aspectRatio = model.WebGPURenderer.getAspectRatio();
      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
      const texels = null;
      if (model.renderable.getUseZValues()) ;
      model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$x = {};

  // ----------------------------------------------------------------------------

  function extend$x(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$x, initialValues);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);

    // Object methods
    vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$x = macro.newInstance(extend$x, 'vtkWebGPUPixelSpaceCallbackMapper');

  // Register ourself to WebGPU backend if imported
  registerOverride('vtkPixelSpaceCallbackMapper', newInstance$x);

  const {
    vtkDebugMacro: vtkDebugMacro$3
  } = macro;

  /* eslint-disable new-cap */

  /*
   * Convenience function to access elements of a gl-matrix.  If it turns
   * out I have rows and columns swapped everywhere, then I'll just change
   * the order of 'row' and 'col' parameters in this function
   */
  // function getMatrixElement(matrix, row, col) {
  //   const idx = (row * 4) + col;
  //   return matrix[idx];
  // }

  // ----------------------------------------------------------------------------
  // vtkCamera methods
  // ----------------------------------------------------------------------------

  function vtkCamera(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkCamera');

    // Set up private variables and methods
    const origin = new Float64Array(3);
    const dopbasis = new Float64Array([0.0, 0.0, -1.0]);
    const upbasis = new Float64Array([0.0, 1.0, 0.0]);
    const tmpMatrix = identity$3(new Float64Array(16));
    const tmpMatrix2 = identity$3(new Float64Array(16));
    const tmpvec1 = new Float64Array(3);
    const tmpvec2 = new Float64Array(3);
    const tmpvec3 = new Float64Array(3);
    const rotateMatrix = identity$3(new Float64Array(16));
    const trans = identity$3(new Float64Array(16));
    const newPosition = new Float64Array(3);
    const newFocalPoint = new Float64Array(3);

    // Internal Functions that don't need to be public
    function computeViewPlaneNormal() {
      // VPN is -DOP
      model.viewPlaneNormal[0] = -model.directionOfProjection[0];
      model.viewPlaneNormal[1] = -model.directionOfProjection[1];
      model.viewPlaneNormal[2] = -model.directionOfProjection[2];
    }
    publicAPI.orthogonalizeViewUp = () => {
      const vt = publicAPI.getViewMatrix();
      model.viewUp[0] = vt[4];
      model.viewUp[1] = vt[5];
      model.viewUp[2] = vt[6];
      publicAPI.modified();
    };
    publicAPI.setPosition = (x, y, z) => {
      if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {
        return;
      }
      model.position[0] = x;
      model.position[1] = y;
      model.position[2] = z;

      // recompute the focal distance
      publicAPI.computeDistance();
      publicAPI.modified();
    };
    publicAPI.setFocalPoint = (x, y, z) => {
      if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {
        return;
      }
      model.focalPoint[0] = x;
      model.focalPoint[1] = y;
      model.focalPoint[2] = z;

      // recompute the focal distance
      publicAPI.computeDistance();
      publicAPI.modified();
    };
    publicAPI.setDistance = d => {
      if (model.distance === d) {
        return;
      }
      model.distance = d;
      if (model.distance < 1e-20) {
        model.distance = 1e-20;
        vtkDebugMacro$3('Distance is set to minimum.');
      }

      // we want to keep the camera pointing in the same direction
      const vec = model.directionOfProjection;

      // recalculate FocalPoint
      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
      publicAPI.modified();
    };

    //----------------------------------------------------------------------------
    // This method must be called when the focal point or camera position changes
    publicAPI.computeDistance = () => {
      const dx = model.focalPoint[0] - model.position[0];
      const dy = model.focalPoint[1] - model.position[1];
      const dz = model.focalPoint[2] - model.position[2];
      model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
      if (model.distance < 1e-20) {
        model.distance = 1e-20;
        vtkDebugMacro$3('Distance is set to minimum.');
        const vec = model.directionOfProjection;

        // recalculate FocalPoint
        model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
        model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
        model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
      }
      model.directionOfProjection[0] = dx / model.distance;
      model.directionOfProjection[1] = dy / model.distance;
      model.directionOfProjection[2] = dz / model.distance;
      computeViewPlaneNormal();
    };

    //----------------------------------------------------------------------------
    // Move the position of the camera along the view plane normal. Moving
    // towards the focal point (e.g., > 1) is a dolly-in, moving away
    // from the focal point (e.g., < 1) is a dolly-out.
    publicAPI.dolly = amount => {
      if (amount <= 0.0) {
        return;
      }

      // dolly moves the camera towards the focus
      const d = model.distance / amount;
      publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);
    };
    publicAPI.roll = angle => {
      const eye = model.position;
      const at = model.focalPoint;
      const up = model.viewUp;
      const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0.0]);
      identity$3(rotateMatrix);
      const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);
      rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle), viewDir);
      transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);
      model.viewUp[0] = viewUpVec4[0];
      model.viewUp[1] = viewUpVec4[1];
      model.viewUp[2] = viewUpVec4[2];
      publicAPI.modified();
    };
    publicAPI.azimuth = angle => {
      const fp = model.focalPoint;
      identity$3(trans);

      // translate the focal point to the origin,
      // rotate about view up,
      // translate back again
      translate(trans, trans, fp);
      rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);
      translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);

      // apply the transform to the position
      transformMat4$1(newPosition, model.position, trans);
      publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
    };
    publicAPI.yaw = angle => {
      const position = model.position;
      identity$3(trans);

      // translate the camera to the origin,
      // rotate about axis,
      // translate back again
      translate(trans, trans, position);
      rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);
      translate(trans, trans, [-position[0], -position[1], -position[2]]);

      // apply the transform to the position
      transformMat4$1(newFocalPoint, model.focalPoint, trans);
      publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);
    };
    publicAPI.elevation = angle => {
      const fp = model.focalPoint;

      // get the eye / camera position from the viewMatrix
      const vt = publicAPI.getViewMatrix();
      const axis = [-vt[0], -vt[1], -vt[2]];
      identity$3(trans);

      // translate the focal point to the origin,
      // rotate about view up,
      // translate back again
      translate(trans, trans, fp);
      rotate(trans, trans, radiansFromDegrees(angle), axis);
      translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);

      // apply the transform to the position
      transformMat4$1(newPosition, model.position, trans);
      publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
    };
    publicAPI.pitch = angle => {
      const position = model.position;
      const vt = publicAPI.getViewMatrix();
      const axis = [vt[0], vt[1], vt[2]];
      identity$3(trans);

      // translate the camera to the origin,
      // rotate about axis,
      // translate back again
      translate(trans, trans, position);
      rotate(trans, trans, radiansFromDegrees(angle), axis);
      translate(trans, trans, [-position[0], -position[1], -position[2]]);

      // apply the transform to the focal point
      transformMat4$1(newFocalPoint, model.focalPoint, trans);
      publicAPI.setFocalPoint(...newFocalPoint);
    };
    publicAPI.zoom = factor => {
      if (factor <= 0) {
        return;
      }
      if (model.parallelProjection) {
        model.parallelScale /= factor;
      } else {
        model.viewAngle /= factor;
      }
      publicAPI.modified();
    };
    publicAPI.translate = (x, y, z) => {
      const offset = [x, y, z];
      add(model.position, offset, model.position);
      add(model.focalPoint, offset, model.focalPoint);
      publicAPI.computeDistance();
      publicAPI.modified();
    };
    publicAPI.applyTransform = transformMat4$1 => {
      const vuOld = [...model.viewUp, 1.0];
      const posNew = [];
      const fpNew = [];
      const vuNew = [];
      vuOld[0] += model.position[0];
      vuOld[1] += model.position[1];
      vuOld[2] += model.position[2];
      transformMat4(posNew, [...model.position, 1.0], transformMat4$1);
      transformMat4(fpNew, [...model.focalPoint, 1.0], transformMat4$1);
      transformMat4(vuNew, vuOld, transformMat4$1);
      vuNew[0] -= posNew[0];
      vuNew[1] -= posNew[1];
      vuNew[2] -= posNew[2];
      publicAPI.setPosition(...posNew.slice(0, 3));
      publicAPI.setFocalPoint(...fpNew.slice(0, 3));
      publicAPI.setViewUp(...vuNew.slice(0, 3));
    };
    publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];
    publicAPI.setThickness = thickness => {
      let t = thickness;
      if (t < 1e-20) {
        t = 1e-20;
        vtkDebugMacro$3('Thickness is set to minimum.');
      }
      publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);
    };
    publicAPI.setThicknessFromFocalPoint = thickness => {
      let t = thickness;
      if (t < 1e-20) {
        t = 1e-20;
        vtkDebugMacro$3('Thickness is set to minimum.');
      }
      publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);
    };

    // Unimplemented functions
    publicAPI.setRoll = angle => {}; // dependency on GetOrientation() and a model.ViewTransform object, see https://github.com/Kitware/VTK/blob/master/Common/Transforms/vtkTransform.cxx and https://vtk.org/doc/nightly/html/classvtkTransform.html
    publicAPI.getRoll = () => {};
    publicAPI.setObliqueAngles = (alpha, beta) => {};
    publicAPI.getOrientation = () => {};
    publicAPI.getOrientationWXYZ = () => {};
    publicAPI.getFrustumPlanes = aspect => {
      // Return array of 24 params (4 params for each of 6 plane equations)
    };
    publicAPI.getCameraLightTransformMatrix = matrix => {
      copy$1(matrix, model.cameraLightTransform);
      return matrix;
    };
    publicAPI.computeCameraLightTransform = () => {
      // not sure if this is the correct transformation, based on the same funciton in VTK
      copy$1(tmpMatrix, publicAPI.getViewMatrix());
      invert(tmpMatrix, tmpMatrix);
      fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);
      multiply$1(tmpMatrix, tmpMatrix, tmpMatrix2);
      identity$3(model.cameraLightTransform);
      translate(model.cameraLightTransform, tmpMatrix, [0.0, 0.0, -1.0]);
    };
    publicAPI.deepCopy = sourceCamera => {};
    publicAPI.physicalOrientationToWorldDirection = ori => {
      // push the x axis through the orientation quat
      const oriq = fromValues(ori[0], ori[1], ori[2], ori[3]);
      const coriq = create();
      const qdir = fromValues(0.0, 0.0, 1.0, 0.0);
      conjugate(coriq, oriq);

      // rotate the z axis by the quat
      multiply(qdir, oriq, qdir);
      multiply(qdir, qdir, coriq);

      // return the z axis in world coords
      return [qdir[0], qdir[1], qdir[2]];
    };
    publicAPI.getPhysicalToWorldMatrix = result => {
      publicAPI.getWorldToPhysicalMatrix(result);
      invert(result, result);
    };
    publicAPI.getWorldToPhysicalMatrix = result => {
      identity$3(result);

      // now the physical to vtk world rotation tform
      const physVRight = [3];
      cross(model.physicalViewNorth, model.physicalViewUp, physVRight);
      result[0] = physVRight[0];
      result[1] = physVRight[1];
      result[2] = physVRight[2];
      result[4] = model.physicalViewUp[0];
      result[5] = model.physicalViewUp[1];
      result[6] = model.physicalViewUp[2];
      result[8] = -model.physicalViewNorth[0];
      result[9] = -model.physicalViewNorth[1];
      result[10] = -model.physicalViewNorth[2];
      transpose(result, result);
      set$1(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);
      scale$2(result, result, tmpvec1);
      translate(result, result, model.physicalTranslation);
    };
    publicAPI.computeViewParametersFromViewMatrix = vmat => {
      // invert to get view to world
      invert(tmpMatrix, vmat);

      // note with glmatrix operations happen in
      // the reverse order
      // mat.scale
      // mat.translate
      // will result in the translation then the scale
      // mat.mult(a,b)
      // results in perform the B transformation then A

      // then extract the params position, orientation
      // push 0,0,0 through to get a translation
      transformMat4$1(tmpvec1, origin, tmpMatrix);
      publicAPI.computeDistance();
      const oldDist = model.distance;
      publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);

      // push basis vectors to get orientation
      transformMat4$1(tmpvec2, dopbasis, tmpMatrix);
      subtract$1(tmpvec2, tmpvec2, tmpvec1);
      normalize$4(tmpvec2, tmpvec2);
      publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);
      transformMat4$1(tmpvec3, upbasis, tmpMatrix);
      subtract$1(tmpvec3, tmpvec3, tmpvec1);
      normalize$4(tmpvec3, tmpvec3);
      publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);
      publicAPI.setDistance(oldDist);
    };

    // the provided matrix should include
    // translation and orientation only
    // mat is physical to view
    publicAPI.computeViewParametersFromPhysicalMatrix = mat => {
      // get the WorldToPhysicalMatrix
      publicAPI.getWorldToPhysicalMatrix(tmpMatrix);

      // first convert the physical -> view matrix to be
      // world -> view
      multiply$1(tmpMatrix, mat, tmpMatrix);
      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
    };
    publicAPI.setViewMatrix = mat => {
      model.viewMatrix = mat;
      if (model.viewMatrix) {
        copy$1(tmpMatrix, model.viewMatrix);
        publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
        transpose(model.viewMatrix, model.viewMatrix);
      }
    };
    publicAPI.getViewMatrix = () => {
      if (model.viewMatrix) {
        return model.viewMatrix;
      }
      lookAt(tmpMatrix, model.position,
      // eye
      model.focalPoint,
      // at
      model.viewUp // up
      );

      transpose(tmpMatrix, tmpMatrix);
      const result = new Float64Array(16);
      copy$1(result, tmpMatrix);
      return result;
    };
    publicAPI.setProjectionMatrix = mat => {
      model.projectionMatrix = mat;
    };
    publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {
      const result = new Float64Array(16);
      identity$3(result);
      if (model.projectionMatrix) {
        const scale = 1 / model.physicalScale;
        set$1(tmpvec1, scale, scale, scale);
        copy$1(result, model.projectionMatrix);
        scale$2(result, result, tmpvec1);
        transpose(result, result);
        return result;
      }
      identity$3(tmpMatrix);

      // FIXME: Not sure what to do about adjust z buffer here
      // adjust Z-buffer range
      // this->ProjectionTransform->AdjustZBuffer( -1, +1, nearz, farz );
      const cWidth = model.clippingRange[1] - model.clippingRange[0];
      const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2.0, model.clippingRange[0] + (farz + 1) * cWidth / 2.0];
      if (model.parallelProjection) {
        // set up a rectangular parallelipiped
        const width = model.parallelScale * aspect;
        const height = model.parallelScale;
        const xmin = (model.windowCenter[0] - 1.0) * width;
        const xmax = (model.windowCenter[0] + 1.0) * width;
        const ymin = (model.windowCenter[1] - 1.0) * height;
        const ymax = (model.windowCenter[1] + 1.0) * height;
        ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
        transpose(tmpMatrix, tmpMatrix);
      } else if (model.useOffAxisProjection) {
        throw new Error('Off-Axis projection is not supported at this time');
      } else {
        const tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2.0);
        let width;
        let height;
        if (model.useHorizontalViewAngle === true) {
          width = model.clippingRange[0] * tmp;
          height = model.clippingRange[0] * tmp / aspect;
        } else {
          width = model.clippingRange[0] * tmp * aspect;
          height = model.clippingRange[0] * tmp;
        }
        const xmin = (model.windowCenter[0] - 1.0) * width;
        const xmax = (model.windowCenter[0] + 1.0) * width;
        const ymin = (model.windowCenter[1] - 1.0) * height;
        const ymax = (model.windowCenter[1] + 1.0) * height;
        const znear = cRange[0];
        const zfar = cRange[1];
        tmpMatrix[0] = 2.0 * znear / (xmax - xmin);
        tmpMatrix[5] = 2.0 * znear / (ymax - ymin);
        tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);
        tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);
        tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
        tmpMatrix[14] = -1.0;
        tmpMatrix[11] = -2.0 * znear * zfar / (zfar - znear);
        tmpMatrix[15] = 0.0;
      }
      copy$1(result, tmpMatrix);
      return result;
    };
    publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {
      const vMat = publicAPI.getViewMatrix();
      const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);
      // mats are transposed so the order is A then B
      // we reuse pMat as it is a copy so we can do what we want with it
      multiply$1(pMat, vMat, pMat);
      return pMat;
    };
    publicAPI.setDirectionOfProjection = (x, y, z) => {
      if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {
        return;
      }
      model.directionOfProjection[0] = x;
      model.directionOfProjection[1] = y;
      model.directionOfProjection[2] = z;
      const vec = model.directionOfProjection;

      // recalculate FocalPoint
      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
      computeViewPlaneNormal();
    };

    // used to handle convert js device orientation angles
    // when you use this method the camera will adjust to the
    // device orientation such that the physicalViewUp you set
    // in world coordinates looks up, and the physicalViewNorth
    // you set in world coorindates will (maybe) point north
    //
    // NOTE WARNING - much of the documentation out there on how
    // orientation works is seriously wrong. Even worse the Chrome
    // device orientation simulator is completely wrong and should
    // never be used. OMG it is so messed up.
    //
    // how it seems to work on iOS is that the device orientation
    // is specified in extrinsic angles with a alpha, beta, gamma
    // convention with axes of Z, X, Y (the code below substitutes
    // the physical coordinate system for these axes to get the right
    // modified coordinate system.
    publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {
      const physVRight = [3];
      cross(model.physicalViewNorth, model.physicalViewUp, physVRight);

      // phone to physical coordinates
      const rotmat = identity$3(new Float64Array(16));
      rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);
      rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);
      rotate(rotmat, rotmat, radiansFromDegrees(gamma), model.physicalViewNorth);
      rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);
      const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);
      const vup = new Float64Array(model.physicalViewNorth);
      transformMat4$1(dop, dop, rotmat);
      transformMat4$1(vup, vup, rotmat);
      publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);
      publicAPI.setViewUp(vup[0], vup[1], vup[2]);
      publicAPI.modified();
    };
    publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {
      const quatMat = identity$3(new Float64Array(16));
      if (degrees !== 0.0 && (x !== 0.0 || y !== 0.0 || z !== 0.0)) {
        // convert to radians
        const angle = radiansFromDegrees(degrees);
        const q = create();
        setAxisAngle(q, [x, y, z], angle);
        fromQuat(quatMat, q);
      }
      const newdop = new Float64Array(3);
      transformMat4$1(newdop, [0.0, 0.0, -1.0], quatMat);
      const newvup = new Float64Array(3);
      transformMat4$1(newvup, [0.0, 1.0, 0.0], quatMat);
      publicAPI.setDirectionOfProjection(...newdop);
      publicAPI.setViewUp(...newvup);
      publicAPI.modified();
    };
    publicAPI.computeClippingRange = bounds => {
      let vn = null;
      let position = null;
      vn = model.viewPlaneNormal;
      position = model.position;
      const a = -vn[0];
      const b = -vn[1];
      const c = -vn[2];
      const d = -(a * position[0] + b * position[1] + c * position[2]);

      // Set the max near clipping plane and the min far clipping plane
      const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];

      // Find the closest / farthest bounding box vertex
      for (let k = 0; k < 2; k++) {
        for (let j = 0; j < 2; j++) {
          for (let i = 0; i < 2; i++) {
            const dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;
            range[0] = dist < range[0] ? dist : range[0];
            range[1] = dist > range[1] ? dist : range[1];
          }
        }
      }
      return range;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$w = {
    position: [0, 0, 1],
    focalPoint: [0, 0, 0],
    viewUp: [0, 1, 0],
    directionOfProjection: [0, 0, -1],
    parallelProjection: false,
    useHorizontalViewAngle: false,
    viewAngle: 30,
    parallelScale: 1,
    clippingRange: [0.01, 1000.01],
    windowCenter: [0, 0],
    viewPlaneNormal: [0, 0, 1],
    useOffAxisProjection: false,
    screenBottomLeft: [-0.5, -0.5, -0.5],
    screenBottomRight: [0.5, -0.5, -0.5],
    screenTopRight: [0.5, 0.5, -0.5],
    freezeFocalPoint: false,
    projectionMatrix: null,
    viewMatrix: null,
    cameraLightTransform: create$3(),
    // used for world to physical transformations
    physicalTranslation: [0, 0, 0],
    physicalScale: 1.0,
    physicalViewUp: [0, 1, 0],
    physicalViewNorth: [0, 0, -1]
  };

  // ----------------------------------------------------------------------------

  function extend$w(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$w, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ['distance']);
    macro.setGet(publicAPI, model, ['parallelProjection', 'useHorizontalViewAngle', 'viewAngle', 'parallelScale', 'useOffAxisProjection', 'freezeFocalPoint', 'physicalScale']);
    macro.getArray(publicAPI, model, ['directionOfProjection', 'viewPlaneNormal', 'position', 'focalPoint']);
    macro.setGetArray(publicAPI, model, ['clippingRange', 'windowCenter'], 2);
    macro.setGetArray(publicAPI, model, ['viewUp', 'screenBottomLeft', 'screenBottomRight', 'screenTopRight', 'physicalTranslation', 'physicalViewUp', 'physicalViewNorth'], 3);

    // Object methods
    vtkCamera(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$w = macro.newInstance(extend$w, 'vtkCamera');

  // ----------------------------------------------------------------------------

  var vtkCamera$1 = {
    newInstance: newInstance$w,
    extend: extend$w
  };

  // ----------------------------------------------------------------------------

  const LIGHT_TYPES = ['HeadLight', 'CameraLight', 'SceneLight'];

  // ----------------------------------------------------------------------------
  // vtkLight methods
  // ----------------------------------------------------------------------------

  function vtkLight(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkLight');
    const tmpVec = new Float64Array(3);
    publicAPI.getTransformedPosition = () => {
      if (model.transformMatrix) {
        transformMat4$1(tmpVec, model.position, model.transformMatrix);
      } else {
        set$1(tmpVec, model.position[0], model.position[1], model.position[2]);
      }
      return tmpVec;
    };
    publicAPI.getTransformedFocalPoint = () => {
      if (model.transformMatrix) {
        transformMat4$1(tmpVec, model.focalPoint, model.transformMatrix);
      } else {
        set$1(tmpVec, model.focalPoint[0], model.focalPoint[1], model.focalPoint[2]);
      }
      return tmpVec;
    };
    publicAPI.getDirection = () => {
      if (model.directionMTime < model.mtime) {
        sub(model.direction, model.focalPoint, model.position);
        normalize(model.direction);
        model.directionMTime = model.mtime;
      }
      return model.direction;
    };

    // Sets the direction from a vec3 instead of a focal point
    publicAPI.setDirection = directionVector => {
      const newFocalPoint = new Float64Array(3);
      sub(newFocalPoint, model.position, directionVector);
      model.focalPoint = newFocalPoint;
    };
    publicAPI.setDirectionAngle = (elevation, azimuth) => {
      const elevationRadians = radiansFromDegrees(elevation);
      const azimuthRadians = radiansFromDegrees(azimuth);
      publicAPI.setPosition(Math.cos(elevationRadians) * Math.sin(azimuthRadians), Math.sin(elevationRadians), Math.cos(elevationRadians) * Math.cos(azimuthRadians));
      publicAPI.setFocalPoint(0, 0, 0);
      publicAPI.setPositional(0);
    };
    publicAPI.setLightTypeToHeadLight = () => {
      publicAPI.setLightType('HeadLight');
    };
    publicAPI.setLightTypeToCameraLight = () => {
      publicAPI.setLightType('CameraLight');
    };
    publicAPI.setLightTypeToSceneLight = () => {
      publicAPI.setTransformMatrix(null);
      publicAPI.setLightType('SceneLight');
    };
    publicAPI.lightTypeIsHeadLight = () => model.lightType === 'HeadLight';
    publicAPI.lightTypeIsSceneLight = () => model.lightType === 'SceneLight';
    publicAPI.lightTypeIsCameraLight = () => model.lightType === 'CameraLight';
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$v = {
    switch: true,
    intensity: 1,
    color: [1, 1, 1],
    position: [0, 0, 1],
    focalPoint: [0, 0, 0],
    positional: false,
    exponent: 1,
    coneAngle: 30,
    coneFalloff: 5,
    attenuationValues: [1, 0, 0],
    transformMatrix: null,
    lightType: 'SceneLight',
    shadowAttenuation: 1,
    direction: [0, 0, 0],
    directionMTime: 0
  };

  // ----------------------------------------------------------------------------

  function extend$v(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$v, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ['intensity', 'switch', 'positional', 'exponent', 'coneAngle', 'coneFalloff', 'transformMatrix', 'lightType', 'shadowAttenuation', 'attenuationValues']);
    macro.setGetArray(publicAPI, model, ['color', 'position', 'focalPoint', 'attenuationValues'], 3);

    // Object methods
    vtkLight(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$v = macro.newInstance(extend$v, 'vtkLight');

  // ----------------------------------------------------------------------------

  var vtkLight$1 = {
    newInstance: newInstance$v,
    extend: extend$v,
    LIGHT_TYPES
  };

  const {
    vtkErrorMacro: vtkErrorMacro$c
  } = macro;
  function notImplemented$1(method) {
    return () => vtkErrorMacro$c(`vtkViewport::${method} - NOT IMPLEMENTED`);
  }

  // ----------------------------------------------------------------------------
  // vtkViewport methods
  // ----------------------------------------------------------------------------

  function vtkViewport(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkViewport');

    // Public API methods
    publicAPI.getViewProps = () => model.props;
    publicAPI.hasViewProp = prop => model.props.includes(prop);
    publicAPI.addViewProp = prop => {
      if (prop && !publicAPI.hasViewProp(prop)) {
        model.props.push(prop);
      }
    };
    publicAPI.removeViewProp = prop => {
      const newPropList = model.props.filter(item => item !== prop);
      if (model.props.length !== newPropList.length) {
        model.props = newPropList;
      }
    };
    publicAPI.removeAllViewProps = () => {
      model.props = [];
    };

    // this method get all the props including any nested props
    function gatherProps(prop) {
      let allProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      allProps.push(prop);
      const children = prop.getNestedProps();
      if (children && children.length) {
        for (let i = 0; i < children.length; i++) {
          gatherProps(children[i], allProps);
        }
      }
      return allProps;
    }
    publicAPI.getViewPropsWithNestedProps = () => {
      const allPropsArray = [];
      for (let i = 0; i < model.props.length; i++) {
        gatherProps(model.props[i], allPropsArray);
      }
      return allPropsArray;
    };
    publicAPI.addActor2D = publicAPI.addViewProp;
    publicAPI.removeActor2D = prop => {
      // VTK way: model.actors2D.RemoveItem(prop);
      publicAPI.removeViewProp(prop);
    };
    publicAPI.getActors2D = () => {
      model.actors2D = [];
      model.props.forEach(prop => {
        model.actors2D = model.actors2D.concat(prop.getActors2D());
      });
      return model.actors2D;
    };
    publicAPI.displayToView = () => vtkErrorMacro$c('call displayToView on your view instead');
    publicAPI.viewToDisplay = () => vtkErrorMacro$c('callviewtodisplay on your view instead');
    publicAPI.getSize = () => vtkErrorMacro$c('call getSize on your View instead');
    publicAPI.normalizedDisplayToProjection = (x, y, z) => {
      // first to normalized viewport
      const nvp = publicAPI.normalizedDisplayToNormalizedViewport(x, y, z);

      // then to view
      return publicAPI.normalizedViewportToProjection(nvp[0], nvp[1], nvp[2]);
    };
    publicAPI.normalizedDisplayToNormalizedViewport = (x, y, z) => {
      const scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
      return [(x - model.viewport[0]) / scale[0], (y - model.viewport[1]) / scale[1], z];
    };
    publicAPI.normalizedViewportToProjection = (x, y, z) => [x * 2.0 - 1.0, y * 2.0 - 1.0, z * 2.0 - 1.0];
    publicAPI.projectionToNormalizedDisplay = (x, y, z) => {
      // first to nvp
      const nvp = publicAPI.projectionToNormalizedViewport(x, y, z);

      // then to ndp
      return publicAPI.normalizedViewportToNormalizedDisplay(nvp[0], nvp[1], nvp[2]);
    };
    publicAPI.normalizedViewportToNormalizedDisplay = (x, y, z) => {
      const scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
      return [x * scale[0] + model.viewport[0], y * scale[1] + model.viewport[1], z];
    };
    publicAPI.projectionToNormalizedViewport = (x, y, z) => [(x + 1.0) * 0.5, (y + 1.0) * 0.5, (z + 1.0) * 0.5];
    publicAPI.PickPropFrom = notImplemented$1('PickPropFrom');
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$u = {
    // _vtkWindow: null,
    background: [0, 0, 0],
    background2: [0.2, 0.2, 0.2],
    gradientBackground: false,
    viewport: [0, 0, 1, 1],
    aspect: [1, 1],
    pixelAspect: [1, 1],
    props: [],
    actors2D: []
  };

  // ----------------------------------------------------------------------------

  function extend$u(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$u, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.event(publicAPI, model, 'event');
    macro.setGetArray(publicAPI, model, ['viewport'], 4);
    macro.setGetArray(publicAPI, model, ['background', 'background2'], 3);
    vtkViewport(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$u = macro.newInstance(extend$u, 'vtkViewport');

  // ----------------------------------------------------------------------------

  var vtkViewport$1 = {
    newInstance: newInstance$u,
    extend: extend$u
  };

  const {
    vtkDebugMacro: vtkDebugMacro$2,
    vtkErrorMacro: vtkErrorMacro$b,
    vtkWarningMacro: vtkWarningMacro$1
  } = macro$1;
  function notImplemented(method) {
    return () => vtkErrorMacro$b(`vtkRenderer::${method} - NOT IMPLEMENTED`);
  }

  // ----------------------------------------------------------------------------
  // vtkRenderer methods
  // ----------------------------------------------------------------------------

  function vtkRenderer(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkRenderer');

    // Events
    const COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {
      type: 'ComputeVisiblePropBoundsEvent',
      renderer: publicAPI
    };
    const RESET_CAMERA_CLIPPING_RANGE_EVENT = {
      type: 'ResetCameraClippingRangeEvent',
      renderer: publicAPI
    };
    const RESET_CAMERA_EVENT = {
      type: 'ResetCameraEvent',
      renderer: publicAPI
    };
    publicAPI.updateCamera = () => {
      if (!model.activeCamera) {
        vtkDebugMacro$2('No cameras are on, creating one.');
        // the get method will automagically create a camera
        // and reset it since one hasn't been specified yet.
        publicAPI.getActiveCameraAndResetIfCreated();
      }

      // update the viewing transformation
      model.activeCamera.render(publicAPI);
      return true;
    };
    publicAPI.updateLightsGeometryToFollowCamera = () => {
      // only update the light's geometry if this Renderer is tracking
      // this lights.  That allows one renderer to view the lights that
      // another renderer is setting up.
      const camera = publicAPI.getActiveCameraAndResetIfCreated();
      model.lights.forEach(light => {
        if (light.lightTypeIsSceneLight()) ; else if (light.lightTypeIsHeadLight()) {
          // update position and orientation of light to match camera.
          light.setPositionFrom(camera.getPositionByReference());
          light.setFocalPointFrom(camera.getFocalPointByReference());
          light.modified(camera.getMTime());
        } else if (light.lightTypeIsCameraLight()) {
          light.setTransformMatrix(camera.getCameraLightTransformMatrix(create$3()));
        } else {
          vtkErrorMacro$b('light has unknown light type', light.get());
        }
      });
    };
    publicAPI.updateLightGeometry = () => {
      if (model.lightFollowCamera) {
        // only update the light's geometry if this Renderer is tracking
        // this lights.  That allows one renderer to view the lights that
        // another renderer is setting up.
        return publicAPI.updateLightsGeometryToFollowCamera();
      }
      return true;
    };
    publicAPI.allocateTime = notImplemented('allocateTime');
    publicAPI.updateGeometry = notImplemented('updateGeometry');
    publicAPI.getVTKWindow = () => model._renderWindow;
    publicAPI.setLayer = layer => {
      vtkDebugMacro$2(publicAPI.getClassName(), publicAPI, 'setting Layer to ', layer);
      if (model.layer !== layer) {
        model.layer = layer;
        publicAPI.modified();
      }
      publicAPI.setPreserveColorBuffer(!!layer);
    };
    publicAPI.setActiveCamera = camera => {
      if (model.activeCamera === camera) {
        return false;
      }
      model.activeCamera = camera;
      publicAPI.modified();
      publicAPI.invokeEvent({
        type: 'ActiveCameraEvent',
        camera
      });
      return true;
    };
    publicAPI.makeCamera = () => {
      const camera = vtkCamera$1.newInstance();
      publicAPI.invokeEvent({
        type: 'CreateCameraEvent',
        camera
      });
      return camera;
    };

    // Replace the set/get macro method
    publicAPI.getActiveCamera = () => {
      if (!model.activeCamera) {
        model.activeCamera = publicAPI.makeCamera();
      }
      return model.activeCamera;
    };
    publicAPI.getActiveCameraAndResetIfCreated = () => {
      if (!model.activeCamera) {
        publicAPI.getActiveCamera();
        publicAPI.resetCamera();
      }
      return model.activeCamera;
    };
    publicAPI.getActors = () => {
      model.actors = [];
      model.props.forEach(prop => {
        model.actors = model.actors.concat(prop.getActors());
      });
      return model.actors;
    };
    publicAPI.addActor = publicAPI.addViewProp;
    publicAPI.removeActor = actor => {
      model.actors = model.actors.filter(a => a !== actor);
      publicAPI.removeViewProp(actor);
      publicAPI.modified();
    };
    publicAPI.removeAllActors = () => {
      const actors = publicAPI.getActors();
      actors.forEach(actor => {
        publicAPI.removeViewProp(actor);
      });
      model.actors = [];
      publicAPI.modified();
    };
    publicAPI.getVolumes = () => {
      model.volumes = [];
      model.props.forEach(prop => {
        model.volumes = model.volumes.concat(prop.getVolumes());
      });
      return model.volumes;
    };
    publicAPI.addVolume = publicAPI.addViewProp;
    publicAPI.removeVolume = volume => {
      model.volumes = model.volumes.filter(v => v !== volume);
      publicAPI.removeViewProp(volume);
      publicAPI.modified();
    };
    publicAPI.removeAllVolumes = () => {
      const volumes = publicAPI.getVolumes();
      volumes.forEach(volume => {
        publicAPI.removeViewProp(volume);
      });
      model.volumes = [];
      publicAPI.modified();
    };
    publicAPI.hasLight = light => model.lights.includes(light);
    publicAPI.addLight = light => {
      if (light && !publicAPI.hasLight(light)) {
        model.lights.push(light);
        publicAPI.modified();
      }
    };
    publicAPI.removeLight = light => {
      model.lights = model.lights.filter(l => l !== light);
      publicAPI.modified();
    };
    publicAPI.removeAllLights = () => {
      model.lights = [];
      publicAPI.modified();
    };
    publicAPI.setLightCollection = lights => {
      model.lights = lights;
      publicAPI.modified();
    };
    publicAPI.makeLight = vtkLight$1.newInstance;
    publicAPI.createLight = () => {
      if (!model.automaticLightCreation) {
        return;
      }
      if (model._createdLight) {
        publicAPI.removeLight(model._createdLight);
        model._createdLight.delete();
        model._createdLight = null;
      }
      model._createdLight = publicAPI.makeLight();
      publicAPI.addLight(model._createdLight);
      model._createdLight.setLightTypeToHeadLight();

      // set these values just to have a good default should LightFollowCamera
      // be turned off.
      model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());
      model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());
    };

    // requires the aspect ratio of the viewport as X/Y
    publicAPI.normalizedDisplayToWorld = (x, y, z, aspect) => {
      let vpd = publicAPI.normalizedDisplayToProjection(x, y, z);
      vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);
      return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);
    };

    // requires the aspect ratio of the viewport as X/Y
    publicAPI.worldToNormalizedDisplay = (x, y, z, aspect) => {
      let vpd = publicAPI.worldToView(x, y, z);
      vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);
      return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);
    };

    // requires the aspect ratio of the viewport as X/Y
    publicAPI.viewToWorld = (x, y, z) => {
      if (model.activeCamera === null) {
        vtkErrorMacro$b('ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0');
        return [0, 0, 0];
      }

      // get the view matrix from the active camera
      const matrix = model.activeCamera.getViewMatrix();
      invert(matrix, matrix);
      transpose(matrix, matrix);

      // Transform point to world coordinates
      const result = new Float64Array([x, y, z]);
      transformMat4$1(result, result, matrix);
      return result;
    };
    publicAPI.projectionToView = (x, y, z, aspect) => {
      if (model.activeCamera === null) {
        vtkErrorMacro$b('ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0');
        return [0, 0, 0];
      }

      // get the projection transformation from the active camera
      const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);
      invert(matrix, matrix);
      transpose(matrix, matrix);

      // Transform point to world coordinates
      const result = new Float64Array([x, y, z]);
      transformMat4$1(result, result, matrix);
      return result;
    };

    // Convert world point coordinates to view coordinates.
    publicAPI.worldToView = (x, y, z) => {
      if (model.activeCamera === null) {
        vtkErrorMacro$b('WorldToView: no active camera, cannot compute view to world, returning 0,0,0');
        return [0, 0, 0];
      }

      // get the view transformation from the active camera
      const matrix = model.activeCamera.getViewMatrix();
      transpose(matrix, matrix);
      const result = new Float64Array([x, y, z]);
      transformMat4$1(result, result, matrix);
      return result;
    };

    // Convert world point coordinates to view coordinates.
    // requires the aspect ratio of the viewport as X/Y
    publicAPI.viewToProjection = (x, y, z, aspect) => {
      if (model.activeCamera === null) {
        vtkErrorMacro$b('ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0');
        return [0, 0, 0];
      }

      // get the projeciton transformation from the active camera
      const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);
      transpose(matrix, matrix);
      const result = new Float64Array([x, y, z]);
      transformMat4$1(result, result, matrix);
      return result;
    };
    publicAPI.computeVisiblePropBounds = () => {
      model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];
      model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];
      model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];
      model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];
      model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];
      model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];
      let nothingVisible = true;
      publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);

      // loop through all props
      for (let index = 0; index < model.props.length; ++index) {
        const prop = model.props[index];
        if (prop.getVisibility() && prop.getUseBounds()) {
          const bounds = prop.getBounds();
          if (bounds && areBoundsInitialized(bounds)) {
            nothingVisible = false;
            if (bounds[0] < model.allBounds[0]) {
              model.allBounds[0] = bounds[0];
            }
            if (bounds[1] > model.allBounds[1]) {
              model.allBounds[1] = bounds[1];
            }
            if (bounds[2] < model.allBounds[2]) {
              model.allBounds[2] = bounds[2];
            }
            if (bounds[3] > model.allBounds[3]) {
              model.allBounds[3] = bounds[3];
            }
            if (bounds[4] < model.allBounds[4]) {
              model.allBounds[4] = bounds[4];
            }
            if (bounds[5] > model.allBounds[5]) {
              model.allBounds[5] = bounds[5];
            }
          }
        }
      }
      if (nothingVisible) {
        uninitializeBounds(model.allBounds);
        vtkDebugMacro$2("Can't compute bounds, no 3D props are visible");
      }
      return model.allBounds;
    };
    publicAPI.resetCamera = function () {
      let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
      const center = [0, 0, 0];
      if (!areBoundsInitialized(boundsToUse)) {
        vtkDebugMacro$2('Cannot reset camera!');
        return false;
      }
      let vn = null;
      if (publicAPI.getActiveCamera()) {
        vn = model.activeCamera.getViewPlaneNormal();
      } else {
        vtkErrorMacro$b('Trying to reset non-existent camera');
        return false;
      }

      // Reset the perspective zoom factors, otherwise subsequent zooms will cause
      // the view angle to become very small and cause bad depth sorting.
      model.activeCamera.setViewAngle(30.0);
      center[0] = (boundsToUse[0] + boundsToUse[1]) / 2.0;
      center[1] = (boundsToUse[2] + boundsToUse[3]) / 2.0;
      center[2] = (boundsToUse[4] + boundsToUse[5]) / 2.0;
      let w1 = boundsToUse[1] - boundsToUse[0];
      let w2 = boundsToUse[3] - boundsToUse[2];
      let w3 = boundsToUse[5] - boundsToUse[4];
      w1 *= w1;
      w2 *= w2;
      w3 *= w3;
      let radius = w1 + w2 + w3;

      // If we have just a single point, pick a radius of 1.0
      radius = radius === 0 ? 1.0 : radius;

      // compute the radius of the enclosing sphere
      radius = Math.sqrt(radius) * 0.5;

      // default so that the bounding sphere fits within the view fustrum

      // compute the distance from the intersection of the view frustum with the
      // bounding sphere. Basically in 2D draw a circle representing the bounding
      // sphere in 2D then draw a horizontal line going out from the center of
      // the circle. That is the camera view. Then draw a line from the camera
      // position to the point where it intersects the circle. (it will be tangent
      // to the circle at this point, this is important, only go to the tangent
      // point, do not draw all the way to the view plane). Then draw the radius
      // from the tangent point to the center of the circle. You will note that
      // this forms a right triangle with one side being the radius, another being
      // the target distance for the camera, then just find the target dist using
      // a sin.
      const angle = radiansFromDegrees(model.activeCamera.getViewAngle());
      const parallelScale = radius;
      const distance = radius / Math.sin(angle * 0.5);

      // check view-up vector against view plane normal
      const vup = model.activeCamera.getViewUp();
      if (Math.abs(dot(vup, vn)) > 0.999) {
        vtkWarningMacro$1('Resetting view-up since view plane normal is parallel');
        model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);
      }

      // update the camera
      model.activeCamera.setFocalPoint(center[0], center[1], center[2]);
      model.activeCamera.setPosition(center[0] + distance * vn[0], center[1] + distance * vn[1], center[2] + distance * vn[2]);
      publicAPI.resetCameraClippingRange(boundsToUse);

      // setup default parallel scale
      model.activeCamera.setParallelScale(parallelScale);

      // update reasonable world to physical values
      model.activeCamera.setPhysicalScale(radius);
      model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]);

      // Here to let parallel/distributed compositing intercept
      // and do the right thing.
      publicAPI.invokeEvent(RESET_CAMERA_EVENT);
      return true;
    };
    publicAPI.resetCameraClippingRange = function () {
      let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
      if (!areBoundsInitialized(boundsToUse)) {
        vtkDebugMacro$2('Cannot reset camera clipping range!');
        return false;
      }

      // Make sure we have an active camera
      publicAPI.getActiveCameraAndResetIfCreated();
      if (!model.activeCamera) {
        vtkErrorMacro$b('Trying to reset clipping range of non-existent camera');
        return false;
      }

      // Get the exact range for the bounds
      const range = model.activeCamera.computeClippingRange(boundsToUse);

      // do not let far - near be less than 0.1 of the window height
      // this is for cases such as 2D images which may have zero range
      let minGap = 0.0;
      if (model.activeCamera.getParallelProjection()) {
        minGap = 0.2 * model.activeCamera.getParallelScale();
      } else {
        const angle = radiansFromDegrees(model.activeCamera.getViewAngle());
        minGap = 0.2 * Math.tan(angle / 2.0) * range[1];
      }
      if (range[1] - range[0] < minGap) {
        minGap = minGap - range[1] + range[0];
        range[1] += minGap / 2.0;
        range[0] -= minGap / 2.0;
      }

      // Do not let the range behind the camera throw off the calculation.
      if (range[0] < 0.0) {
        range[0] = 0.0;
      }

      // Give ourselves a little breathing room
      range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;
      range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;

      // Make sure near is not bigger than far
      range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];

      // Make sure near is at least some fraction of far - this prevents near
      // from being behind the camera or too close in front. How close is too
      // close depends on the resolution of the depth buffer
      if (!model.nearClippingPlaneTolerance) {
        model.nearClippingPlaneTolerance = 0.01;
      }

      // make sure the front clipping range is not too far from the far clippnig
      // range, this is to make sure that the zbuffer resolution is effectively
      // used
      if (range[0] < model.nearClippingPlaneTolerance * range[1]) {
        range[0] = model.nearClippingPlaneTolerance * range[1];
      }
      model.activeCamera.setClippingRange(range[0], range[1]);

      // Here to let parallel/distributed compositing intercept
      // and do the right thing.
      publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);
      return false;
    };
    publicAPI.setRenderWindow = renderWindow => {
      if (renderWindow !== model._renderWindow) {
        model._vtkWindow = renderWindow;
        model._renderWindow = renderWindow;
      }
    };
    publicAPI.visibleActorCount = () => model.props.filter(prop => prop.getVisibility()).length;
    publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;
    publicAPI.getMTime = () => {
      let m1 = model.mtime;
      const m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;
      if (m2 > m1) {
        m1 = m2;
      }
      const m3 = model._createdLight ? model._createdLight.getMTime() : 0;
      if (m3 > m1) {
        m1 = m3;
      }
      return m1;
    };
    publicAPI.getTransparent = () => !!model.preserveColorBuffer;
    publicAPI.isActiveCameraCreated = () => !!model.activeCamera;
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$t = {
    pickedProp: null,
    activeCamera: null,
    allBounds: [],
    ambient: [1, 1, 1],
    allocatedRenderTime: 100,
    timeFactor: 1,
    automaticLightCreation: true,
    twoSidedLighting: true,
    lastRenderTimeInSeconds: -1,
    renderWindow: null,
    lights: [],
    actors: [],
    volumes: [],
    lightFollowCamera: true,
    numberOfPropsRendered: 0,
    propArray: null,
    pathArray: null,
    layer: 0,
    preserveColorBuffer: false,
    preserveDepthBuffer: false,
    computeVisiblePropBounds: createUninitializedBounds(),
    interactive: true,
    nearClippingPlaneTolerance: 0,
    clippingRangeExpansion: 0.05,
    erase: true,
    draw: true,
    useShadows: false,
    useDepthPeeling: false,
    occlusionRatio: 0,
    maximumNumberOfPeels: 4,
    selector: null,
    delegate: null,
    texturedBackground: false,
    backgroundTexture: null,
    environmentTexture: null,
    environmentTextureDiffuseStrength: 1,
    environmentTextureSpecularStrength: 1,
    useEnvironmentTextureAsBackground: false,
    pass: 0
  };

  // ----------------------------------------------------------------------------

  function extend$t(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$t, initialValues);

    // Inheritance
    vtkViewport$1.extend(publicAPI, model, initialValues);

    // make sure background has 4 entries. Default to opaque black
    if (!model.background) model.background = [0, 0, 0, 1];
    while (model.background.length < 3) model.background.push(0);
    if (model.background.length === 3) model.background.push(1);

    // Build VTK API
    get$1(publicAPI, model, ['_renderWindow', 'allocatedRenderTime', 'timeFactor', 'lastRenderTimeInSeconds', 'numberOfPropsRendered', 'lastRenderingUsedDepthPeeling', 'selector']);
    setGet(publicAPI, model, ['twoSidedLighting', 'lightFollowCamera', 'automaticLightCreation', 'erase', 'draw', 'nearClippingPlaneTolerance', 'clippingRangeExpansion', 'backingStore', 'interactive', 'layer', 'preserveColorBuffer', 'preserveDepthBuffer', 'useDepthPeeling', 'occlusionRatio', 'maximumNumberOfPeels', 'delegate', 'backgroundTexture', 'texturedBackground', 'environmentTexture', 'environmentTextureDiffuseStrength', 'environmentTextureSpecularStrength', 'useEnvironmentTextureAsBackground', 'useShadows', 'pass']);
    getArray(publicAPI, model, ['actors', 'volumes', 'lights']);
    setGetArray(publicAPI, model, ['background'], 4, 1.0);
    moveToProtected(publicAPI, model, ['renderWindow']);

    // Object methods
    vtkRenderer(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$t = newInstance$1I(extend$t, 'vtkRenderer');

  // ----------------------------------------------------------------------------

  var vtkRenderer$1 = {
    newInstance: newInstance$t,
    extend: extend$t
  };

  const DEFAULT_VIEW_API = 'WebGL';
  const VIEW_CONSTRUCTORS = Object.create(null);

  // ----------------------------------------------------------------------------
  // static methods
  // ----------------------------------------------------------------------------

  function registerViewConstructor(name, constructor) {
    VIEW_CONSTRUCTORS[name] = constructor;
  }
  function listViewAPIs() {
    return Object.keys(VIEW_CONSTRUCTORS);
  }
  function newAPISpecificView(name) {
    let initialValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return VIEW_CONSTRUCTORS[name] && VIEW_CONSTRUCTORS[name](initialValues);
  }

  // ----------------------------------------------------------------------------
  // vtkRenderWindow methods
  // ----------------------------------------------------------------------------

  function vtkRenderWindow(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkRenderWindow');

    // Add renderer
    publicAPI.addRenderer = renderer => {
      if (publicAPI.hasRenderer(renderer)) {
        return;
      }
      renderer.setRenderWindow(publicAPI);
      model.renderers.push(renderer);

      // for (this->Renderers->InitTraversal(rsit);
      //      (aren = this->Renderers->GetNextRenderer(rsit)); )
      //   {
      //   aren->SetAllocatedRenderTime
      //     (1.0/(this->DesiredUpdateRate*this->Renderers->GetNumberOfItems()));
      //   }

      publicAPI.modified();
    };

    // Remove renderer
    publicAPI.removeRenderer = renderer => {
      model.renderers = model.renderers.filter(r => r !== renderer);
      publicAPI.modified();
    };
    publicAPI.hasRenderer = ren => model.renderers.indexOf(ren) !== -1;

    // get an API specific view of this data
    publicAPI.newAPISpecificView = function (name) {
      let initialValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return newAPISpecificView(name || model.defaultViewAPI, initialValues);
    };

    // Add renderer
    publicAPI.addView = view => {
      if (publicAPI.hasView(view)) {
        return;
      }
      view.setRenderable(publicAPI);
      model._views.push(view);
      publicAPI.modified();
    };

    // Remove renderer
    publicAPI.removeView = view => {
      model._views = model._views.filter(r => r !== view);
      publicAPI.modified();
    };
    publicAPI.hasView = view => model._views.indexOf(view) !== -1;

    // handle any pre render initializations
    publicAPI.preRender = () => {
      model.renderers.forEach(ren => {
        // make sure we have a camera
        if (!ren.isActiveCameraCreated()) {
          ren.resetCamera();
        }
      });
    };
    publicAPI.render = () => {
      publicAPI.preRender();
      if (model.interactor) {
        model.interactor.render();
      } else {
        model._views.forEach(view => view.traverseAllPasses());
      }
    };
    publicAPI.getStatistics = () => {
      const results = {
        propCount: 0,
        invisiblePropCount: 0,
        gpuMemoryMB: 0
      };
      model._views.forEach(v => {
        if (v.getGraphicsMemoryInfo) results.gpuMemoryMB += v.getGraphicsMemoryInfo() / 1e6;
      });
      model.renderers.forEach(ren => {
        const props = ren.getViewProps();
        const gren = model._views[0].getViewNodeFor(ren);
        props.forEach(prop => {
          if (prop.getVisibility()) {
            results.propCount += 1;
            const mpr = prop.getMapper && prop.getMapper();
            if (mpr && mpr.getPrimitiveCount) {
              const gmpr = gren.getViewNodeFor(mpr);
              if (gmpr) {
                if (gmpr.getAllocatedGPUMemoryInBytes) {
                  results.gpuMemoryMB += gmpr.getAllocatedGPUMemoryInBytes() / 1e6;
                }
                const pcount = mpr.getPrimitiveCount();
                Object.keys(pcount).forEach(keyName => {
                  if (!results[keyName]) {
                    results[keyName] = 0;
                  }
                  results[keyName] += pcount[keyName];
                });
              }
            }
          } else {
            results.invisiblePropCount += 1;
          }
        });
      });
      results.str = Object.keys(results).map(keyName => `${keyName}: ${results[keyName]}`).join('\n');
      return results;
    };
    publicAPI.captureImages = function () {
      let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';
      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      macro.setImmediate(publicAPI.render);
      return model._views.map(view => view.captureNextImage ? view.captureNextImage(format, opts) : undefined).filter(i => !!i);
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$s = {
    defaultViewAPI: DEFAULT_VIEW_API,
    renderers: [],
    views: [],
    interactor: null,
    neverRendered: true,
    numberOfLayers: 1
  };

  // ----------------------------------------------------------------------------

  function extend$s(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$s, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ['interactor', 'numberOfLayers', '_views', 'defaultViewAPI']);
    macro.get(publicAPI, model, ['neverRendered']);
    macro.getArray(publicAPI, model, ['renderers']);
    macro.moveToProtected(publicAPI, model, ['views']);
    macro.event(publicAPI, model, 'completion');

    // Object methods
    vtkRenderWindow(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$s = macro.newInstance(extend$s, 'vtkRenderWindow');

  // ----------------------------------------------------------------------------

  var vtkRenderWindow$1 = {
    newInstance: newInstance$s,
    extend: extend$s,
    registerViewConstructor,
    listViewAPIs,
    newAPISpecificView
  };

  const Device$1 = {
    Unknown: 0,
    LeftController: 1,
    RightController: 2
  };
  const Input$1 = {
    Unknown: 0,
    Trigger: 1,
    TrackPad: 2,
    Grip: 3,
    Thumbstick: 4,
    A: 5,
    B: 6,
    ApplicationMenu: 7 // Not exposed in WebXR API
  };

  const Axis = {
    Unknown: 0,
    TouchpadX: 1,
    TouchpadY: 2,
    ThumbstickX: 3,
    ThumbstickY: 4
  };
  var Constants$1 = {
    Device: Device$1,
    Input: Input$1,
    Axis
  };

  const {
    Device,
    Input
  } = Constants$1;
  const {
    vtkWarningMacro,
    vtkErrorMacro: vtkErrorMacro$a,
    normalizeWheel,
    vtkOnceErrorMacro
  } = macro;

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  const EMPTY_MOUSE_EVENT = {
    ctrlKey: false,
    altKey: false,
    shiftKey: false
  };
  const deviceInputMap = {
    'xr-standard': [Input.Trigger, Input.Grip, Input.TrackPad, Input.Thumbstick, Input.A, Input.B]
  };
  const handledEvents = ['StartAnimation', 'Animation', 'EndAnimation', 'PointerEnter', 'PointerLeave', 'MouseEnter', 'MouseLeave', 'StartMouseMove', 'MouseMove', 'EndMouseMove', 'LeftButtonPress', 'LeftButtonRelease', 'MiddleButtonPress', 'MiddleButtonRelease', 'RightButtonPress', 'RightButtonRelease', 'KeyPress', 'KeyDown', 'KeyUp', 'StartMouseWheel', 'MouseWheel', 'EndMouseWheel', 'StartPinch', 'Pinch', 'EndPinch', 'StartPan', 'Pan', 'EndPan', 'StartRotate', 'Rotate', 'EndRotate', 'Button3D', 'Move3D', 'StartPointerLock', 'EndPointerLock', 'StartInteraction', 'Interaction', 'EndInteraction', 'AnimationFrameRateUpdate'];
  function preventDefault(event) {
    if (event.cancelable) {
      event.preventDefault();
    }
  }
  function pointerCacheToPositions(cache) {
    const positions = Object.create(null);
    cache.forEach(_ref => {
      let {
        pointerId,
        position
      } = _ref;
      positions[pointerId] = position;
    });
    return positions;
  }

  // ----------------------------------------------------------------------------
  // vtkRenderWindowInteractor methods
  // ----------------------------------------------------------------------------

  function vtkRenderWindowInteractor(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkRenderWindowInteractor');

    // Capture "parentClass" api for internal use
    const superClass = {
      ...publicAPI
    };

    // Initialize list of requesters
    const animationRequesters = new Set();

    // map from pointerId to { pointerId: number, position: [x, y] }
    const pointerCache = new Map();

    // Factor to apply on wheel spin.
    let wheelCoefficient = 1;

    // Public API methods

    //----------------------------------------------------------------------
    publicAPI.start = () => {
      // Let the compositing handle the event loop if it wants to.
      // if (publicAPI.HasObserver(vtkCommand::StartEvent) && !publicAPI.HandleEventLoop) {
      //   publicAPI.invokeEvent({ type: 'StartEvent' });
      //   return;
      // }

      // As a convenience, initialize if we aren't initialized yet.
      if (!model.initialized) {
        publicAPI.initialize();
        if (!model.initialized) {
          return;
        }
      }
      // Pass execution to the subclass which will run the event loop,
      // this will not return until TerminateApp is called.
      publicAPI.startEventLoop();
    };

    //----------------------------------------------------------------------
    publicAPI.setRenderWindow = aren => {
      vtkErrorMacro$a('you want to call setView(view) instead of setRenderWindow on a vtk.js interactor');
    };

    //----------------------------------------------------------------------
    publicAPI.setInteractorStyle = style => {
      if (model.interactorStyle !== style) {
        if (model.interactorStyle != null) {
          model.interactorStyle.setInteractor(null);
        }
        model.interactorStyle = style;
        if (model.interactorStyle != null) {
          if (model.interactorStyle.getInteractor() !== publicAPI) {
            model.interactorStyle.setInteractor(publicAPI);
          }
        }
      }
    };

    //---------------------------------------------------------------------
    publicAPI.initialize = () => {
      model.initialized = true;
      publicAPI.enable();
      publicAPI.render();
    };
    publicAPI.enable = () => publicAPI.setEnabled(true);
    publicAPI.disable = () => publicAPI.setEnabled(false);
    publicAPI.startEventLoop = () => vtkWarningMacro('empty event loop');
    function updateCurrentRenderer(x, y) {
      if (!model._forcedRenderer) {
        model.currentRenderer = publicAPI.findPokedRenderer(x, y);
      }
    }
    publicAPI.getCurrentRenderer = () => {
      if (model.currentRenderer) {
        return model.currentRenderer;
      }
      updateCurrentRenderer(0, 0);
      return model.currentRenderer;
    };
    function _getScreenEventPositionFor(source) {
      const canvas = model._view.getCanvas();
      const bounds = canvas.getBoundingClientRect();
      const scaleX = canvas.width / bounds.width;
      const scaleY = canvas.height / bounds.height;
      const position = {
        x: scaleX * (source.clientX - bounds.left),
        y: scaleY * (bounds.height - source.clientY + bounds.top),
        z: 0
      };

      // if multitouch, do not update the current renderer
      if (pointerCache.size <= 1 || !model.currentRenderer) {
        updateCurrentRenderer(position.x, position.y);
      }
      return position;
    }
    // Allow user to override it
    const getScreenEventPositionFor = model._getScreenEventPositionFor || _getScreenEventPositionFor;
    function getModifierKeysFor(event) {
      return {
        controlKey: event.ctrlKey,
        altKey: event.altKey,
        shiftKey: event.shiftKey
      };
    }
    function getKeysFor(event) {
      const modifierKeys = getModifierKeysFor(event);
      const keys = {
        key: event.key,
        keyCode: event.charCode,
        ...modifierKeys
      };
      return keys;
    }
    function getDeviceTypeFor(event) {
      return event.pointerType || '';
    }
    const _bindEvents = () => {
      if (model.container === null) {
        return;
      }
      const {
        container
      } = model;
      container.addEventListener('contextmenu', preventDefault);
      container.addEventListener('wheel', publicAPI.handleWheel);
      container.addEventListener('DOMMouseScroll', publicAPI.handleWheel);
      container.addEventListener('pointerenter', publicAPI.handlePointerEnter);
      container.addEventListener('pointerleave', publicAPI.handlePointerLeave);
      container.addEventListener('pointermove', publicAPI.handlePointerMove, {
        passive: false
      });
      container.addEventListener('pointerdown', publicAPI.handlePointerDown, {
        passive: false
      });
      container.addEventListener('pointerup', publicAPI.handlePointerUp);
      container.addEventListener('pointercancel', publicAPI.handlePointerCancel);
      document.addEventListener('keypress', publicAPI.handleKeyPress);
      document.addEventListener('keydown', publicAPI.handleKeyDown);
      document.addEventListener('keyup', publicAPI.handleKeyUp);
      document.addEventListener('pointerlockchange', publicAPI.handlePointerLockChange);

      // using touchAction is more performant than preventDefault
      // in a touchstart handler.
      container.style.touchAction = 'none';
      container.style.userSelect = 'none';
      // disables tap highlight for when cursor is pointer
      container.style.webkitTapHighlightColor = 'rgba(0,0,0,0)';
    };

    // For backward compatibility.
    // Necessary for using unbind/bindEvent without calling setContainer.
    publicAPI.bindEvents = container => {
      if (container === null) {
        return;
      }
      const res = superClass.setContainer(container);
      if (res) {
        _bindEvents();
      }
    };
    const _unbindEvents = () => {
      // Clear any previous timeouts and state variables that control mouse / touchpad behavior.
      clearTimeout(model.moveTimeoutID);
      clearTimeout(model.wheelTimeoutID);
      model.moveTimeoutID = 0;
      model.wheelTimeoutID = 0;
      wheelCoefficient = 1.0;
      const {
        container
      } = model;
      if (container) {
        container.removeEventListener('contextmenu', preventDefault);
        container.removeEventListener('wheel', publicAPI.handleWheel);
        container.removeEventListener('DOMMouseScroll', publicAPI.handleWheel);
        container.removeEventListener('pointerenter', publicAPI.handlePointerEnter);
        container.removeEventListener('pointerleave', publicAPI.handlePointerLeave);
        container.removeEventListener('pointermove', publicAPI.handlePointerMove, {
          passive: false
        });
        container.removeEventListener('pointerdown', publicAPI.handlePointerDown, {
          passive: false
        });
        container.removeEventListener('pointerup', publicAPI.handlePointerUp);
        container.removeEventListener('pointercancel', publicAPI.handlePointerCancel);
      }
      document.removeEventListener('keypress', publicAPI.handleKeyPress);
      document.removeEventListener('keydown', publicAPI.handleKeyDown);
      document.removeEventListener('keyup', publicAPI.handleKeyUp);
      document.removeEventListener('pointerlockchange', publicAPI.handlePointerLockChange);
      pointerCache.clear();
    };
    publicAPI.unbindEvents = () => {
      _unbindEvents();
      superClass.setContainer(null);
    };
    publicAPI.handleKeyPress = event => {
      const data = getKeysFor(event);
      publicAPI.keyPressEvent(data);
    };
    publicAPI.handleKeyDown = event => {
      const data = getKeysFor(event);
      publicAPI.keyDownEvent(data);
    };
    publicAPI.handleKeyUp = event => {
      const data = getKeysFor(event);
      publicAPI.keyUpEvent(data);
    };
    publicAPI.handlePointerEnter = event => {
      const callData = {
        ...getModifierKeysFor(event),
        position: getScreenEventPositionFor(event),
        deviceType: getDeviceTypeFor(event)
      };
      publicAPI.pointerEnterEvent(callData);
      if (callData.deviceType === 'mouse') {
        publicAPI.mouseEnterEvent(callData);
      }
    };
    publicAPI.handlePointerLeave = event => {
      const callData = {
        ...getModifierKeysFor(event),
        position: getScreenEventPositionFor(event),
        deviceType: getDeviceTypeFor(event)
      };
      publicAPI.pointerLeaveEvent(callData);
      if (callData.deviceType === 'mouse') {
        publicAPI.mouseLeaveEvent(callData);
      }
    };
    publicAPI.handlePointerDown = event => {
      if (event.button > 2 || publicAPI.isPointerLocked()) {
        // ignore events from extra mouse buttons such as `back` and `forward`
        return;
      }
      if (model.preventDefaultOnPointerDown) {
        preventDefault(event);
      }
      if (event.target.hasPointerCapture(event.pointerId)) {
        event.target.releasePointerCapture(event.pointerId);
      }
      model.container.setPointerCapture(event.pointerId);
      if (pointerCache.has(event.pointerId)) {
        vtkWarningMacro('[RenderWindowInteractor] duplicate pointerId detected');
      }
      pointerCache.set(event.pointerId, {
        pointerId: event.pointerId,
        position: getScreenEventPositionFor(event)
      });
      switch (event.pointerType) {
        case 'pen':
        case 'touch':
          publicAPI.handleTouchStart(event);
          break;
        case 'mouse':
        default:
          publicAPI.handleMouseDown(event);
          break;
      }
    };
    publicAPI.handlePointerUp = event => {
      if (pointerCache.has(event.pointerId)) {
        if (model.preventDefaultOnPointerUp) {
          preventDefault(event);
        }
        pointerCache.delete(event.pointerId);
        model.container.releasePointerCapture(event.pointerId);
        switch (event.pointerType) {
          case 'pen':
          case 'touch':
            publicAPI.handleTouchEnd(event);
            break;
          case 'mouse':
          default:
            publicAPI.handleMouseUp(event);
            break;
        }
      }
    };
    publicAPI.handlePointerCancel = event => {
      if (pointerCache.has(event.pointerId)) {
        pointerCache.delete(event.pointerId);
        switch (event.pointerType) {
          case 'pen':
          case 'touch':
            publicAPI.handleTouchEnd(event);
            break;
          case 'mouse':
          default:
            publicAPI.handleMouseUp(event);
            break;
        }
      }
    };
    publicAPI.handlePointerMove = event => {
      if (pointerCache.has(event.pointerId)) {
        const pointer = pointerCache.get(event.pointerId);
        pointer.position = getScreenEventPositionFor(event);
      }
      switch (event.pointerType) {
        case 'pen':
        case 'touch':
          publicAPI.handleTouchMove(event);
          break;
        case 'mouse':
        default:
          publicAPI.handleMouseMove(event);
          break;
      }
    };
    publicAPI.handleMouseDown = event => {
      const callData = {
        ...getModifierKeysFor(event),
        position: getScreenEventPositionFor(event),
        deviceType: getDeviceTypeFor(event)
      };
      switch (event.button) {
        case 0:
          publicAPI.leftButtonPressEvent(callData);
          break;
        case 1:
          publicAPI.middleButtonPressEvent(callData);
          break;
        case 2:
          publicAPI.rightButtonPressEvent(callData);
          break;
        default:
          vtkErrorMacro$a(`Unknown mouse button pressed: ${event.button}`);
          break;
      }
    };

    //----------------------------------------------------------------------
    publicAPI.requestPointerLock = () => {
      if (model.container) {
        model.container.requestPointerLock();
      }
    };

    //----------------------------------------------------------------------
    publicAPI.exitPointerLock = () => document.exitPointerLock?.();

    //----------------------------------------------------------------------
    publicAPI.isPointerLocked = () => !!model.container && document.pointerLockElement === model.container;

    //----------------------------------------------------------------------
    publicAPI.handlePointerLockChange = () => {
      if (publicAPI.isPointerLocked()) {
        publicAPI.startPointerLockEvent();
      } else {
        publicAPI.endPointerLockEvent();
      }
    };

    //----------------------------------------------------------------------
    function forceRender() {
      if (model._view && model.enabled && model.enableRender) {
        model.inRender = true;
        model._view.traverseAllPasses();
        model.inRender = false;
      }
      // outside the above test so that third-party code can redirect
      // the render to the appropriate class
      publicAPI.invokeRenderEvent();
    }
    publicAPI.requestAnimation = requestor => {
      if (requestor === undefined) {
        vtkErrorMacro$a(`undefined requester, can not start animating`);
        return;
      }
      if (animationRequesters.has(requestor)) {
        vtkWarningMacro(`requester is already registered for animating`);
        return;
      }
      animationRequesters.add(requestor);
      if (!model.animationRequest && animationRequesters.size === 1 && !model.xrAnimation) {
        model._animationStartTime = Date.now();
        model._animationFrameCount = 0;
        model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
        publicAPI.startAnimationEvent();
      }
    };

    // continue animating for at least the specified duration of
    // milliseconds.
    publicAPI.extendAnimation = duration => {
      const newEnd = Date.now() + duration;
      model._animationExtendedEnd = Math.max(model._animationExtendedEnd, newEnd);
      if (!model.animationRequest && animationRequesters.size === 0 && !model.xrAnimation) {
        model._animationStartTime = Date.now();
        model._animationFrameCount = 0;
        model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
        publicAPI.startAnimationEvent();
      }
    };
    publicAPI.isAnimating = () => model.xrAnimation || model.animationRequest !== null;
    publicAPI.cancelAnimation = function (requestor) {
      let skipWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (!animationRequesters.has(requestor)) {
        if (!skipWarning) {
          const requestStr = requestor && requestor.getClassName ? requestor.getClassName() : requestor;
          vtkWarningMacro(`${requestStr} did not request an animation`);
        }
        return;
      }
      animationRequesters.delete(requestor);
      if (model.animationRequest && animationRequesters.size === 0 && Date.now() > model._animationExtendedEnd) {
        cancelAnimationFrame(model.animationRequest);
        model.animationRequest = null;
        publicAPI.endAnimationEvent();
        publicAPI.render();
      }
    };
    publicAPI.switchToXRAnimation = () => {
      // cancel existing animation if any
      if (model.animationRequest) {
        cancelAnimationFrame(model.animationRequest);
        model.animationRequest = null;
      }
      model.xrAnimation = true;
    };
    publicAPI.returnFromXRAnimation = () => {
      model.xrAnimation = false;
      if (animationRequesters.size !== 0) {
        model.recentAnimationFrameRate = 10.0;
        model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      }
    };
    publicAPI.updateXRGamepads = (xrSession, xrFrame, xrRefSpace) => {
      // watch for when buttons change state and fire events
      xrSession.inputSources.forEach(inputSource => {
        const gripPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.gripSpace, xrRefSpace);
        const gp = inputSource.gamepad;
        const hand = inputSource.handedness;
        if (gp) {
          if (!(gp.index in model.lastGamepadValues)) {
            model.lastGamepadValues[gp.index] = {
              left: {
                buttons: {}
              },
              right: {
                buttons: {}
              },
              none: {
                buttons: {}
              }
            };
          }
          for (let b = 0; b < gp.buttons.length; ++b) {
            if (!(b in model.lastGamepadValues[gp.index][hand].buttons)) {
              model.lastGamepadValues[gp.index][hand].buttons[b] = false;
            }
            if (model.lastGamepadValues[gp.index][hand].buttons[b] !== gp.buttons[b].pressed && gripPose != null) {
              publicAPI.button3DEvent({
                gamepad: gp,
                position: gripPose.transform.position,
                orientation: gripPose.transform.orientation,
                pressed: gp.buttons[b].pressed,
                device: inputSource.handedness === 'left' ? Device.LeftController : Device.RightController,
                input: deviceInputMap[gp.mapping] && deviceInputMap[gp.mapping][b] ? deviceInputMap[gp.mapping][b] : Input.Trigger
              });
              model.lastGamepadValues[gp.index][hand].buttons[b] = gp.buttons[b].pressed;
            }
            if (model.lastGamepadValues[gp.index][hand].buttons[b] && gripPose != null) {
              publicAPI.move3DEvent({
                gamepad: gp,
                position: gripPose.transform.position,
                orientation: gripPose.transform.orientation,
                device: inputSource.handedness === 'left' ? Device.LeftController : Device.RightController
              });
            }
          }
        }
      });
    };
    publicAPI.handleMouseMove = event => {
      const callData = {
        ...getModifierKeysFor(event),
        position: getScreenEventPositionFor(event),
        deviceType: getDeviceTypeFor(event)
      };
      if (model.moveTimeoutID === 0) {
        publicAPI.startMouseMoveEvent(callData);
      } else {
        publicAPI.mouseMoveEvent(callData);
        clearTimeout(model.moveTimeoutID);
      }

      // start a timer to keep us animating while we get mouse move events
      model.moveTimeoutID = setTimeout(() => {
        publicAPI.endMouseMoveEvent();
        model.moveTimeoutID = 0;
      }, 200);
    };
    publicAPI.handleAnimation = () => {
      const currTime = Date.now();
      model._animationFrameCount++;
      if (currTime - model._animationStartTime > 1000.0 && model._animationFrameCount > 1) {
        model.recentAnimationFrameRate = 1000.0 * (model._animationFrameCount - 1) / (currTime - model._animationStartTime);
        model.lastFrameTime = 1.0 / model.recentAnimationFrameRate;
        publicAPI.animationFrameRateUpdateEvent();
        model._animationStartTime = currTime;
        model._animationFrameCount = 1;
      }
      publicAPI.animationEvent();
      forceRender();
      if (animationRequesters.size > 0 || Date.now() < model._animationExtendedEnd) {
        model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      } else {
        cancelAnimationFrame(model.animationRequest);
        model.animationRequest = null;
        publicAPI.endAnimationEvent();
        publicAPI.render();
      }
    };
    publicAPI.handleWheel = event => {
      preventDefault(event);

      /**
       * wheel event values can vary significantly across browsers, platforms
       * and devices [1]. `normalizeWheel` uses facebook's solution from their
       * fixed-data-table repository [2].
       *
       * [1] https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel
       * [2] https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
       *
       * This code will return an object with properties:
       *
       *   spinX   -- normalized spin speed (use for zoom) - x plane
       *   spinY   -- " - y plane
       *   pixelX  -- normalized distance (to pixels) - x plane
       *   pixelY  -- " - y plane
       *
       */
      const callData = {
        ...normalizeWheel(event),
        ...getModifierKeysFor(event),
        position: getScreenEventPositionFor(event),
        deviceType: getDeviceTypeFor(event)
      };

      // Wheel events are thought to scroll pages (i.e. multiple lines at once).
      // See normalizeWheel() documentation for more context.
      // While trackpad wheel events are many small (<1) wheel spins,
      // mouse wheel events have absolute spin values higher than 1.
      // Here the first spin value is "recorded", and used to normalize
      // all the following mouse wheel events.
      if (model.wheelTimeoutID === 0) {
        // we attempt to distinguish between trackpads and mice
        // .3 will be larger than the first trackpad event,
        // but small enough to detect some common edge case mice
        if (Math.abs(callData.spinY) >= 0.3) {
          // Event is coming from mouse wheel
          wheelCoefficient = Math.abs(callData.spinY);
        } else {
          // Event is coming from trackpad
          wheelCoefficient = 1;
        }
      }
      callData.spinY /= wheelCoefficient;
      if (model.wheelTimeoutID === 0) {
        publicAPI.startMouseWheelEvent(callData);
        publicAPI.mouseWheelEvent(callData);
      } else {
        publicAPI.mouseWheelEvent(callData);
        clearTimeout(model.wheelTimeoutID);
      }
      if (model.mouseScrollDebounceByPass) {
        publicAPI.extendAnimation(600);
        publicAPI.endMouseWheelEvent();
        model.wheelTimeoutID = 0;
      } else {
        // start a timer to keep us animating while we get wheel events
        model.wheelTimeoutID = setTimeout(() => {
          publicAPI.extendAnimation(600);
          publicAPI.endMouseWheelEvent();
          model.wheelTimeoutID = 0;
        }, 200);
      }
    };
    publicAPI.handleMouseUp = event => {
      const callData = {
        ...getModifierKeysFor(event),
        position: getScreenEventPositionFor(event),
        deviceType: getDeviceTypeFor(event)
      };
      switch (event.button) {
        case 0:
          publicAPI.leftButtonReleaseEvent(callData);
          break;
        case 1:
          publicAPI.middleButtonReleaseEvent(callData);
          break;
        case 2:
          publicAPI.rightButtonReleaseEvent(callData);
          break;
        default:
          vtkErrorMacro$a(`Unknown mouse button released: ${event.button}`);
          break;
      }
    };
    publicAPI.handleTouchStart = event => {
      const pointers = [...pointerCache.values()];
      // If multitouch
      if (model.recognizeGestures && pointers.length > 1) {
        const positions = pointerCacheToPositions(pointerCache);
        // did we just transition to multitouch?
        if (pointers.length === 2) {
          const callData = {
            ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
            position: pointers[0].position,
            deviceType: getDeviceTypeFor(event)
          };
          publicAPI.leftButtonReleaseEvent(callData);
        }
        // handle the gesture
        publicAPI.recognizeGesture('TouchStart', positions);
      } else if (pointers.length === 1) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: getScreenEventPositionFor(event),
          deviceType: getDeviceTypeFor(event)
        };
        publicAPI.leftButtonPressEvent(callData);
      }
    };
    publicAPI.handleTouchMove = event => {
      const pointers = [...pointerCache.values()];
      if (model.recognizeGestures && pointers.length > 1) {
        const positions = pointerCacheToPositions(pointerCache);
        publicAPI.recognizeGesture('TouchMove', positions);
      } else if (pointers.length === 1) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event)
        };
        publicAPI.mouseMoveEvent(callData);
      }
    };
    publicAPI.handleTouchEnd = event => {
      const pointers = [...pointerCache.values()];
      if (model.recognizeGestures) {
        // No more fingers down
        if (pointers.length === 0) {
          const callData = {
            ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
            position: getScreenEventPositionFor(event),
            deviceType: getDeviceTypeFor(event)
          };
          publicAPI.leftButtonReleaseEvent(callData);
        } else if (pointers.length === 1) {
          // If one finger left, end touch and start button press
          const positions = pointerCacheToPositions(pointerCache);
          publicAPI.recognizeGesture('TouchEnd', positions);
          const callData = {
            ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
            position: pointers[0].position,
            deviceType: getDeviceTypeFor(event)
          };
          publicAPI.leftButtonPressEvent(callData);
        } else {
          // If more than one finger left, keep touch move
          const positions = pointerCacheToPositions(pointerCache);
          publicAPI.recognizeGesture('TouchMove', positions);
        }
      } else if (pointers.length === 1) {
        const callData = {
          ...getModifierKeysFor(EMPTY_MOUSE_EVENT),
          position: pointers[0].position,
          deviceType: getDeviceTypeFor(event)
        };
        publicAPI.leftButtonReleaseEvent(callData);
      }
    };
    publicAPI.setView = val => {
      if (model._view === val) {
        return;
      }
      model._view = val;
      model._view.getRenderable().setInteractor(publicAPI);
      publicAPI.modified();
    };
    publicAPI.getFirstRenderer = () => model._view?.getRenderable()?.getRenderersByReference()?.[0];
    publicAPI.findPokedRenderer = function () {
      let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (!model._view) {
        return null;
      }
      // The original order of renderers needs to remain as
      // the first one is the one we want to manipulate the camera on.
      const rc = model._view?.getRenderable()?.getRenderers();
      if (!rc || rc.length === 0) {
        return null;
      }
      rc.sort((a, b) => a.getLayer() - b.getLayer());
      let interactiveren = null;
      let viewportren = null;
      let currentRenderer = null;
      let count = rc.length;
      while (count--) {
        const aren = rc[count];
        if (model._view.isInViewport(x, y, aren) && aren.getInteractive()) {
          currentRenderer = aren;
          break;
        }
        if (interactiveren === null && aren.getInteractive()) {
          // Save this renderer in case we can't find one in the viewport that
          // is interactive.
          interactiveren = aren;
        }
        if (viewportren === null && model._view.isInViewport(x, y, aren)) {
          // Save this renderer in case we can't find one in the viewport that
          // is interactive.
          viewportren = aren;
        }
      }

      // We must have a value.  If we found an interactive renderer before, that's
      // better than a non-interactive renderer.
      if (currentRenderer === null) {
        currentRenderer = interactiveren;
      }

      // We must have a value.  If we found a renderer that is in the viewport,
      // that is better than any old viewport (but not as good as an interactive
      // one).
      if (currentRenderer === null) {
        currentRenderer = viewportren;
      }

      // We must have a value - take anything.
      if (currentRenderer == null) {
        currentRenderer = rc[0];
      }
      return currentRenderer;
    };

    // only render if we are not animating. If we are animating
    // then renders will happen naturally anyhow and we definitely
    // do not want extra renders as the make the apparent interaction
    // rate slower.
    publicAPI.render = () => {
      if (!publicAPI.isAnimating() && !model.inRender) {
        forceRender();
      }
    };

    // create the generic Event methods
    handledEvents.forEach(eventName => {
      const lowerFirst = eventName.charAt(0).toLowerCase() + eventName.slice(1);
      publicAPI[`${lowerFirst}Event`] = arg => {
        // Check that interactor enabled
        if (!model.enabled) {
          return;
        }

        // Check that a poked renderer exists
        const renderer = publicAPI.getCurrentRenderer();
        if (!renderer) {
          vtkOnceErrorMacro(`
          Can not forward events without a current renderer on the interactor.
        `);
          return;
        }

        // Pass the eventName and the poked renderer
        const callData = {
          type: eventName,
          pokedRenderer: model.currentRenderer,
          firstRenderer: publicAPI.getFirstRenderer(),
          // Add the arguments to the call data
          ...arg
        };

        // Call invoke
        publicAPI[`invoke${eventName}`](callData);
      };
    });

    // we know we are in multitouch now, so start recognizing
    publicAPI.recognizeGesture = (event, positions) => {
      // more than two pointers we ignore
      if (Object.keys(positions).length > 2) {
        return;
      }
      if (!model.startingEventPositions) {
        model.startingEventPositions = {};
      }

      // store the initial positions
      if (event === 'TouchStart') {
        Object.keys(positions).forEach(key => {
          model.startingEventPositions[key] = positions[key];
        });
        // we do not know what the gesture is yet
        model.currentGesture = 'Start';
        return;
      }

      // end the gesture if needed
      if (event === 'TouchEnd') {
        if (model.currentGesture === 'Pinch') {
          publicAPI.render();
          publicAPI.endPinchEvent();
        }
        if (model.currentGesture === 'Rotate') {
          publicAPI.render();
          publicAPI.endRotateEvent();
        }
        if (model.currentGesture === 'Pan') {
          publicAPI.render();
          publicAPI.endPanEvent();
        }
        model.currentGesture = 'Start';
        model.startingEventPositions = {};
        return;
      }

      // what are the two pointers we are working with
      let count = 0;
      const posVals = [];
      const startVals = [];
      Object.keys(positions).forEach(key => {
        posVals[count] = positions[key];
        startVals[count] = model.startingEventPositions[key];
        count++;
      });

      // The meat of the algorithm
      // on move events we analyze them to determine what type
      // of movement it is and then deal with it.
      // calculate the distances
      const originalDistance = Math.sqrt((startVals[0].x - startVals[1].x) * (startVals[0].x - startVals[1].x) + (startVals[0].y - startVals[1].y) * (startVals[0].y - startVals[1].y));
      const newDistance = Math.sqrt((posVals[0].x - posVals[1].x) * (posVals[0].x - posVals[1].x) + (posVals[0].y - posVals[1].y) * (posVals[0].y - posVals[1].y));

      // calculate rotations
      let originalAngle = degreesFromRadians(Math.atan2(startVals[1].y - startVals[0].y, startVals[1].x - startVals[0].x));
      let newAngle = degreesFromRadians(Math.atan2(posVals[1].y - posVals[0].y, posVals[1].x - posVals[0].x));

      // angles are cyclic so watch for that, 1 and 359 are only 2 apart :)
      let angleDeviation = newAngle - originalAngle;
      newAngle = newAngle + 180.0 >= 360.0 ? newAngle - 180.0 : newAngle + 180.0;
      originalAngle = originalAngle + 180.0 >= 360.0 ? originalAngle - 180.0 : originalAngle + 180.0;
      if (Math.abs(newAngle - originalAngle) < Math.abs(angleDeviation)) {
        angleDeviation = newAngle - originalAngle;
      }

      // calculate the translations
      const trans = [];
      trans[0] = (posVals[0].x - startVals[0].x + posVals[1].x - startVals[1].x) / 2.0;
      trans[1] = (posVals[0].y - startVals[0].y + posVals[1].y - startVals[1].y) / 2.0;
      if (event === 'TouchMove') {
        // OK we want to
        // - immediately respond to the user
        // - allow the user to zoom without panning (saves focal point)
        // - allow the user to rotate without panning (saves focal point)

        // do we know what gesture we are doing yet? If not
        // see if we can figure it out
        if (model.currentGesture === 'Start') {
          // pinch is a move to/from the center point
          // rotate is a move along the circumference
          // pan is a move of the center point
          // compute the distance along each of these axes in pixels
          // the first to break thresh wins
          let thresh = 0.01 * Math.sqrt(model.container.clientWidth * model.container.clientWidth + model.container.clientHeight * model.container.clientHeight);
          if (thresh < 15.0) {
            thresh = 15.0;
          }
          const pinchDistance = Math.abs(newDistance - originalDistance);
          const rotateDistance = newDistance * 3.1415926 * Math.abs(angleDeviation) / 360.0;
          const panDistance = Math.sqrt(trans[0] * trans[0] + trans[1] * trans[1]);
          if (pinchDistance > thresh && pinchDistance > rotateDistance && pinchDistance > panDistance) {
            model.currentGesture = 'Pinch';
            const callData = {
              scale: 1.0,
              touches: positions
            };
            publicAPI.startPinchEvent(callData);
          } else if (rotateDistance > thresh && rotateDistance > panDistance) {
            model.currentGesture = 'Rotate';
            const callData = {
              rotation: 0.0,
              touches: positions
            };
            publicAPI.startRotateEvent(callData);
          } else if (panDistance > thresh) {
            model.currentGesture = 'Pan';
            const callData = {
              translation: [0, 0],
              touches: positions
            };
            publicAPI.startPanEvent(callData);
          }
        } else {
          // if we have found a specific type of movement then
          // handle it
          if (model.currentGesture === 'Rotate') {
            const callData = {
              rotation: angleDeviation,
              touches: positions
            };
            publicAPI.rotateEvent(callData);
          }
          if (model.currentGesture === 'Pinch') {
            const callData = {
              scale: newDistance / originalDistance,
              touches: positions
            };
            publicAPI.pinchEvent(callData);
          }
          if (model.currentGesture === 'Pan') {
            const callData = {
              translation: trans,
              touches: positions
            };
            publicAPI.panEvent(callData);
          }
        }
      }
    };
    publicAPI.handleVisibilityChange = () => {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
    };
    publicAPI.setCurrentRenderer = r => {
      model._forcedRenderer = !!r;
      model.currentRenderer = r;
    };
    publicAPI.setContainer = container => {
      _unbindEvents();
      const res = superClass.setContainer(container ?? null);
      if (res) {
        _bindEvents();
      }
      return res;
    };

    // Stop animating if the renderWindowInteractor is deleted.
    publicAPI.delete = () => {
      while (animationRequesters.size) {
        publicAPI.cancelAnimation(animationRequesters.values().next().value);
      }
      if (typeof document.hidden !== 'undefined') {
        document.removeEventListener('visibilitychange', publicAPI.handleVisibilityChange);
      }
      if (model.container) {
        publicAPI.setContainer(null);
      }
      superClass.delete();
    };

    // Use the Page Visibility API to detect when we switch away from or back to
    // this tab, and reset the animationFrameStart. When tabs are not active, browsers
    // will stop calling requestAnimationFrame callbacks.
    if (typeof document.hidden !== 'undefined') {
      document.addEventListener('visibilitychange', publicAPI.handleVisibilityChange, false);
    }
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$r = {
    renderWindow: null,
    interactorStyle: null,
    picker: null,
    pickingManager: null,
    initialized: false,
    enabled: false,
    enableRender: true,
    currentRenderer: null,
    lightFollowCamera: true,
    desiredUpdateRate: 30.0,
    stillUpdateRate: 2.0,
    container: null,
    // _view: null,
    recognizeGestures: true,
    currentGesture: 'Start',
    animationRequest: null,
    lastFrameTime: 0.1,
    recentAnimationFrameRate: 10.0,
    wheelTimeoutID: 0,
    moveTimeoutID: 0,
    lastGamepadValues: {},
    preventDefaultOnPointerDown: false,
    preventDefaultOnPointerUp: false,
    mouseScrollDebounceByPass: false
  };

  // ----------------------------------------------------------------------------

  function extend$r(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$r, initialValues);

    // Object methods
    macro.obj(publicAPI, model);

    // run animation at least until this time
    model._animationExtendedEnd = 0;
    macro.event(publicAPI, model, 'RenderEvent');
    handledEvents.forEach(eventName => macro.event(publicAPI, model, eventName));

    // Create get-only macros
    macro.get(publicAPI, model, ['initialized', 'interactorStyle', 'lastFrameTime', 'recentAnimationFrameRate', '_view']);

    // Create get-set macros
    macro.setGet(publicAPI, model, ['container', 'lightFollowCamera', 'enabled', 'enableRender', 'recognizeGestures', 'desiredUpdateRate', 'stillUpdateRate', 'picker', 'preventDefaultOnPointerDown', 'preventDefaultOnPointerUp', 'mouseScrollDebounceByPass']);
    macro.moveToProtected(publicAPI, model, ['view']);

    // For more macro methods, see "Sources/macros.js"

    // Object specific methods
    vtkRenderWindowInteractor(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$r = macro.newInstance(extend$r, 'vtkRenderWindowInteractor');

  // ----------------------------------------------------------------------------

  var vtkRenderWindowInteractor$1 = {
    newInstance: newInstance$r,
    extend: extend$r,
    handledEvents,
    ...Constants$1
  };

  const {
    vtkErrorMacro: vtkErrorMacro$9,
    VOID
  } = macro;

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  //----------------------------------------------------------------------------
  // Description:
  // Transform from world to display coordinates.
  function computeWorldToDisplay(renderer, x, y, z) {
    const view = renderer.getRenderWindow().getViews()[0];
    return view.worldToDisplay(x, y, z, renderer);
  }

  //----------------------------------------------------------------------------
  // Description:
  // Transform from display to world coordinates.
  function computeDisplayToWorld(renderer, x, y, z) {
    const view = renderer.getRenderWindow().getViews()[0];
    return view.displayToWorld(x, y, z, renderer);
  }

  // ----------------------------------------------------------------------------
  // Static API
  // ----------------------------------------------------------------------------
  const STATIC = {
    computeWorldToDisplay,
    computeDisplayToWorld
  };

  // ----------------------------------------------------------------------------
  // vtkInteractorObserver methods
  // ----------------------------------------------------------------------------

  function vtkInteractorObserver(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkInteractorObserver');
    const superClass = {
      ...publicAPI
    };

    //----------------------------------------------------------------------------
    function unsubscribeFromEvents() {
      while (model.subscribedEvents.length) {
        model.subscribedEvents.pop().unsubscribe();
      }
    }

    //----------------------------------------------------------------------------
    // Check what events we can handle and register callbacks
    function subscribeToEvents() {
      vtkRenderWindowInteractor$1.handledEvents.forEach(eventName => {
        if (publicAPI[`handle${eventName}`]) {
          model.subscribedEvents.push(model._interactor[`on${eventName}`](callData => {
            if (model.processEvents) {
              return publicAPI[`handle${eventName}`](callData);
            }
            return VOID;
          }, model.priority));
        }
      });
    }

    //----------------------------------------------------------------------------
    // Public API methods
    //----------------------------------------------------------------------------
    publicAPI.setInteractor = i => {
      if (i === model._interactor) {
        return;
      }
      unsubscribeFromEvents();
      model._interactor = i;
      if (i && model.enabled) {
        subscribeToEvents();
      }
      publicAPI.modified();
    };

    //----------------------------------------------------------------------------
    publicAPI.setEnabled = enable => {
      if (enable === model.enabled) {
        return;
      }
      unsubscribeFromEvents();
      if (enable) {
        if (model._interactor) {
          subscribeToEvents();
        } else {
          vtkErrorMacro$9(`
          The interactor must be set before subscribing to events
        `);
        }
      }
      model.enabled = enable;
      publicAPI.modified();
    };

    //----------------------------------------------------------------------------
    // Description:
    // Transform from display to world coordinates.
    publicAPI.computeDisplayToWorld = (renderer, x, y, z) => {
      if (!renderer) {
        return null;
      }
      return model._interactor.getView().displayToWorld(x, y, z, renderer);
    };

    //----------------------------------------------------------------------------
    // Description:
    // Transform from world to display coordinates.
    publicAPI.computeWorldToDisplay = (renderer, x, y, z) => {
      if (!renderer) {
        return null;
      }
      return model._interactor.getView().worldToDisplay(x, y, z, renderer);
    };

    //----------------------------------------------------------------------------

    publicAPI.setPriority = priority => {
      const modified = superClass.setPriority(priority);
      if (modified && model._interactor) {
        unsubscribeFromEvents();
        subscribeToEvents();
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$q = {
    enabled: true,
    // _interactor: null,
    priority: 0.0,
    processEvents: true,
    subscribedEvents: []
  };

  // ----------------------------------------------------------------------------

  function extend$q(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$q, initialValues);

    // Object methods
    macro.obj(publicAPI, model);
    macro.event(publicAPI, model, 'InteractionEvent');
    macro.event(publicAPI, model, 'StartInteractionEvent');
    macro.event(publicAPI, model, 'EndInteractionEvent');

    // Create get-only macros
    macro.get(publicAPI, model, ['_interactor', 'enabled']);

    // Create get-set macros
    macro.setGet(publicAPI, model, ['priority', 'processEvents']);
    macro.moveToProtected(publicAPI, model, ['interactor']);

    // For more macro methods, see "Sources/macros.js"

    // Object specific methods
    vtkInteractorObserver(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$q = macro.newInstance(extend$q, 'vtkInteractorObserver');

  // ----------------------------------------------------------------------------

  var vtkInteractorObserver$1 = {
    newInstance: newInstance$q,
    extend: extend$q,
    ...STATIC
  };

  const States$2 = {
    IS_START: 0,
    IS_NONE: 0,
    IS_ROTATE: 1,
    IS_PAN: 2,
    IS_SPIN: 3,
    IS_DOLLY: 4,
    IS_CAMERA_POSE: 11,
    IS_WINDOW_LEVEL: 1024,
    IS_SLICE: 1025
  };
  var vtkInteractorStyleConstants = {
    States: States$2
  };

  const {
    States: States$1
  } = vtkInteractorStyleConstants;

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  // Add module-level functions or api that you want to expose statically via
  // the next section...

  const stateNames = {
    Rotate: States$1.IS_ROTATE,
    Pan: States$1.IS_PAN,
    Spin: States$1.IS_SPIN,
    Dolly: States$1.IS_DOLLY,
    CameraPose: States$1.IS_CAMERA_POSE,
    WindowLevel: States$1.IS_WINDOW_LEVEL,
    Slice: States$1.IS_SLICE
  };

  // ----------------------------------------------------------------------------
  // vtkInteractorStyle methods
  // ----------------------------------------------------------------------------

  function vtkInteractorStyle(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkInteractorStyle');

    // Public API methods
    // create bunch of Start/EndState methods
    Object.keys(stateNames).forEach(key => {
      macro.event(publicAPI, model, `Start${key}Event`);
      publicAPI[`start${key}`] = () => {
        if (model.state !== States$1.IS_NONE) {
          return;
        }
        model.state = stateNames[key];
        model._interactor.requestAnimation(publicAPI);
        publicAPI.invokeStartInteractionEvent({
          type: 'StartInteractionEvent'
        });
        publicAPI[`invokeStart${key}Event`]({
          type: `Start${key}Event`
        });
      };
      macro.event(publicAPI, model, `End${key}Event`);
      publicAPI[`end${key}`] = () => {
        if (model.state !== stateNames[key]) {
          return;
        }
        model.state = States$1.IS_NONE;
        model._interactor.cancelAnimation(publicAPI);
        publicAPI.invokeEndInteractionEvent({
          type: 'EndInteractionEvent'
        });
        publicAPI[`invokeEnd${key}Event`]({
          type: `End${key}Event`
        });
        model._interactor.render();
      };
    });

    //----------------------------------------------------------------------------
    publicAPI.handleKeyPress = callData => {
      const rwi = model._interactor;
      let ac = null;
      switch (callData.key) {
        case 'r':
        case 'R':
          callData.pokedRenderer.resetCamera();
          rwi.render();
          break;
        case 'w':
        case 'W':
          ac = callData.pokedRenderer.getActors();
          ac.forEach(anActor => {
            const prop = anActor.getProperty();
            if (prop.setRepresentationToWireframe) {
              prop.setRepresentationToWireframe();
            }
          });
          rwi.render();
          break;
        case 's':
        case 'S':
          ac = callData.pokedRenderer.getActors();
          ac.forEach(anActor => {
            const prop = anActor.getProperty();
            if (prop.setRepresentationToSurface) {
              prop.setRepresentationToSurface();
            }
          });
          rwi.render();
          break;
        case 'v':
        case 'V':
          ac = callData.pokedRenderer.getActors();
          ac.forEach(anActor => {
            const prop = anActor.getProperty();
            if (prop.setRepresentationToPoints) {
              prop.setRepresentationToPoints();
            }
          });
          rwi.render();
          break;
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$p = {
    state: States$1.IS_NONE,
    handleObservers: 1,
    autoAdjustCameraClippingRange: 1
  };

  // ----------------------------------------------------------------------------

  function extend$p(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$p, initialValues);

    // Inheritance
    vtkInteractorObserver$1.extend(publicAPI, model, initialValues);

    // Object specific methods
    vtkInteractorStyle(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$p = macro.newInstance(extend$p, 'vtkInteractorStyle');

  // ----------------------------------------------------------------------------

  var vtkInteractorStyle$1 = {
    newInstance: newInstance$p,
    extend: extend$p,
    ...vtkInteractorStyleConstants
  };

  const {
    States
  } = vtkInteractorStyleConstants;

  /* eslint-disable no-lonely-if */

  // ----------------------------------------------------------------------------
  // vtkInteractorStyleTrackballCamera methods
  // ----------------------------------------------------------------------------

  function vtkInteractorStyleTrackballCamera(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkInteractorStyleTrackballCamera');

    // Public API methods
    publicAPI.handleMouseMove = callData => {
      const pos = callData.position;
      const renderer = callData.pokedRenderer;
      switch (model.state) {
        case States.IS_ROTATE:
          publicAPI.handleMouseRotate(renderer, pos);
          publicAPI.invokeInteractionEvent({
            type: 'InteractionEvent'
          });
          break;
        case States.IS_PAN:
          publicAPI.handleMousePan(renderer, pos);
          publicAPI.invokeInteractionEvent({
            type: 'InteractionEvent'
          });
          break;
        case States.IS_DOLLY:
          publicAPI.handleMouseDolly(renderer, pos);
          publicAPI.invokeInteractionEvent({
            type: 'InteractionEvent'
          });
          break;
        case States.IS_SPIN:
          publicAPI.handleMouseSpin(renderer, pos);
          publicAPI.invokeInteractionEvent({
            type: 'InteractionEvent'
          });
          break;
      }
      model.previousPosition = pos;
    };

    //----------------------------------------------------------------------------
    publicAPI.handleButton3D = ed => {
      if (ed && ed.pressed && ed.device === Device$1.RightController && (ed.input === Input$1.Trigger || ed.input === Input$1.TrackPad)) {
        publicAPI.startCameraPose();
        return;
      }
      if (ed && !ed.pressed && ed.device === Device$1.RightController && (ed.input === Input$1.Trigger || ed.input === Input$1.TrackPad) && model.state === States.IS_CAMERA_POSE) {
        publicAPI.endCameraPose();
        // return;
      }
    };

    publicAPI.handleMove3D = ed => {
      switch (model.state) {
        case States.IS_CAMERA_POSE:
          publicAPI.updateCameraPose(ed);
          break;
      }
    };
    publicAPI.updateCameraPose = ed => {
      // move the world in the direction of the
      // controller
      const camera = ed.pokedRenderer.getActiveCamera();
      const oldTrans = camera.getPhysicalTranslation();

      // look at the y axis to determine how fast / what direction to move
      const speed = 0.5; // ed.gamepad.axes[1];

      // 0.05 meters / frame movement
      const pscale = speed * 0.05 * camera.getPhysicalScale();

      // convert orientation to world coordinate direction
      const dir = camera.physicalOrientationToWorldDirection([ed.orientation.x, ed.orientation.y, ed.orientation.z, ed.orientation.w]);
      camera.setPhysicalTranslation(oldTrans[0] + dir[0] * pscale, oldTrans[1] + dir[1] * pscale, oldTrans[2] + dir[2] * pscale);
    };

    //----------------------------------------------------------------------------
    publicAPI.handleLeftButtonPress = callData => {
      const pos = callData.position;
      model.previousPosition = pos;
      if (callData.shiftKey) {
        if (callData.controlKey || callData.altKey) {
          publicAPI.startDolly();
        } else {
          publicAPI.startPan();
        }
      } else {
        if (callData.controlKey || callData.altKey) {
          publicAPI.startSpin();
        } else {
          publicAPI.startRotate();
        }
      }
    };

    //--------------------------------------------------------------------------
    publicAPI.handleLeftButtonRelease = () => {
      switch (model.state) {
        case States.IS_DOLLY:
          publicAPI.endDolly();
          break;
        case States.IS_PAN:
          publicAPI.endPan();
          break;
        case States.IS_SPIN:
          publicAPI.endSpin();
          break;
        case States.IS_ROTATE:
          publicAPI.endRotate();
          break;
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.handleStartMouseWheel = () => {
      publicAPI.startDolly();
    };

    //--------------------------------------------------------------------------
    publicAPI.handleEndMouseWheel = () => {
      publicAPI.endDolly();
    };

    //----------------------------------------------------------------------------
    publicAPI.handleStartPinch = callData => {
      model.previousScale = callData.scale;
      publicAPI.startDolly();
    };

    //--------------------------------------------------------------------------
    publicAPI.handleEndPinch = () => {
      publicAPI.endDolly();
    };

    //----------------------------------------------------------------------------
    publicAPI.handleStartRotate = callData => {
      model.previousRotation = callData.rotation;
      publicAPI.startRotate();
    };

    //--------------------------------------------------------------------------
    publicAPI.handleEndRotate = () => {
      publicAPI.endRotate();
    };

    //----------------------------------------------------------------------------
    publicAPI.handleStartPan = callData => {
      model.previousTranslation = callData.translation;
      publicAPI.startPan();
    };

    //--------------------------------------------------------------------------
    publicAPI.handleEndPan = () => {
      publicAPI.endPan();
    };

    //----------------------------------------------------------------------------
    publicAPI.handlePinch = callData => {
      publicAPI.dollyByFactor(callData.pokedRenderer, callData.scale / model.previousScale);
      model.previousScale = callData.scale;
    };

    //----------------------------------------------------------------------------
    publicAPI.handlePan = callData => {
      const camera = callData.pokedRenderer.getActiveCamera();

      // Calculate the focal depth since we'll be using it a lot
      let viewFocus = camera.getFocalPoint();
      viewFocus = publicAPI.computeWorldToDisplay(callData.pokedRenderer, viewFocus[0], viewFocus[1], viewFocus[2]);
      const focalDepth = viewFocus[2];
      const trans = callData.translation;
      const lastTrans = model.previousTranslation;
      const newPickPoint = publicAPI.computeDisplayToWorld(callData.pokedRenderer, viewFocus[0] + trans[0] - lastTrans[0], viewFocus[1] + trans[1] - lastTrans[1], focalDepth);

      // Has to recalc old mouse point since the viewport has moved,
      // so can't move it outside the loop
      const oldPickPoint = publicAPI.computeDisplayToWorld(callData.pokedRenderer, viewFocus[0], viewFocus[1], focalDepth);

      // Camera motion is reversed
      const motionVector = [];
      motionVector[0] = oldPickPoint[0] - newPickPoint[0];
      motionVector[1] = oldPickPoint[1] - newPickPoint[1];
      motionVector[2] = oldPickPoint[2] - newPickPoint[2];
      viewFocus = camera.getFocalPoint();
      const viewPoint = camera.getPosition();
      camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
      camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
      if (model._interactor.getLightFollowCamera()) {
        callData.pokedRenderer.updateLightsGeometryToFollowCamera();
      }
      camera.orthogonalizeViewUp();
      model.previousTranslation = callData.translation;
    };

    //----------------------------------------------------------------------------
    publicAPI.handleRotate = callData => {
      const camera = callData.pokedRenderer.getActiveCamera();
      camera.roll(callData.rotation - model.previousRotation);
      camera.orthogonalizeViewUp();
      model.previousRotation = callData.rotation;
    };

    //--------------------------------------------------------------------------
    publicAPI.handleMouseRotate = (renderer, position) => {
      if (!model.previousPosition) {
        return;
      }
      const rwi = model._interactor;
      const dx = position.x - model.previousPosition.x;
      const dy = position.y - model.previousPosition.y;
      const size = rwi.getView().getViewportSize(renderer);
      let deltaElevation = -0.1;
      let deltaAzimuth = -0.1;
      if (size[0] && size[1]) {
        deltaElevation = -20.0 / size[1];
        deltaAzimuth = -20.0 / size[0];
      }
      const rxf = dx * deltaAzimuth * model.motionFactor;
      const ryf = dy * deltaElevation * model.motionFactor;
      const camera = renderer.getActiveCamera();
      if (!Number.isNaN(rxf) && !Number.isNaN(ryf)) {
        camera.azimuth(rxf);
        camera.elevation(ryf);
        camera.orthogonalizeViewUp();
      }
      if (model.autoAdjustCameraClippingRange) {
        renderer.resetCameraClippingRange();
      }
      if (rwi.getLightFollowCamera()) {
        renderer.updateLightsGeometryToFollowCamera();
      }
    };

    //--------------------------------------------------------------------------
    publicAPI.handleMouseSpin = (renderer, position) => {
      if (!model.previousPosition) {
        return;
      }
      const rwi = model._interactor;
      const camera = renderer.getActiveCamera();
      const center = rwi.getView().getViewportCenter(renderer);
      const oldAngle = degreesFromRadians(Math.atan2(model.previousPosition.y - center[1], model.previousPosition.x - center[0]));
      const newAngle = degreesFromRadians(Math.atan2(position.y - center[1], position.x - center[0])) - oldAngle;
      if (!Number.isNaN(newAngle)) {
        camera.roll(newAngle);
        camera.orthogonalizeViewUp();
      }
    };

    //--------------------------------------------------------------------------
    publicAPI.handleMousePan = (renderer, position) => {
      if (!model.previousPosition) {
        return;
      }
      const camera = renderer.getActiveCamera();

      // Calculate the focal depth since we'll be using it a lot
      let viewFocus = camera.getFocalPoint();
      viewFocus = publicAPI.computeWorldToDisplay(renderer, viewFocus[0], viewFocus[1], viewFocus[2]);
      const focalDepth = viewFocus[2];
      const newPickPoint = publicAPI.computeDisplayToWorld(renderer, position.x, position.y, focalDepth);

      // Has to recalc old mouse point since the viewport has moved,
      // so can't move it outside the loop
      const oldPickPoint = publicAPI.computeDisplayToWorld(renderer, model.previousPosition.x, model.previousPosition.y, focalDepth);

      // Camera motion is reversed
      const motionVector = [];
      motionVector[0] = oldPickPoint[0] - newPickPoint[0];
      motionVector[1] = oldPickPoint[1] - newPickPoint[1];
      motionVector[2] = oldPickPoint[2] - newPickPoint[2];
      viewFocus = camera.getFocalPoint();
      const viewPoint = camera.getPosition();
      camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
      camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
      if (model._interactor.getLightFollowCamera()) {
        renderer.updateLightsGeometryToFollowCamera();
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.handleMouseDolly = (renderer, position) => {
      if (!model.previousPosition) {
        return;
      }
      const dy = position.y - model.previousPosition.y;
      const rwi = model._interactor;
      const center = rwi.getView().getViewportCenter(renderer);
      const dyf = model.motionFactor * dy / center[1];
      publicAPI.dollyByFactor(renderer, 1.1 ** dyf);
    };

    //----------------------------------------------------------------------------
    publicAPI.handleMouseWheel = callData => {
      const dyf = 1 - callData.spinY / model.zoomFactor;
      publicAPI.dollyByFactor(callData.pokedRenderer, dyf);
    };

    //----------------------------------------------------------------------------
    publicAPI.dollyByFactor = (renderer, factor) => {
      if (Number.isNaN(factor)) {
        return;
      }
      const camera = renderer.getActiveCamera();
      if (camera.getParallelProjection()) {
        camera.setParallelScale(camera.getParallelScale() / factor);
      } else {
        camera.dolly(factor);
        if (model.autoAdjustCameraClippingRange) {
          renderer.resetCameraClippingRange();
        }
      }
      if (model._interactor.getLightFollowCamera()) {
        renderer.updateLightsGeometryToFollowCamera();
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$o = {
    motionFactor: 10.0,
    zoomFactor: 10.0
  };

  // ----------------------------------------------------------------------------

  function extend$o(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$o, initialValues);

    // Inheritance
    vtkInteractorStyle$1.extend(publicAPI, model, initialValues);

    // Create get-set macros
    macro.setGet(publicAPI, model, ['motionFactor', 'zoomFactor']);

    // For more macro methods, see "Sources/macros.js"

    // Object specific methods
    vtkInteractorStyleTrackballCamera(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$o = macro.newInstance(extend$o, 'vtkInteractorStyleTrackballCamera');

  // ----------------------------------------------------------------------------

  var vtkInteractorStyleTrackballCamera$1 = {
    newInstance: newInstance$o,
    extend: extend$o
  };

  function identity(i) {
    return i;
  }
  function toNativeType(str) {
    if (str === null || str === 'null') {
      return null;
    }
    if (str === 'true') {
      return true;
    }
    if (str === 'false') {
      return false;
    }
    if (str === undefined || str === 'undefined') {
      return undefined;
    }
    if (str[0] === '[' && str[str.length - 1] === ']') {
      return str.substring(1, str.length - 1).split(',').map(s => toNativeType(s.trim()));
    }
    if (str === '' || Number.isNaN(Number(str))) {
      return str;
    }
    return Number(str);
  }
  function extractURLParameters() {
    let castToNativeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    let query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location.search;
    const summary = {};
    const convert = castToNativeType ? toNativeType : identity;
    const queryTokens = (query || '').replace(/#.*/, '') // remove hash query
    .replace('?', '') // Remove ? from the head
    .split('&'); // extract token pair

    queryTokens.forEach(token => {
      const [key, value] = token.split('=').map(s => decodeURIComponent(s));
      if (key) {
        summary[key] = value ? convert(value) : true;
      }
    });
    return summary;
  }
  var vtkURLExtract = {
    toNativeType,
    extractURLParameters
  };

  // ----------------------------------------------------------------------------
  // vtkFramebuffer methods
  // ----------------------------------------------------------------------------
  function vtkFramebuffer(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkFramebuffer');
    publicAPI.getBothMode = () => model.context.FRAMEBUFFER;
    // publicAPI.getDrawMode = () => model.context.DRAW_FRAMEBUFFER;
    // publicAPI.getReadMode = () => model.context.READ_FRAMEBUFFER;

    publicAPI.saveCurrentBindingsAndBuffers = modeIn => {
      const mode = typeof modeIn !== 'undefined' ? modeIn : publicAPI.getBothMode();
      publicAPI.saveCurrentBindings(mode);
      publicAPI.saveCurrentBuffers(mode);
    };
    publicAPI.saveCurrentBindings = modeIn => {
      if (!model.context) {
        vtkErrorMacro$v('you must set the OpenGLRenderWindow before calling saveCurrentBindings');
        return;
      }
      const gl = model.context;
      model.previousDrawBinding = gl.getParameter(model.context.FRAMEBUFFER_BINDING);
      model.previousActiveFramebuffer = model._openGLRenderWindow.getActiveFramebuffer();
    };
    publicAPI.saveCurrentBuffers = modeIn => {
      // noop on webgl 1
    };
    publicAPI.restorePreviousBindingsAndBuffers = modeIn => {
      const mode = typeof modeIn !== 'undefined' ? modeIn : publicAPI.getBothMode();
      publicAPI.restorePreviousBindings(mode);
      publicAPI.restorePreviousBuffers(mode);
    };
    publicAPI.restorePreviousBindings = modeIn => {
      if (!model.context) {
        vtkErrorMacro$v('you must set the OpenGLRenderWindow before calling restorePreviousBindings');
        return;
      }
      const gl = model.context;
      gl.bindFramebuffer(gl.FRAMEBUFFER, model.previousDrawBinding);
      model._openGLRenderWindow.setActiveFramebuffer(model.previousActiveFramebuffer);
    };
    publicAPI.restorePreviousBuffers = modeIn => {
      // currently a noop on webgl1
    };
    publicAPI.bind = function () {
      let modeArg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      let mode = modeArg;
      if (mode === null) {
        mode = model.context.FRAMEBUFFER;
      }
      model.context.bindFramebuffer(mode, model.glFramebuffer);
      for (let i = 0; i < model.colorBuffers.length; i++) {
        model.colorBuffers[i].bind();
      }
      model._openGLRenderWindow.setActiveFramebuffer(publicAPI);
    };
    publicAPI.create = (width, height) => {
      if (!model.context) {
        vtkErrorMacro$v('you must set the OpenGLRenderWindow before calling create');
        return;
      }
      model.glFramebuffer = model.context.createFramebuffer();
      model.glFramebuffer.width = width;
      model.glFramebuffer.height = height;
    };
    publicAPI.setColorBuffer = function (texture) {
      let attachment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      const gl = model.context;
      if (!gl) {
        vtkErrorMacro$v('you must set the OpenGLRenderWindow before calling setColorBuffer');
        return;
      }
      let glAttachment = gl.COLOR_ATTACHMENT0;
      if (attachment > 0) {
        if (model._openGLRenderWindow.getWebgl2()) {
          glAttachment += attachment;
        } else {
          vtkErrorMacro$v('Using multiple framebuffer attachments requires WebGL 2');
          return;
        }
      }
      model.colorBuffers[attachment] = texture;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, texture.getHandle(), 0);
    };
    publicAPI.removeColorBuffer = function () {
      let attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      const gl = model.context;
      if (!gl) {
        vtkErrorMacro$v('you must set the OpenGLRenderWindow before calling removeColorBuffer');
        return;
      }
      let glAttachment = gl.COLOR_ATTACHMENT0;
      if (attachment > 0) {
        if (model._openGLRenderWindow.getWebgl2()) {
          glAttachment += attachment;
        } else {
          vtkErrorMacro$v('Using multiple framebuffer attachments requires WebGL 2');
          return;
        }
      }
      gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, null, 0);
      model.colorBuffers = model.colorBuffers.splice(attachment, 1);
    };
    publicAPI.setDepthBuffer = texture => {
      if (!model.context) {
        vtkErrorMacro$v('you must set the OpenGLRenderWindow before calling setDepthBuffer');
        return;
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        const gl = model.context;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, texture.getHandle(), 0);
      } else {
        vtkErrorMacro$v('Attaching depth buffer textures to fbo requires WebGL 2');
      }
    };
    publicAPI.removeDepthBuffer = () => {
      if (!model.context) {
        vtkErrorMacro$v('you must set the OpenGLRenderWindow before calling removeDepthBuffer');
        return;
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        const gl = model.context;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, null, 0);
      } else {
        vtkErrorMacro$v('Attaching depth buffer textures to framebuffers requires WebGL 2');
      }
    };
    publicAPI.getGLFramebuffer = () => model.glFramebuffer;
    publicAPI.setOpenGLRenderWindow = rw => {
      if (model._openGLRenderWindow === rw) {
        return;
      }
      publicAPI.releaseGraphicsResources();
      model._openGLRenderWindow = rw;
      model.context = null;
      if (rw) {
        model.context = model._openGLRenderWindow.getContext();
      }
    };
    publicAPI.releaseGraphicsResources = () => {
      if (model.glFramebuffer) {
        model.context.deleteFramebuffer(model.glFramebuffer);
      }
    };
    publicAPI.getSize = () => {
      const size = [0, 0];
      if (model.glFramebuffer !== null) {
        size[0] = model.glFramebuffer.width;
        size[1] = model.glFramebuffer.height;
      }
      return size;
    };
    publicAPI.populateFramebuffer = () => {
      if (!model.context) {
        vtkErrorMacro$v('you must set the OpenGLRenderWindow before calling populateFrameBuffer');
        return;
      }
      publicAPI.bind();
      const gl = model.context;
      const texture = vtkOpenGLTexture$1.newInstance();
      texture.setOpenGLRenderWindow(model._openGLRenderWindow);
      texture.setMinificationFilter(Filter$2.LINEAR);
      texture.setMagnificationFilter(Filter$2.LINEAR);
      texture.create2DFromRaw(model.glFramebuffer.width, model.glFramebuffer.height, 4, VtkDataTypes$5.UNSIGNED_CHAR, null);
      publicAPI.setColorBuffer(texture);

      // for now do not count on having a depth buffer texture
      // as they are not standard webgl 1
      model.depthTexture = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, model.depthTexture);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, model.glFramebuffer.width, model.glFramebuffer.height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, model.depthTexture);
    };

    // For backwards compatibility. Use getColorBuffers()[0] going forward.
    publicAPI.getColorTexture = () => model.colorBuffers[0];
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------
  const DEFAULT_VALUES$n = {
    // _openGLRenderWindow: null,
    glFramebuffer: null,
    colorBuffers: null,
    depthTexture: null,
    previousDrawBinding: 0,
    previousReadBinding: 0,
    previousDrawBuffer: 0,
    previousReadBuffer: 0,
    previousActiveFramebuffer: null
  };

  // ----------------------------------------------------------------------------
  function extend$n(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$n, initialValues);

    // Build VTK API
    obj(publicAPI, model);
    if (model.colorBuffers) {
      vtkErrorMacro$v('you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.');
    }
    model.colorBuffers = [];
    getArray(publicAPI, model, ['colorBuffers']);

    // For more macro methods, see "Sources/macros.js"
    // Object specific methods
    vtkFramebuffer(publicAPI, model);
  }

  // ----------------------------------------------------------------------------
  const newInstance$n = newInstance$1I(extend$n, 'vtkFramebuffer');

  // ----------------------------------------------------------------------------
  var vtkOpenGLFramebuffer = {
    newInstance: newInstance$n,
    extend: extend$n
  };

  // ----------------------------------------------------------------------------

  function vtkRenderPass(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkRenderPass');
    publicAPI.getOperation = () => model.currentOperation;
    publicAPI.setCurrentOperation = val => {
      model.currentOperation = val;
      model.currentTraverseOperation = `traverse${macro.capitalize(model.currentOperation)}`;
    };
    publicAPI.getTraverseOperation = () => model.currentTraverseOperation;

    // by default this class will traverse all of its
    // preDelegateOperations, then call its delegate render passes
    // the traverse all of its postDelegateOperations
    // any of those three arrays can be empty
    publicAPI.traverse = function (viewNode) {
      let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (model.deleted) {
        return;
      }

      // we just render our delegates in order
      model._currentParent = parent;
      model.preDelegateOperations.forEach(val => {
        publicAPI.setCurrentOperation(val);
        viewNode.traverse(publicAPI);
      });
      model.delegates.forEach(val => {
        val.traverse(viewNode, publicAPI);
      });
      model.postDelegateOperations.forEach(val => {
        publicAPI.setCurrentOperation(val);
        viewNode.traverse(publicAPI);
      });
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$m = {
    delegates: [],
    currentOperation: null,
    preDelegateOperations: [],
    postDelegateOperations: [],
    currentParent: null
  };

  // ----------------------------------------------------------------------------

  function extend$m(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$m, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ['currentOperation']);
    macro.setGet(publicAPI, model, ['delegates', '_currentParent', 'preDelegateOperations', 'postDelegateOperations']);
    macro.moveToProtected(publicAPI, model, ['currentParent']);

    // Object methods
    vtkRenderPass(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$m = macro.newInstance(extend$m, 'vtkRenderPass');

  // ----------------------------------------------------------------------------

  var vtkRenderPass$1 = {
    newInstance: newInstance$m,
    extend: extend$m
  };

  const {
    Representation: Representation$1
  } = vtkProperty$1;
  const {
    vtkErrorMacro: vtkErrorMacro$8
  } = macro;

  // ----------------------------------------------------------------------------

  function translucentShaderReplacement(shaders) {
    const substituteRes = vtkShaderProgram$1.substitute(shaders.Fragment, '//VTK::RenderPassFragmentShader::Impl', `
      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);
      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);
      gl_FragData[1].r = weight;
    `, false);
    shaders.Fragment = substituteRes.result;
  }
  const oitpFragTemplate$1 = `//VTK::System::Dec

in vec2 tcoord;

uniform sampler2D translucentRTexture;
uniform sampler2D translucentRGBATexture;

// the output of this shader
//VTK::Output::Dec

void main()
{
  vec4 t1Color = texture(translucentRGBATexture, tcoord);
  float t2Color = texture(translucentRTexture, tcoord).r;
  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);
}
`;
  function vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLOrderIndependentTranslucentPass');

    // build vertices etc
    publicAPI.createVertexBuffer = () => {
      // 4 corner points in clipping space in order (x, y, z) where z is always set to -1
      // prettier-ignore
      const ptsArray = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1]);

      // 4 corresponding corner points in texture space in order (x, y)
      const tcoordArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);

      // a square defined as cell relation ship in order (cell_size, v1, v2, v3, v4)
      const cellArray = new Uint16Array([4, 0, 1, 3, 2]);
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName('points');
      const tcoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcoordArray
      });
      tcoords.setName('tcoords');
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, 'polys', Representation$1.SURFACE, {
        points,
        tcoords,
        cellOffset: 0
      });
      model.VBOBuildTime.modified();
    };
    publicAPI.createFramebuffer = viewNode => {
      const size = viewNode.getSize();
      const gl = viewNode.getContext();
      model.framebuffer = vtkOpenGLFramebuffer.newInstance();
      model.framebuffer.setOpenGLRenderWindow(viewNode);
      model.framebuffer.create(...size);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      model.framebuffer.bind();
      model.translucentRGBATexture = vtkOpenGLTexture$1.newInstance();
      model.translucentRGBATexture.setInternalFormat(gl.RGBA16F);
      model.translucentRGBATexture.setFormat(gl.RGBA);
      model.translucentRGBATexture.setOpenGLDataType(gl.HALF_FLOAT);
      model.translucentRGBATexture.setOpenGLRenderWindow(viewNode);
      model.translucentRGBATexture.create2DFromRaw(size[0], size[1], 4, 'Float32Array', null);
      model.translucentRTexture = vtkOpenGLTexture$1.newInstance();
      model.translucentRTexture.setInternalFormat(gl.R16F);
      model.translucentRTexture.setFormat(gl.RED);
      model.translucentRTexture.setOpenGLDataType(gl.HALF_FLOAT);
      model.translucentRTexture.setOpenGLRenderWindow(viewNode);
      model.translucentRTexture.create2DFromRaw(size[0], size[1], 1, 'Float32Array', null);
      model.translucentZTexture = vtkOpenGLTexture$1.newInstance();
      model.translucentZTexture.setOpenGLRenderWindow(viewNode);
      model.translucentZTexture.createDepthFromRaw(size[0], size[1], 'Float32Array', null);
      model.framebuffer.setColorBuffer(model.translucentRGBATexture, 0);
      model.framebuffer.setColorBuffer(model.translucentRTexture, 1);
      model.framebuffer.setDepthBuffer(model.translucentZTexture);
    };
    publicAPI.createCopyShader = viewNode => {
      model.copyShader = viewNode.getShaderCache().readyShaderProgramArray(['//VTK::System::Dec', 'attribute vec4 vertexDC;', 'attribute vec2 tcoordTC;', 'varying vec2 tcoord;', 'void main() { tcoord = tcoordTC; gl_Position = vertexDC; }'].join('\n'), oitpFragTemplate$1, '');
    };
    publicAPI.createVBO = viewNode => {
      const gl = viewNode.getContext();
      model.tris.setOpenGLRenderWindow(viewNode);
      publicAPI.createVertexBuffer();
      const program = model.copyShader;
      // prepare the vertex and triangle data for the image plane to render to

      model.tris.getCABO().bind();
      if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'vertexDC', model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 3, gl.FALSE)) {
        vtkErrorMacro$8('Error setting vertexDC in copy shader VAO.');
      }
      if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), 'tcoordTC', model.tris.getCABO().getTCoordOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 2, gl.FALSE)) {
        vtkErrorMacro$8('Error setting vertexDC in copy shader VAO.');
      }
    };
    publicAPI.traverse = (viewNode, renNode, forwardPass) => {
      if (model.deleted) {
        return;
      }
      const size = viewNode.getSize();
      const gl = viewNode.getContext();

      // if we lack the webgl2 and half floatsupport just do
      // basic alpha blending
      model._supported = false;
      if (renNode.getSelector() || !gl || !viewNode.getWebgl2() || !gl.getExtension('EXT_color_buffer_half_float') && !gl.getExtension('EXT_color_buffer_float')) {
        publicAPI.setCurrentOperation('translucentPass');
        renNode.traverse(publicAPI);
        return;
      }
      model._supported = true;

      // prepare framebuffer // allocate framebuffer if needed and bind it
      if (model.framebuffer === null) {
        publicAPI.createFramebuffer(viewNode);
      } else {
        const fbSize = model.framebuffer.getSize();
        if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
          model.framebuffer.releaseGraphicsResources();
          model.translucentRGBATexture.releaseGraphicsResources(viewNode);
          model.translucentRTexture.releaseGraphicsResources(viewNode);
          model.translucentZTexture.releaseGraphicsResources(viewNode);
          publicAPI.createFramebuffer(viewNode);
        } else {
          // store framebuffer bindings to restore them later
          model.framebuffer.saveCurrentBindingsAndBuffers();
          model.framebuffer.bind();
        }
      }
      gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
      gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 0.0]);
      gl.clearBufferfv(gl.DEPTH, 0, [1.0]);
      gl.colorMask(false, false, false, false);

      // rerender the opaque pass to set the depth buffer
      // TODO remove when webgl1 is deprecated and instead
      // have the forward pass use a texture backed zbuffer
      if (forwardPass.getOpaqueActorCount() > 0) {
        // Don't use zBufferPass as it will also render the depth of translucent actors
        forwardPass.setCurrentOperation('opaqueZBufferPass');
        renNode.traverse(forwardPass);
      }
      gl.colorMask(true, true, true, true);
      gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);

      // make sure to clear the entire framebuffer as we will
      // be blitting the entire thing all of it needs good initial values
      gl.viewport(0, 0, size[0], size[1]);
      gl.scissor(0, 0, size[0], size[1]);
      gl.clearBufferfv(gl.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
      gl.clearBufferfv(gl.COLOR, 1, [0.0, 0.0, 0.0, 0.0]);
      gl.enable(gl.DEPTH_TEST);
      gl.enable(gl.BLEND);

      // basic gist is we accumulate color into RGB We compute final opacity
      // into A We store accumulated opacity into R of the R texture.
      gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);

      // now do the translucent rendering
      publicAPI.setCurrentOperation('translucentPass');
      renNode.traverse(publicAPI);
      gl.drawBuffers([gl.NONE]);
      model.framebuffer.restorePreviousBindingsAndBuffers();
      // gl.drawBuffers([gl.BACK]);

      // make sure the copy shader is ready
      if (model.copyShader === null) {
        publicAPI.createCopyShader(viewNode);
      } else {
        viewNode.getShaderCache().readyShaderProgram(model.copyShader);
      }

      // make sure we have a VAO
      if (!model.copyVAO) {
        model.copyVAO = vtkVertexArrayObject.newInstance();
        model.copyVAO.setOpenGLRenderWindow(viewNode);
      }
      model.copyVAO.bind();

      // make sure the VBO is up to date
      if (model.VBOBuildTime.getMTime() < publicAPI.getMTime()) {
        publicAPI.createVBO(viewNode);
      }
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      gl.depthMask(false);
      gl.depthFunc(gl.ALWAYS);
      gl.viewport(0, 0, size[0], size[1]);
      gl.scissor(0, 0, size[0], size[1]);

      // activate texture
      model.translucentRGBATexture.activate();
      model.copyShader.setUniformi('translucentRGBATexture', model.translucentRGBATexture.getTextureUnit());
      model.translucentRTexture.activate();
      model.copyShader.setUniformi('translucentRTexture', model.translucentRTexture.getTextureUnit());

      // render quad
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      gl.depthMask(true);
      gl.depthFunc(gl.LEQUAL);
      model.translucentRGBATexture.deactivate();
      model.translucentRTexture.deactivate();
    };
    publicAPI.getShaderReplacement = () => {
      if (model._supported) {
        return translucentShaderReplacement;
      }
      return null;
    };
    publicAPI.releaseGraphicsResources = viewNode => {
      if (model.framebuffer) {
        model.framebuffer.releaseGraphicsResources(viewNode);
        model.framebuffer = null;
      }
      if (model.translucentRGBATexture) {
        model.translucentRGBATexture.releaseGraphicsResources(viewNode);
        model.translucentRGBATexture = null;
      }
      if (model.translucentRTexture) {
        model.translucentRTexture.releaseGraphicsResources(viewNode);
        model.translucentRTexture = null;
      }
      if (model.translucentZTexture) {
        model.translucentZTexture.releaseGraphicsResources(viewNode);
        model.translucentZTexture = null;
      }
      if (model.copyVAO) {
        model.copyVAO.releaseGraphicsResources(viewNode);
        model.copyVAO = null;
      }
      if (model.copyShader) {
        model.copyShader.releaseGraphicsResources(viewNode);
        model.copyShader = null;
      }
      if (model.tris) {
        model.tris.releaseGraphicsResources(viewNode);
        model.tris = null;
      }
      publicAPI.modified();
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$l = {
    framebuffer: null,
    copyShader: null,
    tris: null
  };

  // ----------------------------------------------------------------------------

  function extend$l(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$l, initialValues);

    // Build VTK API
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    model.VBOBuildTime = {};
    macro.obj(model.VBOBuildTime, {
      mtime: 0
    });
    model.tris = vtkHelper.newInstance();
    macro.get(publicAPI, model, ['framebuffer']);

    // Object methods
    vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$l = macro.newInstance(extend$l, 'vtkOpenGLOrderIndependentTranslucentPass');

  // ----------------------------------------------------------------------------

  var vtkOpenGLOrderIndependentTranslucentPass$1 = {
    newInstance: newInstance$l,
    extend: extend$l
  };

  // ----------------------------------------------------------------------------

  function vtkForwardPass$2(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkForwardPass');

    // this pass implements a forward rendering pipeline
    // if both volumes and opaque geometry are present
    // it will mix the two together by capturing a zbuffer
    // first
    publicAPI.traverse = function (viewNode) {
      let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (model.deleted) {
        return;
      }

      // we just render our delegates in order
      model._currentParent = parent;

      // build
      publicAPI.setCurrentOperation('buildPass');
      viewNode.traverse(publicAPI);
      const numlayers = viewNode.getRenderable().getNumberOfLayers();

      // iterate over renderers
      const renderers = viewNode.getChildren();
      for (let i = 0; i < numlayers; i++) {
        for (let index = 0; index < renderers.length; index++) {
          const renNode = renderers[index];
          const ren = viewNode.getRenderable().getRenderers()[index];
          if (ren.getDraw() && ren.getLayer() === i) {
            // check for both opaque and volume actors
            model.opaqueActorCount = 0;
            model.translucentActorCount = 0;
            model.volumeCount = 0;
            model.overlayActorCount = 0;
            publicAPI.setCurrentOperation('queryPass');
            renNode.traverse(publicAPI);

            // do we need to capture a zbuffer?
            if ((model.opaqueActorCount > 0 || model.translucentActorCount > 0) && model.volumeCount > 0 || model.depthRequested) {
              const size = viewNode.getFramebufferSize();
              // make sure the framebuffer is setup
              if (model.framebuffer === null) {
                model.framebuffer = vtkOpenGLFramebuffer.newInstance();
              }
              model.framebuffer.setOpenGLRenderWindow(viewNode);
              model.framebuffer.saveCurrentBindingsAndBuffers();
              const fbSize = model.framebuffer.getSize();
              if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
                model.framebuffer.create(size[0], size[1]);
                model.framebuffer.populateFramebuffer();
              }
              model.framebuffer.bind();
              // opaqueZBufferPass only renders opaque actors
              // zBufferPass renders both translucent and opaque actors
              // we want to be able to pick translucent actors
              publicAPI.setCurrentOperation('zBufferPass');
              renNode.traverse(publicAPI);
              model.framebuffer.restorePreviousBindingsAndBuffers();

              // reset now that we have done it
              model.depthRequested = false;
            }
            publicAPI.setCurrentOperation('cameraPass');
            renNode.traverse(publicAPI);
            if (model.opaqueActorCount > 0) {
              publicAPI.setCurrentOperation('opaquePass');
              renNode.traverse(publicAPI);
            }
            if (model.translucentActorCount > 0) {
              if (!model.translucentPass) {
                model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass$1.newInstance();
              }
              model.translucentPass.traverse(viewNode, renNode, publicAPI);
            }
            if (model.volumeCount > 0) {
              publicAPI.setCurrentOperation('volumePass');
              renNode.traverse(publicAPI);
            }
            if (model.overlayActorCount > 0) {
              publicAPI.setCurrentOperation('overlayPass');
              renNode.traverse(publicAPI);
            }
          }
        }
      }
    };
    publicAPI.getZBufferTexture = () => {
      if (model.framebuffer) {
        return model.framebuffer.getColorTexture();
      }
      return null;
    };
    publicAPI.requestDepth = () => {
      model.depthRequested = true;
    };
    publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;
    publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;
    publicAPI.incrementVolumeCount = () => model.volumeCount++;
    publicAPI.incrementOverlayActorCount = () => model.overlayActorCount++;
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$k = {
    opaqueActorCount: 0,
    translucentActorCount: 0,
    volumeCount: 0,
    overlayActorCount: 0,
    framebuffer: null,
    depthRequested: false
  };

  // ----------------------------------------------------------------------------

  function extend$k(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$k, initialValues);

    // Build VTK API
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    macro.get(publicAPI, model, ['framebuffer', 'opaqueActorCount', 'translucentActorCount', 'volumeCount']);

    // Object methods
    vtkForwardPass$2(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$k = macro.newInstance(extend$k, 'vtkForwardPass');

  // ----------------------------------------------------------------------------

  var vtkForwardPass$1$1 = {
    newInstance: newInstance$k,
    extend: extend$k
  };

  const {
    FieldAssociations: FieldAssociations$2
  } = vtkDataSet$1;

  // ----------------------------------------------------------------------------
  // vtkHardwareSelector methods
  // ----------------------------------------------------------------------------

  function vtkHardwareSelector$1(publicAPI, model) {
    model.classHierarchy.push('vtkHardwareSelector');

    // get the source data that is used for generating a selection. This
    // must be called at least once before calling generateSelection. In
    // raster based backends this method will capture the buffers. You can
    // call this once and then make multiple calls to generateSelection.
    publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {};
    publicAPI.selectAsync = async (renderer, fx1, fy1, fx2, fy2) => {
      const srcData = await publicAPI.getSourceDataAsync(renderer, fx1, fy1, fx2, fy2);
      if (srcData) {
        return srcData.generateSelection(fx1, fy1, fx2, fy2);
      }
      return [];
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$j = {
    fieldAssociation: FieldAssociations$2.FIELD_ASSOCIATION_CELLS,
    captureZValues: false
  };

  // ----------------------------------------------------------------------------

  function extend$j(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$j, initialValues);

    // Inheritance
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ['fieldAssociation', 'captureZValues']);

    // Object methods
    vtkHardwareSelector$1(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$j = macro.newInstance(extend$j, 'vtkHardwareSelector');

  // ----------------------------------------------------------------------------

  var vtkHardwareSelector$1$1 = {
    newInstance: newInstance$j,
    extend: extend$j
  };

  /**
   * The (primary) property that describes the content of a selection
   * node's data. Other auxiliary description properties follow.
   * GLOBALIDS means that the selection list contains values from the
   * vtkDataSetAttribute array of the same name.
   * PEDIGREEIDS means that the selection list contains values from the
   * vtkDataSetAttribute array of the same name.
   * VALUES means the the selection list contains values from an
   * arbitrary attribute array (ignores any globalids attribute)
   * INDICES means that the selection list contains indexes into the
   * cell or point arrays.
   * FRUSTUM means the set of points and cells inside a frustum
   * LOCATIONS means the set of points and cells near a set of positions
   * THRESHOLDS means the points and cells with values within a set of ranges
   * getContentType() returns -1 if the content type is not set.
   */

  // Specify how data arrays can be used by data objects
  const SelectionContent$2 = {
    GLOBALIDS: 0,
    PEDIGREEIDS: 1,
    VALUES: 2,
    INDICES: 3,
    FRUSTUM: 4,
    LOCATIONS: 5,
    THRESHOLDS: 6,
    BLOCKS: 7,
    QUERY: 8
  };
  const SelectionField$2 = {
    CELL: 0,
    POINT: 1,
    FIELD: 2,
    VERTEX: 3,
    EDGE: 4,
    ROW: 5
  };
  var Constants = {
    SelectionContent: SelectionContent$2,
    SelectionField: SelectionField$2
  };

  // ----------------------------------------------------------------------------
  // vtkSelectionNode methods
  // ----------------------------------------------------------------------------

  function vtkSelectionNode(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkSelectionNode');
    publicAPI.getBounds = () => model.points.getBounds();
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$i = {
    contentType: -1,
    fieldType: -1,
    properties: null,
    selectionList: []
  };

  // ----------------------------------------------------------------------------

  function extend$i(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$i, initialValues);

    // Inheritance
    macro.obj(publicAPI, model);
    model.properties = {};
    macro.setGet(publicAPI, model, ['contentType', 'fieldType', 'properties', 'selectionList']);

    // Object specific methods
    vtkSelectionNode(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$i = macro.newInstance(extend$i, 'vtkSelectionNode');

  // ----------------------------------------------------------------------------

  var vtkSelectionNode$1 = {
    newInstance: newInstance$i,
    extend: extend$i,
    ...Constants
  };

  const {
    PassTypes
  } = Constants$7;
  const {
    SelectionContent: SelectionContent$1,
    SelectionField: SelectionField$1
  } = vtkSelectionNode$1;
  const {
    FieldAssociations: FieldAssociations$1
  } = vtkDataSet$1;
  const {
    vtkErrorMacro: vtkErrorMacro$7
  } = macro;
  const idOffset = 1;
  function getInfoHash$1(info) {
    return `${info.propID} ${info.compositeID}`;
  }
  function getAlpha(xx, yy, pb, area) {
    if (!pb) {
      return 0;
    }
    const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;
    return pb[offset + 3];
  }
  function convert$1(xx, yy, pb, area) {
    if (!pb) {
      return 0;
    }
    const offset = (yy * (area[2] - area[0] + 1) + xx) * 4;
    const r = pb[offset];
    const g = pb[offset + 1];
    const b = pb[offset + 2];
    return (b * 256 + g) * 256 + r;
  }
  function getID(low24, high8) {
    /* eslint-disable no-bitwise */
    let val = high8;
    val <<= 24;
    val |= low24;
    return val;
    /* eslint-enable no-bitwise */
  }

  function getPixelInformationWithData$1(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
    // Base case
    const maxDist = maxDistance < 0 ? 0 : maxDistance;
    if (maxDist === 0) {
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      if (inDisplayPosition[0] < buffdata.area[0] || inDisplayPosition[0] > buffdata.area[2] || inDisplayPosition[1] < buffdata.area[1] || inDisplayPosition[1] > buffdata.area[3]) {
        return null;
      }

      // offset inDisplayPosition based on the lower-left-corner of the Area.
      const displayPosition = [inDisplayPosition[0] - buffdata.area[0], inDisplayPosition[1] - buffdata.area[1]];
      const actorid = convert$1(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ACTOR_PASS], buffdata.area);
      if (actorid <= 0 || actorid - idOffset >= buffdata.props.length) {
        // the pixel did not hit any actor.
        return null;
      }
      const info = {};
      info.valid = true;
      info.propID = actorid - idOffset;
      info.prop = buffdata.props[info.propID];
      let compositeID = convert$1(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], buffdata.area);
      if (compositeID < 0 || compositeID > 0xffffff) {
        compositeID = 0;
      }
      info.compositeID = compositeID - idOffset;
      if (buffdata.captureZValues) {
        const offset = (displayPosition[1] * (buffdata.area[2] - buffdata.area[0] + 1) + displayPosition[0]) * 4;
        info.zValue = (256 * buffdata.zBuffer[offset] + buffdata.zBuffer[offset + 1]) / 65535.0;
        info.displayPosition = inDisplayPosition;
      }
      if (buffdata.pixBuffer[PassTypes.ID_LOW24]) {
        if (getAlpha(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area) === 0.0) {
          return info;
        }
      }
      const low24 = convert$1(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_LOW24], buffdata.area);
      const high24 = convert$1(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes.ID_HIGH24], buffdata.area);
      info.attributeID = getID(low24, high24);
      return info;
    }

    // Iterate over successively growing boxes.
    // They recursively call the base case to handle single pixels.
    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
    const curPos = [0, 0];
    let info = getPixelInformationWithData$1(buffdata, inDisplayPosition, 0, outSelectedPosition);
    if (info && info.valid) {
      return info;
    }
    for (let dist = 1; dist < maxDist; ++dist) {
      // Vertical sides of box.
      for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
        curPos[1] = y;
        if (dispPos[0] >= dist) {
          curPos[0] = dispPos[0] - dist;
          info = getPixelInformationWithData$1(buffdata, curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[0] = dispPos[0] + dist;
        info = getPixelInformationWithData$1(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      // Horizontal sides of box.
      for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
        curPos[0] = x;
        if (dispPos[1] >= dist) {
          curPos[1] = dispPos[1] - dist;
          info = getPixelInformationWithData$1(buffdata, curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[1] = dispPos[1] + dist;
        info = getPixelInformationWithData$1(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
    }

    // nothing hit.
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    return null;
  }

  //-----------------------------------------------------------------------------
  function convertSelection$1(fieldassociation, dataMap, captureZValues, renderer, openGLRenderWindow) {
    const sel = [];
    let count = 0;
    dataMap.forEach((value, key) => {
      const child = vtkSelectionNode$1.newInstance();
      child.setContentType(SelectionContent$1.INDICES);
      switch (fieldassociation) {
        case FieldAssociations$1.FIELD_ASSOCIATION_CELLS:
          child.setFieldType(SelectionField$1.CELL);
          break;
        case FieldAssociations$1.FIELD_ASSOCIATION_POINTS:
          child.setFieldType(SelectionField$1.POINT);
          break;
        default:
          vtkErrorMacro$7('Unknown field association');
      }
      child.getProperties().propID = value.info.propID;
      child.getProperties().prop = value.info.prop;
      child.getProperties().compositeID = value.info.compositeID;
      child.getProperties().attributeID = value.info.attributeID;
      child.getProperties().pixelCount = value.pixelCount;
      if (captureZValues) {
        child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
        child.getProperties().worldPosition = openGLRenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, renderer);
      }
      child.setSelectionList(value.attributeIDs);
      sel[count] = child;
      count++;
    });
    return sel;
  }

  //----------------------------------------------------------------------------
  function generateSelectionWithData$1(buffdata, fx1, fy1, fx2, fy2) {
    const x1 = Math.floor(fx1);
    const y1 = Math.floor(fy1);
    const x2 = Math.floor(fx2);
    const y2 = Math.floor(fy2);
    const dataMap = new Map();
    const outSelectedPosition = [0, 0];
    for (let yy = y1; yy <= y2; yy++) {
      for (let xx = x1; xx <= x2; xx++) {
        const pos = [xx, yy];
        const info = getPixelInformationWithData$1(buffdata, pos, 0, outSelectedPosition);
        if (info && info.valid) {
          const hash = getInfoHash$1(info);
          if (!dataMap.has(hash)) {
            dataMap.set(hash, {
              info,
              pixelCount: 1,
              attributeIDs: [info.attributeID]
            });
          } else {
            const dmv = dataMap.get(hash);
            dmv.pixelCount++;
            if (buffdata.captureZValues) {
              if (info.zValue < dmv.info.zValue) {
                dmv.info = info;
              }
            }
            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
              dmv.attributeIDs.push(info.attributeID);
            }
          }
        }
      }
    }
    return convertSelection$1(buffdata.fieldAssociation, dataMap, buffdata.captureZValues, buffdata.renderer, buffdata.openGLRenderWindow);
  }

  // ----------------------------------------------------------------------------
  // vtkOpenGLHardwareSelector methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLHardwareSelector(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLHardwareSelector');

    //----------------------------------------------------------------------------
    publicAPI.releasePixBuffers = () => {
      model.rawPixBuffer = [];
      model.pixBuffer = [];
      model.zBuffer = null;
    };

    //----------------------------------------------------------------------------
    publicAPI.beginSelection = () => {
      model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);
      model.maxAttributeId = 0;
      const size = model._openGLRenderWindow.getSize();
      if (!model.framebuffer) {
        model.framebuffer = vtkOpenGLFramebuffer.newInstance();
        model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.framebuffer.saveCurrentBindingsAndBuffers();
        model.framebuffer.create(size[0], size[1]);
        // this calls model.framebuffer.bind()
        model.framebuffer.populateFramebuffer();
      } else {
        model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.framebuffer.saveCurrentBindingsAndBuffers();
        const fbSize = model.framebuffer.getSize();
        if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
          model.framebuffer.create(size[0], size[1]);
          // this calls model.framebuffer.bind()
          model.framebuffer.populateFramebuffer();
        } else {
          model.framebuffer.bind();
        }
      }
      model._openGLRenderer.clear();
      model._openGLRenderer.setSelector(publicAPI);
      model.hitProps = {};
      model.propPixels = {};
      model.props = [];
      publicAPI.releasePixBuffers();
      if (model.fieldAssociation === FieldAssociations$1.FIELD_ASSOCIATION_POINTS) {
        const gl = model._openGLRenderWindow.getContext();
        const originalBlending = gl.isEnabled(gl.BLEND);
        gl.disable(gl.BLEND);
        model._openGLRenderWindow.traverseAllPasses();
        if (originalBlending) {
          gl.enable(gl.BLEND);
        }
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.endSelection = () => {
      model.hitProps = {};
      model._openGLRenderer.setSelector(null);
      model.framebuffer.restorePreviousBindingsAndBuffers();
    };
    publicAPI.preCapturePass = () => {
      const gl = model._openGLRenderWindow.getContext();
      // Disable blending
      model.originalBlending = gl.isEnabled(gl.BLEND);
      gl.disable(gl.BLEND);
    };
    publicAPI.postCapturePass = () => {
      const gl = model._openGLRenderWindow.getContext();
      // Restore blending if it was enabled prior to the capture
      if (model.originalBlending) {
        gl.enable(gl.BLEND);
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.select = () => {
      let sel = null;
      if (publicAPI.captureBuffers()) {
        sel = publicAPI.generateSelection(model.area[0], model.area[1], model.area[2], model.area[3]);
        publicAPI.releasePixBuffers();
      }
      return sel;
    };
    publicAPI.getSourceDataAsync = async (renderer, fx1, fy1, fx2, fy2) => {
      // assign the renderer
      model._renderer = renderer;

      // set area to all if no arguments provided
      if (fx1 === undefined) {
        const size = model._openGLRenderWindow.getSize();
        publicAPI.setArea(0, 0, size[0] - 1, size[1] - 1);
      } else {
        publicAPI.setArea(fx1, fy1, fx2, fy2);
      }
      // just do capture buffers and package up the result
      if (!publicAPI.captureBuffers()) {
        return false;
      }
      const result = {
        area: [...model.area],
        pixBuffer: [...model.pixBuffer],
        captureZValues: model.captureZValues,
        zBuffer: model.zBuffer,
        props: [...model.props],
        fieldAssociation: model.fieldAssociation,
        renderer,
        openGLRenderWindow: model._openGLRenderWindow
      };
      result.generateSelection = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return generateSelectionWithData$1(result, ...args);
      };
      return result;
    };

    //----------------------------------------------------------------------------
    publicAPI.captureBuffers = () => {
      if (!model._renderer || !model._openGLRenderWindow) {
        vtkErrorMacro$7('Renderer and view must be set before calling Select.');
        return false;
      }
      model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model._renderer);

      // todo revisit making selection part of core
      // then we can do this in core
      model._openGLRenderWindow.getRenderable().preRender();

      // int rgba[4];
      // rwin.getColorBufferSizes(rgba);
      // if (rgba[0] < 8 || rgba[1] < 8 || rgba[2] < 8) {
      //   vtkErrorMacro("Color buffer depth must be at least 8 bit. "
      //     "Currently: " << rgba[0] << ", " << rgba[1] << ", " <<rgba[2]);
      //   return false;
      // }
      publicAPI.invokeEvent({
        type: 'StartEvent'
      });

      // Initialize renderer for selection.
      // change the renderer's background to black, which will indicate a miss
      model.originalBackground = model._renderer.getBackgroundByReference();
      model._renderer.setBackground(0.0, 0.0, 0.0, 0.0);
      const rpasses = model._openGLRenderWindow.getRenderPasses();
      publicAPI.beginSelection();
      for (model.currentPass = PassTypes.MIN_KNOWN_PASS; model.currentPass <= PassTypes.MAX_KNOWN_PASS; model.currentPass++) {
        if (publicAPI.passRequired(model.currentPass)) {
          publicAPI.preCapturePass(model.currentPass);
          if (model.captureZValues && model.currentPass === PassTypes.ACTOR_PASS && typeof rpasses[0].requestDepth === 'function' && typeof rpasses[0].getFramebuffer === 'function') {
            rpasses[0].requestDepth();
            model._openGLRenderWindow.traverseAllPasses();
          } else {
            model._openGLRenderWindow.traverseAllPasses();
          }
          publicAPI.postCapturePass(model.currentPass);
          publicAPI.savePixelBuffer(model.currentPass);
          publicAPI.processPixelBuffers();
        }
      }
      publicAPI.endSelection();

      // restore original background
      model._renderer.setBackground(model.originalBackground);
      publicAPI.invokeEvent({
        type: 'EndEvent'
      });

      // restore image, not needed?
      // model._openGLRenderWindow.traverseAllPasses();
      return true;
    };
    publicAPI.processPixelBuffers = () => {
      model.props.forEach((prop, index) => {
        if (publicAPI.isPropHit(index)) {
          prop.processSelectorPixelBuffers(publicAPI, model.propPixels[index]);
        }
      });
    };

    //----------------------------------------------------------------------------
    publicAPI.passRequired = pass => {
      if (pass === PassTypes.ID_HIGH24) {
        if (model.fieldAssociation === FieldAssociations$1.FIELD_ASSOCIATION_POINTS) {
          return model.maximumPointId > 0x00ffffff;
        }
        if (model.fieldAssociation === FieldAssociations$1.FIELD_ASSOCIATION_CELLS) {
          return model.maximumCellId > 0x00ffffff;
        }
      }
      return true;
    };

    //----------------------------------------------------------------------------
    publicAPI.savePixelBuffer = passNo => {
      model.pixBuffer[passNo] = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
      if (!model.rawPixBuffer[passNo]) {
        const size = (model.area[2] - model.area[0] + 1) * (model.area[3] - model.area[1] + 1) * 4;
        model.rawPixBuffer[passNo] = new Uint8Array(size);
        model.rawPixBuffer[passNo].set(model.pixBuffer[passNo]);
      }
      if (passNo === PassTypes.ACTOR_PASS) {
        if (model.captureZValues) {
          const rpasses = model._openGLRenderWindow.getRenderPasses();
          if (typeof rpasses[0].requestDepth === 'function' && typeof rpasses[0].getFramebuffer === 'function') {
            const fb = rpasses[0].getFramebuffer();
            fb.saveCurrentBindingsAndBuffers();
            fb.bind();
            model.zBuffer = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
            fb.restorePreviousBindingsAndBuffers();
          }
        }
        publicAPI.buildPropHitList(model.rawPixBuffer[passNo]);
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.buildPropHitList = pixelbuffer => {
      let offset = 0;
      for (let yy = 0; yy <= model.area[3] - model.area[1]; yy++) {
        for (let xx = 0; xx <= model.area[2] - model.area[0]; xx++) {
          let val = convert$1(xx, yy, pixelbuffer, model.area);
          if (val > 0) {
            val--;
            if (!(val in model.hitProps)) {
              model.hitProps[val] = true;
              model.propPixels[val] = [];
            }
            model.propPixels[val].push(offset * 4);
          }
          ++offset;
        }
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.renderProp = prop => {
      if (model.currentPass === PassTypes.ACTOR_PASS) {
        publicAPI.setPropColorValueFromInt(model.props.length + idOffset);
        model.props.push(prop);
      }
    };

    //----------------------------------------------------------------------------
    publicAPI.renderCompositeIndex = index => {
      if (model.currentPass === PassTypes.COMPOSITE_INDEX_PASS) {
        publicAPI.setPropColorValueFromInt(index + idOffset);
      }
    };

    //----------------------------------------------------------------------------
    // TODO: make inline
    publicAPI.renderAttributeId = attribid => {
      if (attribid < 0) {
        // negative attribid is valid. It happens when rendering higher order
        // elements where new points are added for rendering smooth surfaces.
        return;
      }
      model.maxAttributeId = attribid > model.maxAttributeId ? attribid : model.maxAttributeId;

      // if (model.currentPass < PassTypes.ID_LOW24) {
      //   return; // useless...
      // }
    };

    //----------------------------------------------------------------------------
    publicAPI.passTypeToString = type => macro.enumToString(PassTypes, type);

    //----------------------------------------------------------------------------
    publicAPI.isPropHit = id => Boolean(model.hitProps[id]);
    publicAPI.setPropColorValueFromInt = val => {
      model.propColorValue[0] = val % 256 / 255.0;
      model.propColorValue[1] = Math.floor(val / 256) % 256 / 255.0;
      model.propColorValue[2] = Math.floor(val / 65536) % 256 / 255.0;
    };

    // info has
    //   valid
    //   propId
    //   prop
    //   compositeID
    //   attributeID

    //----------------------------------------------------------------------------
    publicAPI.getPixelInformation = (inDisplayPosition, maxDistance, outSelectedPosition) => {
      // Base case
      const maxDist = maxDistance < 0 ? 0 : maxDistance;
      if (maxDist === 0) {
        outSelectedPosition[0] = inDisplayPosition[0];
        outSelectedPosition[1] = inDisplayPosition[1];
        if (inDisplayPosition[0] < model.area[0] || inDisplayPosition[0] > model.area[2] || inDisplayPosition[1] < model.area[1] || inDisplayPosition[1] > model.area[3]) {
          return null;
        }

        // offset inDisplayPosition based on the lower-left-corner of the Area.
        const displayPosition = [inDisplayPosition[0] - model.area[0], inDisplayPosition[1] - model.area[1]];
        const actorid = convert$1(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ACTOR_PASS], model.area);
        if (actorid <= 0 || actorid - idOffset >= model.props.length) {
          // the pixel did not hit any actor.
          return null;
        }
        const info = {};
        info.valid = true;
        info.propID = actorid - idOffset;
        info.prop = model.props[info.propID];
        let compositeID = convert$1(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS], model.area);
        if (compositeID < 0 || compositeID > 0xffffff) {
          compositeID = 0;
        }
        info.compositeID = compositeID - idOffset;
        if (model.captureZValues) {
          const offset = (displayPosition[1] * (model.area[2] - model.area[0] + 1) + displayPosition[0]) * 4;
          info.zValue = (256 * model.zBuffer[offset] + model.zBuffer[offset + 1]) / 65535.0;
          info.displayPosition = inDisplayPosition;
        }

        // Skip attribute ids if alpha is zero (missed)
        if (model.pixBuffer[PassTypes.ID_LOW24]) {
          if (getAlpha(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area) === 0.0) {
            return info;
          }
        }
        const low24 = convert$1(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24], model.area);
        const high24 = convert$1(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_HIGH24], model.area);
        info.attributeID = getID(low24, high24);
        return info;
      }

      // Iterate over successively growing boxes.
      // They recursively call the base case to handle single pixels.
      const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
      const curPos = [0, 0];
      let info = publicAPI.getPixelInformation(inDisplayPosition, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
      for (let dist = 1; dist < maxDist; ++dist) {
        // Vertical sides of box.
        for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
          curPos[1] = y;
          if (dispPos[0] >= dist) {
            curPos[0] = dispPos[0] - dist;
            info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
            if (info && info.valid) {
              return info;
            }
          }
          curPos[0] = dispPos[0] + dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        // Horizontal sides of box.
        for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
          curPos[0] = x;
          if (dispPos[1] >= dist) {
            curPos[1] = dispPos[1] - dist;
            info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
            if (info && info.valid) {
              return info;
            }
          }
          curPos[1] = dispPos[1] + dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
      }

      // nothing hit.
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      return null;
    };

    //----------------------------------------------------------------------------
    publicAPI.generateSelection = (fx1, fy1, fx2, fy2) => {
      const x1 = Math.floor(fx1);
      const y1 = Math.floor(fy1);
      const x2 = Math.floor(fx2);
      const y2 = Math.floor(fy2);
      const dataMap = new Map();
      const outSelectedPosition = [0, 0];
      for (let yy = y1; yy <= y2; yy++) {
        for (let xx = x1; xx <= x2; xx++) {
          const pos = [xx, yy];
          const info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);
          if (info && info.valid) {
            const hash = getInfoHash$1(info);
            if (!dataMap.has(hash)) {
              dataMap.set(hash, {
                info,
                pixelCount: 1,
                attributeIDs: [info.attributeID]
              });
            } else {
              const dmv = dataMap.get(hash);
              dmv.pixelCount++;
              if (model.captureZValues) {
                if (info.zValue < dmv.info.zValue) {
                  dmv.info = info;
                }
              }
              if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
                dmv.attributeIDs.push(info.attributeID);
              }
            }
          }
        }
      }
      return convertSelection$1(model.fieldAssociation, dataMap, model.captureZValues, model._renderer, model._openGLRenderWindow);
    };
    publicAPI.getRawPixelBuffer = passNo => model.rawPixBuffer[passNo];
    publicAPI.getPixelBuffer = passNo => model.pixBuffer[passNo];

    //----------------------------------------------------------------------------

    publicAPI.attach = (w, r) => {
      model._openGLRenderWindow = w;
      model._renderer = r;
    };

    // override
    const superSetArea = publicAPI.setArea;
    publicAPI.setArea = function () {
      if (superSetArea(...arguments)) {
        model.area[0] = Math.floor(model.area[0]);
        model.area[1] = Math.floor(model.area[1]);
        model.area[2] = Math.floor(model.area[2]);
        model.area[3] = Math.floor(model.area[3]);
        return true;
      }
      return false;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$h = {
    area: undefined,
    // _renderer: null,
    // _openGLRenderWindow: null,
    // _openGLRenderer: null,
    currentPass: -1,
    propColorValue: null,
    props: null,
    maximumPointId: 0,
    maximumCellId: 0,
    idOffset: 1
  };

  // ----------------------------------------------------------------------------

  function extend$h(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$h, initialValues);

    // Build VTK API
    vtkHardwareSelector$1$1.extend(publicAPI, model, initialValues);
    model.propColorValue = [0, 0, 0];
    model.props = [];
    if (!model.area) {
      model.area = [0, 0, 0, 0];
    }
    macro.setGetArray(publicAPI, model, ['area'], 4);
    macro.setGet(publicAPI, model, ['_renderer', 'currentPass', '_openGLRenderWindow', 'maximumPointId', 'maximumCellId']);
    macro.setGetArray(publicAPI, model, ['propColorValue'], 3);
    macro.moveToProtected(publicAPI, model, ['renderer', 'openGLRenderWindow']);
    macro.event(publicAPI, model, 'event');

    // Object methods
    vtkOpenGLHardwareSelector(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$h = macro.newInstance(extend$h, 'vtkOpenGLHardwareSelector');

  // ----------------------------------------------------------------------------

  var vtkHardwareSelector = {
    newInstance: newInstance$h,
    extend: extend$h,
    ...Constants$7
  };

  var sparkMd5 = {exports: {}};

  (function (module, exports) {
  	(function (factory) {
  	    {
  	        // Node/CommonJS
  	        module.exports = factory();
  	    }
  	}(function (undefined$1) {

  	    /*
  	     * Fastest md5 implementation around (JKM md5).
  	     * Credits: Joseph Myers
  	     *
  	     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html
  	     * @see http://jsperf.com/md5-shootout/7
  	     */

  	    /* this function is much faster,
  	      so if possible we use it. Some IEs
  	      are the only ones I know of that
  	      need the idiotic second function,
  	      generated by an if clause.  */
  	    var hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];

  	    function md5cycle(x, k) {
  	        var a = x[0],
  	            b = x[1],
  	            c = x[2],
  	            d = x[3];

  	        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
  	        a  = (a << 7 | a >>> 25) + b | 0;
  	        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
  	        d  = (d << 12 | d >>> 20) + a | 0;
  	        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
  	        c  = (c << 17 | c >>> 15) + d | 0;
  	        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
  	        b  = (b << 22 | b >>> 10) + c | 0;
  	        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
  	        a  = (a << 7 | a >>> 25) + b | 0;
  	        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
  	        d  = (d << 12 | d >>> 20) + a | 0;
  	        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
  	        c  = (c << 17 | c >>> 15) + d | 0;
  	        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
  	        b  = (b << 22 | b >>> 10) + c | 0;
  	        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
  	        a  = (a << 7 | a >>> 25) + b | 0;
  	        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
  	        d  = (d << 12 | d >>> 20) + a | 0;
  	        c += (d & a | ~d & b) + k[10] - 42063 | 0;
  	        c  = (c << 17 | c >>> 15) + d | 0;
  	        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
  	        b  = (b << 22 | b >>> 10) + c | 0;
  	        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
  	        a  = (a << 7 | a >>> 25) + b | 0;
  	        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
  	        d  = (d << 12 | d >>> 20) + a | 0;
  	        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
  	        c  = (c << 17 | c >>> 15) + d | 0;
  	        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
  	        b  = (b << 22 | b >>> 10) + c | 0;

  	        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
  	        a  = (a << 5 | a >>> 27) + b | 0;
  	        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
  	        d  = (d << 9 | d >>> 23) + a | 0;
  	        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
  	        c  = (c << 14 | c >>> 18) + d | 0;
  	        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
  	        b  = (b << 20 | b >>> 12) + c | 0;
  	        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
  	        a  = (a << 5 | a >>> 27) + b | 0;
  	        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
  	        d  = (d << 9 | d >>> 23) + a | 0;
  	        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
  	        c  = (c << 14 | c >>> 18) + d | 0;
  	        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
  	        b  = (b << 20 | b >>> 12) + c | 0;
  	        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
  	        a  = (a << 5 | a >>> 27) + b | 0;
  	        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
  	        d  = (d << 9 | d >>> 23) + a | 0;
  	        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
  	        c  = (c << 14 | c >>> 18) + d | 0;
  	        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
  	        b  = (b << 20 | b >>> 12) + c | 0;
  	        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
  	        a  = (a << 5 | a >>> 27) + b | 0;
  	        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
  	        d  = (d << 9 | d >>> 23) + a | 0;
  	        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
  	        c  = (c << 14 | c >>> 18) + d | 0;
  	        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
  	        b  = (b << 20 | b >>> 12) + c | 0;

  	        a += (b ^ c ^ d) + k[5] - 378558 | 0;
  	        a  = (a << 4 | a >>> 28) + b | 0;
  	        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
  	        d  = (d << 11 | d >>> 21) + a | 0;
  	        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
  	        c  = (c << 16 | c >>> 16) + d | 0;
  	        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
  	        b  = (b << 23 | b >>> 9) + c | 0;
  	        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
  	        a  = (a << 4 | a >>> 28) + b | 0;
  	        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
  	        d  = (d << 11 | d >>> 21) + a | 0;
  	        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
  	        c  = (c << 16 | c >>> 16) + d | 0;
  	        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
  	        b  = (b << 23 | b >>> 9) + c | 0;
  	        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
  	        a  = (a << 4 | a >>> 28) + b | 0;
  	        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
  	        d  = (d << 11 | d >>> 21) + a | 0;
  	        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
  	        c  = (c << 16 | c >>> 16) + d | 0;
  	        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
  	        b  = (b << 23 | b >>> 9) + c | 0;
  	        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
  	        a  = (a << 4 | a >>> 28) + b | 0;
  	        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
  	        d  = (d << 11 | d >>> 21) + a | 0;
  	        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
  	        c  = (c << 16 | c >>> 16) + d | 0;
  	        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
  	        b  = (b << 23 | b >>> 9) + c | 0;

  	        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
  	        a  = (a << 6 | a >>> 26) + b | 0;
  	        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
  	        d  = (d << 10 | d >>> 22) + a | 0;
  	        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
  	        c  = (c << 15 | c >>> 17) + d | 0;
  	        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
  	        b  = (b << 21 |b >>> 11) + c | 0;
  	        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
  	        a  = (a << 6 | a >>> 26) + b | 0;
  	        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
  	        d  = (d << 10 | d >>> 22) + a | 0;
  	        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
  	        c  = (c << 15 | c >>> 17) + d | 0;
  	        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
  	        b  = (b << 21 |b >>> 11) + c | 0;
  	        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
  	        a  = (a << 6 | a >>> 26) + b | 0;
  	        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
  	        d  = (d << 10 | d >>> 22) + a | 0;
  	        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
  	        c  = (c << 15 | c >>> 17) + d | 0;
  	        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
  	        b  = (b << 21 |b >>> 11) + c | 0;
  	        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
  	        a  = (a << 6 | a >>> 26) + b | 0;
  	        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
  	        d  = (d << 10 | d >>> 22) + a | 0;
  	        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
  	        c  = (c << 15 | c >>> 17) + d | 0;
  	        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
  	        b  = (b << 21 | b >>> 11) + c | 0;

  	        x[0] = a + x[0] | 0;
  	        x[1] = b + x[1] | 0;
  	        x[2] = c + x[2] | 0;
  	        x[3] = d + x[3] | 0;
  	    }

  	    function md5blk(s) {
  	        var md5blks = [],
  	            i; /* Andy King said do it this way. */

  	        for (i = 0; i < 64; i += 4) {
  	            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
  	        }
  	        return md5blks;
  	    }

  	    function md5blk_array(a) {
  	        var md5blks = [],
  	            i; /* Andy King said do it this way. */

  	        for (i = 0; i < 64; i += 4) {
  	            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
  	        }
  	        return md5blks;
  	    }

  	    function md51(s) {
  	        var n = s.length,
  	            state = [1732584193, -271733879, -1732584194, 271733878],
  	            i,
  	            length,
  	            tail,
  	            tmp,
  	            lo,
  	            hi;

  	        for (i = 64; i <= n; i += 64) {
  	            md5cycle(state, md5blk(s.substring(i - 64, i)));
  	        }
  	        s = s.substring(i - 64);
  	        length = s.length;
  	        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  	        for (i = 0; i < length; i += 1) {
  	            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
  	        }
  	        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
  	        if (i > 55) {
  	            md5cycle(state, tail);
  	            for (i = 0; i < 16; i += 1) {
  	                tail[i] = 0;
  	            }
  	        }

  	        // Beware that the final length might not fit in 32 bits so we take care of that
  	        tmp = n * 8;
  	        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
  	        lo = parseInt(tmp[2], 16);
  	        hi = parseInt(tmp[1], 16) || 0;

  	        tail[14] = lo;
  	        tail[15] = hi;

  	        md5cycle(state, tail);
  	        return state;
  	    }

  	    function md51_array(a) {
  	        var n = a.length,
  	            state = [1732584193, -271733879, -1732584194, 271733878],
  	            i,
  	            length,
  	            tail,
  	            tmp,
  	            lo,
  	            hi;

  	        for (i = 64; i <= n; i += 64) {
  	            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
  	        }

  	        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1
  	        // containing the last element of the parent array if the sub array specified starts
  	        // beyond the length of the parent array - weird.
  	        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue
  	        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);

  	        length = a.length;
  	        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  	        for (i = 0; i < length; i += 1) {
  	            tail[i >> 2] |= a[i] << ((i % 4) << 3);
  	        }

  	        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
  	        if (i > 55) {
  	            md5cycle(state, tail);
  	            for (i = 0; i < 16; i += 1) {
  	                tail[i] = 0;
  	            }
  	        }

  	        // Beware that the final length might not fit in 32 bits so we take care of that
  	        tmp = n * 8;
  	        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
  	        lo = parseInt(tmp[2], 16);
  	        hi = parseInt(tmp[1], 16) || 0;

  	        tail[14] = lo;
  	        tail[15] = hi;

  	        md5cycle(state, tail);

  	        return state;
  	    }

  	    function rhex(n) {
  	        var s = '',
  	            j;
  	        for (j = 0; j < 4; j += 1) {
  	            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];
  	        }
  	        return s;
  	    }

  	    function hex(x) {
  	        var i;
  	        for (i = 0; i < x.length; i += 1) {
  	            x[i] = rhex(x[i]);
  	        }
  	        return x.join('');
  	    }

  	    // In some cases the fast add32 function cannot be used..
  	    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') ;

  	    // ---------------------------------------------------

  	    /**
  	     * ArrayBuffer slice polyfill.
  	     *
  	     * @see https://github.com/ttaubert/node-arraybuffer-slice
  	     */

  	    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
  	        (function () {
  	            function clamp(val, length) {
  	                val = (val | 0) || 0;

  	                if (val < 0) {
  	                    return Math.max(val + length, 0);
  	                }

  	                return Math.min(val, length);
  	            }

  	            ArrayBuffer.prototype.slice = function (from, to) {
  	                var length = this.byteLength,
  	                    begin = clamp(from, length),
  	                    end = length,
  	                    num,
  	                    target,
  	                    targetArray,
  	                    sourceArray;

  	                if (to !== undefined$1) {
  	                    end = clamp(to, length);
  	                }

  	                if (begin > end) {
  	                    return new ArrayBuffer(0);
  	                }

  	                num = end - begin;
  	                target = new ArrayBuffer(num);
  	                targetArray = new Uint8Array(target);

  	                sourceArray = new Uint8Array(this, begin, num);
  	                targetArray.set(sourceArray);

  	                return target;
  	            };
  	        })();
  	    }

  	    // ---------------------------------------------------

  	    /**
  	     * Helpers.
  	     */

  	    function toUtf8(str) {
  	        if (/[\u0080-\uFFFF]/.test(str)) {
  	            str = unescape(encodeURIComponent(str));
  	        }

  	        return str;
  	    }

  	    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
  	        var length = str.length,
  	           buff = new ArrayBuffer(length),
  	           arr = new Uint8Array(buff),
  	           i;

  	        for (i = 0; i < length; i += 1) {
  	            arr[i] = str.charCodeAt(i);
  	        }

  	        return returnUInt8Array ? arr : buff;
  	    }

  	    function arrayBuffer2Utf8Str(buff) {
  	        return String.fromCharCode.apply(null, new Uint8Array(buff));
  	    }

  	    function concatenateArrayBuffers(first, second, returnUInt8Array) {
  	        var result = new Uint8Array(first.byteLength + second.byteLength);

  	        result.set(new Uint8Array(first));
  	        result.set(new Uint8Array(second), first.byteLength);

  	        return returnUInt8Array ? result : result.buffer;
  	    }

  	    function hexToBinaryString(hex) {
  	        var bytes = [],
  	            length = hex.length,
  	            x;

  	        for (x = 0; x < length - 1; x += 2) {
  	            bytes.push(parseInt(hex.substr(x, 2), 16));
  	        }

  	        return String.fromCharCode.apply(String, bytes);
  	    }

  	    // ---------------------------------------------------

  	    /**
  	     * SparkMD5 OOP implementation.
  	     *
  	     * Use this class to perform an incremental md5, otherwise use the
  	     * static methods instead.
  	     */

  	    function SparkMD5() {
  	        // call reset to init the instance
  	        this.reset();
  	    }

  	    /**
  	     * Appends a string.
  	     * A conversion will be applied if an utf8 string is detected.
  	     *
  	     * @param {String} str The string to be appended
  	     *
  	     * @return {SparkMD5} The instance itself
  	     */
  	    SparkMD5.prototype.append = function (str) {
  	        // Converts the string to utf8 bytes if necessary
  	        // Then append as binary
  	        this.appendBinary(toUtf8(str));

  	        return this;
  	    };

  	    /**
  	     * Appends a binary string.
  	     *
  	     * @param {String} contents The binary string to be appended
  	     *
  	     * @return {SparkMD5} The instance itself
  	     */
  	    SparkMD5.prototype.appendBinary = function (contents) {
  	        this._buff += contents;
  	        this._length += contents.length;

  	        var length = this._buff.length,
  	            i;

  	        for (i = 64; i <= length; i += 64) {
  	            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
  	        }

  	        this._buff = this._buff.substring(i - 64);

  	        return this;
  	    };

  	    /**
  	     * Finishes the incremental computation, reseting the internal state and
  	     * returning the result.
  	     *
  	     * @param {Boolean} raw True to get the raw string, false to get the hex string
  	     *
  	     * @return {String} The result
  	     */
  	    SparkMD5.prototype.end = function (raw) {
  	        var buff = this._buff,
  	            length = buff.length,
  	            i,
  	            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  	            ret;

  	        for (i = 0; i < length; i += 1) {
  	            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);
  	        }

  	        this._finish(tail, length);
  	        ret = hex(this._hash);

  	        if (raw) {
  	            ret = hexToBinaryString(ret);
  	        }

  	        this.reset();

  	        return ret;
  	    };

  	    /**
  	     * Resets the internal state of the computation.
  	     *
  	     * @return {SparkMD5} The instance itself
  	     */
  	    SparkMD5.prototype.reset = function () {
  	        this._buff = '';
  	        this._length = 0;
  	        this._hash = [1732584193, -271733879, -1732584194, 271733878];

  	        return this;
  	    };

  	    /**
  	     * Gets the internal state of the computation.
  	     *
  	     * @return {Object} The state
  	     */
  	    SparkMD5.prototype.getState = function () {
  	        return {
  	            buff: this._buff,
  	            length: this._length,
  	            hash: this._hash.slice()
  	        };
  	    };

  	    /**
  	     * Gets the internal state of the computation.
  	     *
  	     * @param {Object} state The state
  	     *
  	     * @return {SparkMD5} The instance itself
  	     */
  	    SparkMD5.prototype.setState = function (state) {
  	        this._buff = state.buff;
  	        this._length = state.length;
  	        this._hash = state.hash;

  	        return this;
  	    };

  	    /**
  	     * Releases memory used by the incremental buffer and other additional
  	     * resources. If you plan to use the instance again, use reset instead.
  	     */
  	    SparkMD5.prototype.destroy = function () {
  	        delete this._hash;
  	        delete this._buff;
  	        delete this._length;
  	    };

  	    /**
  	     * Finish the final calculation based on the tail.
  	     *
  	     * @param {Array}  tail   The tail (will be modified)
  	     * @param {Number} length The length of the remaining buffer
  	     */
  	    SparkMD5.prototype._finish = function (tail, length) {
  	        var i = length,
  	            tmp,
  	            lo,
  	            hi;

  	        tail[i >> 2] |= 0x80 << ((i % 4) << 3);
  	        if (i > 55) {
  	            md5cycle(this._hash, tail);
  	            for (i = 0; i < 16; i += 1) {
  	                tail[i] = 0;
  	            }
  	        }

  	        // Do the final computation based on the tail and length
  	        // Beware that the final length may not fit in 32 bits so we take care of that
  	        tmp = this._length * 8;
  	        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
  	        lo = parseInt(tmp[2], 16);
  	        hi = parseInt(tmp[1], 16) || 0;

  	        tail[14] = lo;
  	        tail[15] = hi;
  	        md5cycle(this._hash, tail);
  	    };

  	    /**
  	     * Performs the md5 hash on a string.
  	     * A conversion will be applied if utf8 string is detected.
  	     *
  	     * @param {String}  str The string
  	     * @param {Boolean} [raw] True to get the raw string, false to get the hex string
  	     *
  	     * @return {String} The result
  	     */
  	    SparkMD5.hash = function (str, raw) {
  	        // Converts the string to utf8 bytes if necessary
  	        // Then compute it using the binary function
  	        return SparkMD5.hashBinary(toUtf8(str), raw);
  	    };

  	    /**
  	     * Performs the md5 hash on a binary string.
  	     *
  	     * @param {String}  content The binary string
  	     * @param {Boolean} [raw]     True to get the raw string, false to get the hex string
  	     *
  	     * @return {String} The result
  	     */
  	    SparkMD5.hashBinary = function (content, raw) {
  	        var hash = md51(content),
  	            ret = hex(hash);

  	        return raw ? hexToBinaryString(ret) : ret;
  	    };

  	    // ---------------------------------------------------

  	    /**
  	     * SparkMD5 OOP implementation for array buffers.
  	     *
  	     * Use this class to perform an incremental md5 ONLY for array buffers.
  	     */
  	    SparkMD5.ArrayBuffer = function () {
  	        // call reset to init the instance
  	        this.reset();
  	    };

  	    /**
  	     * Appends an array buffer.
  	     *
  	     * @param {ArrayBuffer} arr The array to be appended
  	     *
  	     * @return {SparkMD5.ArrayBuffer} The instance itself
  	     */
  	    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
  	        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
  	            length = buff.length,
  	            i;

  	        this._length += arr.byteLength;

  	        for (i = 64; i <= length; i += 64) {
  	            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
  	        }

  	        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);

  	        return this;
  	    };

  	    /**
  	     * Finishes the incremental computation, reseting the internal state and
  	     * returning the result.
  	     *
  	     * @param {Boolean} raw True to get the raw string, false to get the hex string
  	     *
  	     * @return {String} The result
  	     */
  	    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
  	        var buff = this._buff,
  	            length = buff.length,
  	            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  	            i,
  	            ret;

  	        for (i = 0; i < length; i += 1) {
  	            tail[i >> 2] |= buff[i] << ((i % 4) << 3);
  	        }

  	        this._finish(tail, length);
  	        ret = hex(this._hash);

  	        if (raw) {
  	            ret = hexToBinaryString(ret);
  	        }

  	        this.reset();

  	        return ret;
  	    };

  	    /**
  	     * Resets the internal state of the computation.
  	     *
  	     * @return {SparkMD5.ArrayBuffer} The instance itself
  	     */
  	    SparkMD5.ArrayBuffer.prototype.reset = function () {
  	        this._buff = new Uint8Array(0);
  	        this._length = 0;
  	        this._hash = [1732584193, -271733879, -1732584194, 271733878];

  	        return this;
  	    };

  	    /**
  	     * Gets the internal state of the computation.
  	     *
  	     * @return {Object} The state
  	     */
  	    SparkMD5.ArrayBuffer.prototype.getState = function () {
  	        var state = SparkMD5.prototype.getState.call(this);

  	        // Convert buffer to a string
  	        state.buff = arrayBuffer2Utf8Str(state.buff);

  	        return state;
  	    };

  	    /**
  	     * Gets the internal state of the computation.
  	     *
  	     * @param {Object} state The state
  	     *
  	     * @return {SparkMD5.ArrayBuffer} The instance itself
  	     */
  	    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
  	        // Convert string to buffer
  	        state.buff = utf8Str2ArrayBuffer(state.buff, true);

  	        return SparkMD5.prototype.setState.call(this, state);
  	    };

  	    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;

  	    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;

  	    /**
  	     * Performs the md5 hash on an array buffer.
  	     *
  	     * @param {ArrayBuffer} arr The array buffer
  	     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one
  	     *
  	     * @return {String} The result
  	     */
  	    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
  	        var hash = md51_array(new Uint8Array(arr)),
  	            ret = hex(hash);

  	        return raw ? hexToBinaryString(ret) : ret;
  	    };

  	    return SparkMD5;
  	})); 
  } (sparkMd5));

  var sparkMd5Exports = sparkMd5.exports;
  var Md5 = /*@__PURE__*/getDefaultExportFromCjs(sparkMd5Exports);

  // ----------------------------------------------------------------------------

  const SET_GET_FIELDS = ['lastShaderProgramBound', 'context', '_openGLRenderWindow'];

  // ----------------------------------------------------------------------------
  // vtkShaderCache methods
  // ----------------------------------------------------------------------------

  function vtkShaderCache(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkShaderCache');
    publicAPI.replaceShaderValues = (VSSource, FSSource, GSSource) => {
      // first handle renaming any Fragment shader inputs
      // if we have a geometry shader. By default fragment shaders
      // assume their inputs come from a Vertex Shader. When we
      // have a Geometry shader we rename the frament shader inputs
      // to come from the geometry shader

      let nFSSource = FSSource;
      if (GSSource.length > 0) {
        nFSSource = vtkShaderProgram$1.substitute(nFSSource, 'VSOut', 'GSOut').result;
      }
      const gl2 = model._openGLRenderWindow.getWebgl2();
      let fragDepthString = '\n';
      let version = '#version 100\n';
      if (gl2) {
        version = '#version 300 es\n' + '#define attribute in\n' + '#define textureCube texture\n' + '#define texture2D texture\n' + '#define textureCubeLod textureLod\n' + '#define texture2DLod textureLod\n';
      } else {
        model.context.getExtension('OES_standard_derivatives');
        if (model.context.getExtension('EXT_frag_depth')) {
          fragDepthString = '#extension GL_EXT_frag_depth : enable\n';
        }
        if (model.context.getExtension('EXT_shader_texture_lod')) {
          fragDepthString += '#extension GL_EXT_shader_texture_lod : enable\n' + '#define textureCubeLod textureCubeLodEXT\n' + '#define texture2DLod texture2DLodEXT';
        }
      }
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, '//VTK::System::Dec', [`${version}\n`, gl2 ? '' : '#extension GL_OES_standard_derivatives : enable\n', fragDepthString, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;
      let nVSSource = vtkShaderProgram$1.substitute(VSSource, '//VTK::System::Dec', [`${version}\n`, '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', 'precision highp int;', '#else', 'precision mediump float;', 'precision mediump int;', '#endif']).result;
      if (gl2) {
        nVSSource = vtkShaderProgram$1.substitute(nVSSource, 'varying', 'out').result;
        nFSSource = vtkShaderProgram$1.substitute(nFSSource, 'varying', 'in').result;
        let shaderOutputs = '';
        let outputCount = 0;
        while (nFSSource.includes(`gl_FragData[${outputCount}]`)) {
          nFSSource = vtkShaderProgram$1.substitute(nFSSource, `gl_FragData\\[${outputCount}\\]`, `fragOutput${outputCount}`).result;
          shaderOutputs += `layout(location = ${outputCount}) out vec4 fragOutput${outputCount};\n`;
          outputCount++;
        }
        nFSSource = vtkShaderProgram$1.substitute(nFSSource, '//VTK::Output::Dec', shaderOutputs).result;
      }

      // nFSSource = ShaderProgram.substitute(nFSSource, 'gl_FragData\\[0\\]',
      //   'gl_FragColor').result;

      const nGSSource = vtkShaderProgram$1.substitute(GSSource, '//VTK::System::Dec', version).result;
      return {
        VSSource: nVSSource,
        FSSource: nFSSource,
        GSSource: nGSSource
      };
    };

    // return NULL if there is an issue
    publicAPI.readyShaderProgramArray = (vertexCode, fragmentCode, geometryCode) => {
      const data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);
      const shaderProgram = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);
      return publicAPI.readyShaderProgram(shaderProgram);
    };
    publicAPI.readyShaderProgram = program => {
      if (!program) {
        return null;
      }

      // compile if needed
      if (!program.getCompiled() && !program.compileShader()) {
        return null;
      }

      // bind if needed
      if (!publicAPI.bindShaderProgram(program)) {
        return null;
      }
      return program;
    };
    publicAPI.getShaderProgram = (vertexCode, fragmentCode, geometryCode) => {
      // compute the MD5 and the check the map
      const hashInput = `${vertexCode}${fragmentCode}${geometryCode}`;
      const result = Md5.hash(hashInput);

      // does it already exist?
      if (!(result in model.shaderPrograms)) {
        // create one
        const sps = vtkShaderProgram$1.newInstance();
        sps.setContext(model.context);
        sps.getVertexShader().setSource(vertexCode);
        sps.getFragmentShader().setSource(fragmentCode);
        if (geometryCode) {
          sps.getGeometryShader().setSource(geometryCode);
        }
        sps.setMd5Hash(result);
        model.shaderPrograms[result] = sps;
        return sps;
      }
      return model.shaderPrograms[result];
    };
    publicAPI.releaseGraphicsResources = win => {
      // NOTE:
      // In the current implementation as of October 26th, if a shader
      // program is created by ShaderCache then it should make sure
      // that it releases the graphics resources used by these programs.
      // It is not wisely for callers to do that since then they would
      // have to loop over all the programs were in use and invoke
      // release graphics resources individually.

      publicAPI.releaseCurrentShaderProgram();
      Object.keys(model.shaderPrograms).map(key => model.shaderPrograms[key]).forEach(sp => sp.cleanup());
      model.shaderPrograms = {};
    };
    publicAPI.releaseCurrentShaderProgram = () => {
      // release prior shader
      if (model.lastShaderProgramBound) {
        model.lastShaderProgramBound.cleanup();
        model.lastShaderProgramBound = null;
      }
    };
    publicAPI.bindShaderProgram = program => {
      if (model.lastShaderProgramBound === program) {
        return 1;
      }

      // release prior program
      if (model.lastShaderProgramBound) {
        model.lastShaderProgramBound.release();
      }
      program.bind();
      model.lastShaderProgramBound = program;
      return 1;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$g = {
    lastShaderProgramBound: null,
    shaderPrograms: null,
    context: null
    // _openGLRenderWindow: null,
  };

  // ----------------------------------------------------------------------------

  function extend$g(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$g, initialValues);

    // Internal objects
    model.shaderPrograms = {};

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, SET_GET_FIELDS);
    macro.moveToProtected(publicAPI, model, ['openGLRenderWindow']);

    // Object methods
    vtkShaderCache(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$g = macro.newInstance(extend$g, 'vtkShaderCache');

  // ----------------------------------------------------------------------------

  var vtkShaderCache$1 = {
    newInstance: newInstance$g,
    extend: extend$g
  };

  const {
    vtkErrorMacro: vtkErrorMacro$6
  } = macro;

  // ----------------------------------------------------------------------------
  // vtkOpenGLTextureUnitManager methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLTextureUnitManager(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLTextureUnitManager');

    // ----------------------------------------------------------------------------
    // Description:
    // Delete the allocation table and check if it is not called before
    // all the texture units have been released.
    publicAPI.deleteTable = () => {
      for (let i = 0; i < model.numberOfTextureUnits; ++i) {
        if (model.textureUnits[i] === true) {
          vtkErrorMacro$6('some texture units  were not properly released');
        }
      }
      model.textureUnits = [];
      model.numberOfTextureUnits = 0;
    };

    // ----------------------------------------------------------------------------
    publicAPI.setContext = ctx => {
      if (model.context !== ctx) {
        if (model.context !== 0) {
          publicAPI.deleteTable();
        }
        model.context = ctx;
        if (model.context) {
          model.numberOfTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
          for (let i = 0; i < model.numberOfTextureUnits; ++i) {
            model.textureUnits[i] = false;
          }
        }
        publicAPI.modified();
      }
    };

    // ----------------------------------------------------------------------------
    // Description:
    // Reserve a texture unit. It returns its number.
    // It returns -1 if the allocation failed (because there are no more
    // texture units left).
    // \post valid_result: result==-1 || result>=0 && result<this->GetNumberOfTextureUnits())
    // \post allocated: result==-1 || this->IsAllocated(result)
    publicAPI.allocate = () => {
      for (let i = 0; i < model.numberOfTextureUnits; i++) {
        if (!publicAPI.isAllocated(i)) {
          model.textureUnits[i] = true;
          return i;
        }
      }
      return -1;
    };
    publicAPI.allocateUnit = unit => {
      if (publicAPI.isAllocated(unit)) {
        return -1;
      }
      model.textureUnits[unit] = true;
      return unit;
    };

    // ----------------------------------------------------------------------------
    // Description:
    // Tell if texture unit `textureUnitId' is already allocated.
    // \pre valid_id_range : textureUnitId>=0 && textureUnitId<this->GetNumberOfTextureUnits()
    publicAPI.isAllocated = textureUnitId => model.textureUnits[textureUnitId];

    // ----------------------------------------------------------------------------
    // Description:
    // Release a texture unit.
    // \pre valid_id: textureUnitId>=0 && textureUnitId<this->GetNumberOfTextureUnits()
    // \pre allocated_id: this->IsAllocated(textureUnitId)
    publicAPI.free = val => {
      model.textureUnits[val] = false;
    };
    publicAPI.freeAll = () => {
      for (let i = 0; i < model.numberOfTextureUnits; ++i) {
        model.textureUnits[i] = false;
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$f = {
    context: null,
    numberOfTextureUnits: 0,
    textureUnits: 0
  };

  // ----------------------------------------------------------------------------

  function extend$f(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$f, initialValues);
    macro.obj(publicAPI, model);
    model.textureUnits = [];

    // Build VTK API
    macro.get(publicAPI, model, ['numberOfTextureUnits']);
    macro.setGet(publicAPI, model, ['context']);

    // Object methods
    vtkOpenGLTextureUnitManager(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$f = macro.newInstance(extend$f, 'vtkOpenGLTextureUnitManager');

  // ----------------------------------------------------------------------------

  var vtkTextureUnitManager = {
    newInstance: newInstance$f,
    extend: extend$f
  };

  // ----------------------------------------------------------------------------
  // vtkRenderWindowViewNode is intended to be a superclass for all api specific
  // RenderWindows. It is intended to define a common API that can be invoked
  // upon an api specific render window and provide some common method
  // implementations. If your application requires communicating with an api specific
  // view try to limit such interactions to methods defined in this class.
  // ----------------------------------------------------------------------------

  // ----------------------------------------------------------------------------
  // vtkRenderWindowViewNode methods
  // ----------------------------------------------------------------------------

  function vtkRenderWindowViewNode(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkRenderWindowViewNode');
    publicAPI.getViewNodeFactory = () => null;
    publicAPI.getAspectRatio = () => model.size[0] / model.size[1];
    publicAPI.getAspectRatioForRenderer = renderer => {
      const viewport = renderer.getViewportByReference();
      return model.size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * model.size[1]);
    };
    publicAPI.isInViewport = (x, y, viewport) => {
      const vCoords = viewport.getViewportByReference();
      const size = publicAPI.getFramebufferSize();
      if (vCoords[0] * size[0] <= x && vCoords[2] * size[0] >= x && vCoords[1] * size[1] <= y && vCoords[3] * size[1] >= y) {
        return true;
      }
      return false;
    };
    publicAPI.getViewportSize = viewport => {
      const vCoords = viewport.getViewportByReference();
      const size = publicAPI.getFramebufferSize();
      return [(vCoords[2] - vCoords[0]) * size[0], (vCoords[3] - vCoords[1]) * size[1]];
    };
    publicAPI.getViewportCenter = viewport => {
      const size = publicAPI.getViewportSize(viewport);
      return [size[0] * 0.5, size[1] * 0.5];
    };
    publicAPI.displayToNormalizedDisplay = (x, y, z) => {
      const size = publicAPI.getFramebufferSize();
      return [x / size[0], y / size[1], z];
    };
    publicAPI.normalizedDisplayToDisplay = (x, y, z) => {
      const size = publicAPI.getFramebufferSize();
      return [x * size[0], y * size[1], z];
    };
    publicAPI.worldToView = (x, y, z, renderer) => renderer.worldToView(x, y, z);
    publicAPI.viewToWorld = (x, y, z, renderer) => renderer.viewToWorld(x, y, z);
    publicAPI.worldToDisplay = (x, y, z, renderer) => {
      const val = renderer.worldToView(x, y, z);
      const dims = publicAPI.getViewportSize(renderer);
      const val2 = renderer.viewToProjection(val[0], val[1], val[2], dims[0] / dims[1]);
      const val3 = renderer.projectionToNormalizedDisplay(val2[0], val2[1], val2[2]);
      return publicAPI.normalizedDisplayToDisplay(val3[0], val3[1], val3[2]);
    };
    publicAPI.displayToWorld = (x, y, z, renderer) => {
      const val = publicAPI.displayToNormalizedDisplay(x, y, z);
      const val2 = renderer.normalizedDisplayToProjection(val[0], val[1], val[2]);
      const dims = publicAPI.getViewportSize(renderer);
      const val3 = renderer.projectionToView(val2[0], val2[1], val2[2], dims[0] / dims[1]);
      return renderer.viewToWorld(val3[0], val3[1], val3[2]);
    };
    publicAPI.normalizedDisplayToViewport = (x, y, z, renderer) => {
      let vCoords = renderer.getViewportByReference();
      vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0.0);
      const coords = publicAPI.normalizedDisplayToDisplay(x, y, z);
      return [coords[0] - vCoords[0] - 0.5, coords[1] - vCoords[1] - 0.5, z];
    };
    publicAPI.viewportToNormalizedViewport = (x, y, z, renderer) => {
      const size = publicAPI.getViewportSize(renderer);
      if (size && size[0] !== 0 && size[1] !== 0) {
        return [x / (size[0] - 1.0), y / (size[1] - 1.0), z];
      }
      return [x, y, z];
    };
    publicAPI.normalizedViewportToViewport = (x, y, z, renderer) => {
      const size = publicAPI.getViewportSize(renderer);
      return [x * (size[0] - 1.0), y * (size[1] - 1.0), z];
    };
    publicAPI.displayToLocalDisplay = (x, y, z) => {
      const size = publicAPI.getFramebufferSize();
      return [x, size[1] - y - 1, z];
    };
    publicAPI.viewportToNormalizedDisplay = (x, y, z, renderer) => {
      let vCoords = renderer.getViewportByReference();
      vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0.0);
      const x2 = x + vCoords[0] + 0.5;
      const y2 = y + vCoords[1] + 0.5;
      return publicAPI.displayToNormalizedDisplay(x2, y2, z);
    };
    publicAPI.getComputedDevicePixelRatio = () => model.size[0] / publicAPI.getContainerSize()[0];
    publicAPI.getContainerSize = () => {
      macro.vtkErrorMacro('not implemented');
    };
    publicAPI.getPixelData = (x1, y1, x2, y2) => {
      macro.vtkErrorMacro('not implemented');
    };
    publicAPI.createSelector = () => {
      macro.vtkErrorMacro('not implemented');
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$e = {
    size: undefined,
    selector: undefined
  };

  // ----------------------------------------------------------------------------

  function extend$e(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$e, initialValues);
    if (!model.size) {
      model.size = [300, 300];
    }
    macro.getArray(publicAPI, model, ['size'], 2);
    macro.get(publicAPI, model, ['selector']);

    // Inheritance
    vtkViewNode$1.extend(publicAPI, model, initialValues);

    // Object methods
    vtkRenderWindowViewNode(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$e = macro.newInstance(extend$e, 'vtkRenderWindowViewNode');

  // ----------------------------------------------------------------------------

  var vtkRenderWindowViewNode$1 = {
    newInstance: newInstance$e,
    extend: extend$e
  };

  // This is used to access the underlying 3D context
  const GET_UNDERLYING_CONTEXT = '__getUnderlyingContext';
  function createContextProxyHandler() {
    const cache = new Map();
    const getParameterHandler = {
      apply(target, gl, args) {
        if (cache.has(args[0])) {
          return cache.get(args[0]);
        }
        return target.apply(gl, args);
      }
    };

    // only supports single-value setters
    function cachedSetterHandler(key) {
      return {
        apply(target, gl, args) {
          cache.set(key, args[0]);
          return target.apply(gl, args);
        }
      };
    }

    // When a property is accessed on the webgl context proxy,
    // it's accessed is intercepted. If the property name matches
    // any of the keys of `propHandlers`, then that handler is called
    // with the following arguments: (gl, prop, receiver, propValue)
    // - gl (WebGL2RenderingContext): the underlying webgl context
    // - propName (string): the property name
    // - receiver (Proxy): the webgl context proxy
    // - propValue (unknown): the value of `gl[propName]`

    const propHandlers = Object.create(null);

    // Sets getParameter(property) as a cached getter proxy.
    // propValue.bind(gl) is to avoid Illegal Invocation errors.
    propHandlers.getParameter = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), getParameterHandler);

    // Sets depthMask(flag) as a cached setter proxy.
    propHandlers.depthMask = (gl, prop, receiver, propValue) => new Proxy(propValue.bind(gl), cachedSetterHandler(gl.DEPTH_WRITEMASK));
    return {
      get(gl, prop, receiver) {
        if (prop === GET_UNDERLYING_CONTEXT) return () => gl;
        let value = Reflect.get(gl, prop, gl);
        if (value instanceof Function) {
          // prevents Illegal Invocation errors
          value = value.bind(gl);
        }
        const propHandler = propHandlers[prop];
        if (propHandler) {
          return propHandler(gl, prop, receiver, value);
        }
        return value;
      }
    };
  }

  const {
    vtkDebugMacro: vtkDebugMacro$1,
    vtkErrorMacro: vtkErrorMacro$5
  } = macro;
  const SCREENSHOT_PLACEHOLDER$1 = {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%'
  };
  function checkRenderTargetSupport(gl, format, type) {
    // create temporary frame buffer and texture
    const framebuffer = gl.createFramebuffer();
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, format, 2, 2, 0, format, type, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

    // check frame buffer status
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

    // clean up
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
    return status === gl.FRAMEBUFFER_COMPLETE;
  }

  // ----------------------------------------------------------------------------
  // Monitor the usage of GL context across vtkOpenGLRenderWindow instances
  // ----------------------------------------------------------------------------

  let GL_CONTEXT_COUNT = 0;
  const GL_CONTEXT_LISTENERS = [];
  function createGLContext() {
    GL_CONTEXT_COUNT++;
    GL_CONTEXT_LISTENERS.forEach(cb => cb(GL_CONTEXT_COUNT));
  }
  function deleteGLContext() {
    GL_CONTEXT_COUNT--;
    GL_CONTEXT_LISTENERS.forEach(cb => cb(GL_CONTEXT_COUNT));
  }
  function _preventDefault(e) {
    e.preventDefault();
  }

  // ----------------------------------------------------------------------------
  // vtkOpenGLRenderWindow methods
  // ----------------------------------------------------------------------------

  function vtkOpenGLRenderWindow(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkOpenGLRenderWindow');
    const cachingContextHandler = createContextProxyHandler();
    publicAPI.getViewNodeFactory = () => model.myFactory;

    // prevent default context lost handler
    model.canvas.addEventListener('webglcontextlost', _preventDefault, false);
    model.canvas.addEventListener('webglcontextrestored', publicAPI.restoreContext, false);

    // Auto update style
    const previousSize = [0, 0];
    function updateWindow() {
      // Canvas size
      if (model.renderable) {
        if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
          previousSize[0] = model.size[0];
          previousSize[1] = model.size[1];
          model.canvas.setAttribute('width', model.size[0]);
          model.canvas.setAttribute('height', model.size[1]);
        }
      }

      // ImageStream size
      if (model.viewStream) {
        // If same size that's a NoOp
        model.viewStream.setSize(model.size[0], model.size[1]);
      }

      // Offscreen ?
      model.canvas.style.display = model.useOffScreen ? 'none' : 'block';

      // Cursor type
      if (model.el) {
        model.el.style.cursor = model.cursorVisibility ? model.cursor : 'none';
      }

      // Invalidate cached DOM container size
      model.containerSize = null;
    }
    publicAPI.onModified(updateWindow);

    // Builds myself.
    publicAPI.buildPass = prepass => {
      if (prepass) {
        if (!model.renderable) {
          return;
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
        publicAPI.removeUnusedNodes();
        publicAPI.initialize();
        model.children.forEach(child => {
          child.setOpenGLRenderWindow(publicAPI);
        });
      }
    };
    publicAPI.initialize = () => {
      if (!model.initialized) {
        model.context = publicAPI.get3DContext();
        model.textureUnitManager = vtkTextureUnitManager.newInstance();
        model.textureUnitManager.setContext(model.context);
        model.shaderCache.setContext(model.context);
        // initialize blending for transparency
        const gl = model.context;
        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.depthFunc(gl.LEQUAL);
        gl.enable(gl.BLEND);
        model.initialized = true;
      }
    };
    publicAPI.makeCurrent = () => {
      model.context.makeCurrent();
    };
    publicAPI.setContainer = el => {
      if (model.el && model.el !== el) {
        if (model.canvas.parentNode !== model.el) {
          vtkErrorMacro$5('Error: canvas parent node does not match container');
        }

        // Remove canvas from previous container
        model.el.removeChild(model.canvas);

        // If the renderer has previously added
        // a background image, remove it from the DOM.
        if (model.el.contains(model.bgImage)) {
          model.el.removeChild(model.bgImage);
        }
      }
      if (model.el !== el) {
        model.el = el;
        if (model.el) {
          model.el.appendChild(model.canvas);

          // If the renderer is set to use a background
          // image, attach it to the DOM.
          if (model.useBackgroundImage) {
            model.el.appendChild(model.bgImage);
          }
        }

        // Trigger modified()
        publicAPI.modified();
      }
    };
    publicAPI.getContainer = () => model.el;
    publicAPI.getContainerSize = () => {
      if (!model.containerSize && model.el) {
        const {
          width,
          height
        } = model.el.getBoundingClientRect();
        model.containerSize = [width, height];
      }
      return model.containerSize || model.size;
    };
    publicAPI.getFramebufferSize = () => {
      if (model.activeFramebuffer) {
        return model.activeFramebuffer.getSize();
      }
      return model.size;
    };
    publicAPI.getPixelData = (x1, y1, x2, y2) => {
      const pixels = new Uint8Array((x2 - x1 + 1) * (y2 - y1 + 1) * 4);
      model.context.readPixels(x1, y1, x2 - x1 + 1, y2 - y1 + 1, model.context.RGBA, model.context.UNSIGNED_BYTE, pixels);
      return pixels;
    };
    publicAPI.get3DContext = function () {
      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        preserveDrawingBuffer: false,
        depth: true,
        alpha: true,
        powerPreference: 'high-performance'
      };
      let result = null;
      const webgl2Supported = typeof WebGL2RenderingContext !== 'undefined';
      model.webgl2 = false;
      if (model.defaultToWebgl2 && webgl2Supported) {
        result = model.canvas.getContext('webgl2', options);
        if (result) {
          model.webgl2 = true;
          vtkDebugMacro$1('using webgl2');
        }
      }
      if (!result) {
        vtkDebugMacro$1('using webgl1');
        result = model.canvas.getContext('webgl', options) || model.canvas.getContext('experimental-webgl', options);
      }
      return new Proxy(result, cachingContextHandler);
    };
    publicAPI.restoreContext = () => {
      const rp = vtkRenderPass$1.newInstance();
      rp.setCurrentOperation('Release');
      rp.traverse(publicAPI, null);
    };
    publicAPI.activateTexture = texture => {
      // Only add if it isn't already there
      const result = model._textureResourceIds.get(texture);
      if (result !== undefined) {
        model.context.activeTexture(model.context.TEXTURE0 + result);
        return;
      }
      const activeUnit = publicAPI.getTextureUnitManager().allocate();
      if (activeUnit < 0) {
        vtkErrorMacro$5('Hardware does not support the number of textures defined.');
        return;
      }
      model._textureResourceIds.set(texture, activeUnit);
      model.context.activeTexture(model.context.TEXTURE0 + activeUnit);
    };
    publicAPI.deactivateTexture = texture => {
      // Only deactivate if it isn't already there
      const result = model._textureResourceIds.get(texture);
      if (result !== undefined) {
        publicAPI.getTextureUnitManager().free(result);
        model._textureResourceIds.delete(texture);
      }
    };
    publicAPI.getTextureUnitForTexture = texture => {
      const result = model._textureResourceIds.get(texture);
      if (result !== undefined) {
        return result;
      }
      return -1;
    };
    publicAPI.getDefaultTextureByteSize = function (vtkType) {
      let oglNorm16Ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      let useHalfFloat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (model.webgl2) {
        switch (vtkType) {
          case VtkDataTypes$5.CHAR:
          case VtkDataTypes$5.SIGNED_CHAR:
          case VtkDataTypes$5.UNSIGNED_CHAR:
            return 1;
          case oglNorm16Ext:
          case useHalfFloat:
          case VtkDataTypes$5.UNSIGNED_SHORT:
          case VtkDataTypes$5.SHORT:
          case VtkDataTypes$5.VOID:
            // Used for unsigned int depth
            return 2;
          default:
            // For all other cases, assume float
            return 4;
        }
      }

      // webgl1 type support is limited to 1 byte
      return 1;
    };
    publicAPI.getDefaultTextureInternalFormat = function (vtktype, numComps) {
      let oglNorm16Ext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      let useHalfFloat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      if (model.webgl2) {
        switch (vtktype) {
          case VtkDataTypes$5.UNSIGNED_CHAR:
            switch (numComps) {
              case 1:
                return model.context.R8;
              case 2:
                return model.context.RG8;
              case 3:
                return model.context.RGB8;
              case 4:
              default:
                return model.context.RGBA8;
            }
          case oglNorm16Ext && !useHalfFloat && VtkDataTypes$5.UNSIGNED_SHORT:
            switch (numComps) {
              case 1:
                return oglNorm16Ext.R16_EXT;
              case 2:
                return oglNorm16Ext.RG16_EXT;
              case 3:
                return oglNorm16Ext.RGB16_EXT;
              case 4:
              default:
                return oglNorm16Ext.RGBA16_EXT;
            }
          // prioritize norm16 over float
          case oglNorm16Ext && !useHalfFloat && VtkDataTypes$5.SHORT:
            switch (numComps) {
              case 1:
                return oglNorm16Ext.R16_SNORM_EXT;
              case 2:
                return oglNorm16Ext.RG16_SNORM_EXT;
              case 3:
                return oglNorm16Ext.RGB16_SNORM_EXT;
              case 4:
              default:
                return oglNorm16Ext.RGBA16_SNORM_EXT;
            }
          case VtkDataTypes$5.UNSIGNED_SHORT:
          case VtkDataTypes$5.SHORT:
          case VtkDataTypes$5.FLOAT:
          default:
            // useHalfFloat tells us if the texture can be accurately
            // rendered with 16 bits or not.
            switch (numComps) {
              case 1:
                return useHalfFloat ? model.context.R16F : model.context.R32F;
              case 2:
                return useHalfFloat ? model.context.RG16F : model.context.RG32F;
              case 3:
                return useHalfFloat ? model.context.RGB16F : model.context.RGB32F;
              case 4:
              default:
                return useHalfFloat ? model.context.RGBA16F : model.context.RGBA32F;
            }
        }
      }

      // webgl1 only supports four types
      switch (numComps) {
        case 1:
          return model.context.LUMINANCE;
        case 2:
          return model.context.LUMINANCE_ALPHA;
        case 3:
          return model.context.RGB;
        case 4:
        default:
          return model.context.RGBA;
      }
    };
    publicAPI.setBackgroundImage = img => {
      model.bgImage.src = img.src;
    };
    publicAPI.setUseBackgroundImage = value => {
      model.useBackgroundImage = value;

      // Add or remove the background image from the
      // DOM as specified.
      if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
        model.el.appendChild(model.bgImage);
      } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    };
    function getCanvasDataURL() {
      let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.imageFormat;
      // Copy current canvas to not modify the original
      const temporaryCanvas = document.createElement('canvas');
      const temporaryContext = temporaryCanvas.getContext('2d');
      temporaryCanvas.width = model.canvas.width;
      temporaryCanvas.height = model.canvas.height;
      temporaryContext.drawImage(model.canvas, 0, 0);

      // Get current client rect to place canvas
      const mainBoundingClientRect = model.canvas.getBoundingClientRect();
      const renderWindow = model.renderable;
      const renderers = renderWindow.getRenderers();
      renderers.forEach(renderer => {
        const viewProps = renderer.getViewProps();
        viewProps.forEach(viewProp => {
          // Check if the prop has a container that should have canvas
          if (viewProp.getContainer) {
            const container = viewProp.getContainer();
            const canvasList = container.getElementsByTagName('canvas');
            // Go throughout all canvas and copy it into temporary main canvas
            for (let i = 0; i < canvasList.length; i++) {
              const currentCanvas = canvasList[i];
              const boundingClientRect = currentCanvas.getBoundingClientRect();
              const newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
              const newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
              temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
            }
          }
        });
      });
      const screenshot = temporaryCanvas.toDataURL(format);
      temporaryCanvas.remove();
      publicAPI.invokeImageReady(screenshot);
    }
    publicAPI.captureNextImage = function () {
      let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';
      let {
        resetCamera = false,
        size = null,
        scale = 1
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (model.deleted) {
        return null;
      }
      model.imageFormat = format;
      const previous = model.notifyStartCaptureImage;
      model.notifyStartCaptureImage = true;
      model._screenshot = {
        size: !!size || scale !== 1 ? size || model.size.map(val => val * scale) : null
      };
      return new Promise((resolve, reject) => {
        const subscription = publicAPI.onImageReady(imageURL => {
          if (model._screenshot.size === null) {
            model.notifyStartCaptureImage = previous;
            subscription.unsubscribe();
            if (model._screenshot.placeHolder) {
              // resize the main canvas back to its original size and show it
              model.size = model._screenshot.originalSize;

              // process the resize
              publicAPI.modified();

              // restore the saved camera parameters, if applicable
              if (model._screenshot.cameras) {
                model._screenshot.cameras.forEach(_ref => {
                  let {
                    restoreParamsFn,
                    arg
                  } = _ref;
                  return restoreParamsFn(arg);
                });
              }

              // Trigger a render at the original size
              publicAPI.traverseAllPasses();

              // Remove and clean up the placeholder, revealing the original
              model.el.removeChild(model._screenshot.placeHolder);
              model._screenshot.placeHolder.remove();
              model._screenshot = null;
            }
            resolve(imageURL);
          } else {
            // Create a placeholder image overlay while we resize and render
            const tmpImg = document.createElement('img');
            tmpImg.style = SCREENSHOT_PLACEHOLDER$1;
            tmpImg.src = imageURL;
            model._screenshot.placeHolder = model.el.appendChild(tmpImg);

            // hide the main canvas
            model.canvas.style.display = 'none';

            // remember the main canvas original size, then resize it
            model._screenshot.originalSize = model.size;
            model.size = model._screenshot.size;
            model._screenshot.size = null;

            // process the resize
            publicAPI.modified();
            if (resetCamera) {
              const isUserResetCamera = resetCamera !== true;

              // If resetCamera was requested, we first save camera parameters
              // from all the renderers, so we can restore them later
              model._screenshot.cameras = model.renderable.getRenderers().map(renderer => {
                const camera = renderer.getActiveCamera();
                const params = camera.get('focalPoint', 'position', 'parallelScale');
                return {
                  resetCameraArgs: isUserResetCamera ? {
                    renderer
                  } : undefined,
                  resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,
                  restoreParamsFn: camera.set,
                  // "clone" the params so we don't keep refs to properties
                  arg: JSON.parse(JSON.stringify(params))
                };
              });

              // Perform the resetCamera() on each renderer only after capturing
              // the params from all active cameras, in case there happen to be
              // linked cameras among the renderers.
              model._screenshot.cameras.forEach(_ref2 => {
                let {
                  resetCameraFn,
                  resetCameraArgs
                } = _ref2;
                return resetCameraFn(resetCameraArgs);
              });
            }

            // Trigger a render at the custom size
            publicAPI.traverseAllPasses();
          }
        });
      });
    };
    let hardwareMaximumLineWidth;
    publicAPI.getHardwareMaximumLineWidth = () => {
      // We cache the result of this function because `getParameter` is slow
      if (hardwareMaximumLineWidth != null) {
        return hardwareMaximumLineWidth;
      }
      const gl = publicAPI.get3DContext();
      const lineWidthRange = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
      hardwareMaximumLineWidth = lineWidthRange[1];
      return lineWidthRange[1];
    };
    publicAPI.getGLInformations = () => {
      if (model._glInformation) {
        return model._glInformation;
      }
      const gl = publicAPI.get3DContext();
      const glTextureFloat = gl.getExtension('OES_texture_float');
      const glTextureHalfFloat = gl.getExtension('OES_texture_half_float');
      const glDebugRendererInfo = gl.getExtension('WEBGL_debug_renderer_info');
      const glDrawBuffers = gl.getExtension('WEBGL_draw_buffers');
      const glAnisotropic = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
      const params = [['Max Vertex Attributes', 'MAX_VERTEX_ATTRIBS', gl.getParameter(gl.MAX_VERTEX_ATTRIBS)], ['Max Varying Vectors', 'MAX_VARYING_VECTORS', gl.getParameter(gl.MAX_VARYING_VECTORS)], ['Max Vertex Uniform Vectors', 'MAX_VERTEX_UNIFORM_VECTORS', gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS)], ['Max Fragment Uniform Vectors', 'MAX_FRAGMENT_UNIFORM_VECTORS', gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)], ['Max Fragment Texture Image Units', 'MAX_TEXTURE_IMAGE_UNITS', gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)], ['Max Vertex Texture Image Units', 'MAX_VERTEX_TEXTURE_IMAGE_UNITS', gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)], ['Max Combined Texture Image Units', 'MAX_COMBINED_TEXTURE_IMAGE_UNITS', gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)], ['Max 2D Texture Size', 'MAX_TEXTURE_SIZE', gl.getParameter(gl.MAX_TEXTURE_SIZE)], ['Max Cube Texture Size', 'MAX_CUBE_MAP_TEXTURE_SIZE', gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE)], ['Max Texture Anisotropy', 'MAX_TEXTURE_MAX_ANISOTROPY_EXT', glAnisotropic && gl.getParameter(glAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)], ['Point Size Range', 'ALIASED_POINT_SIZE_RANGE', gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE).join(' - ')], ['Line Width Range', 'ALIASED_LINE_WIDTH_RANGE', gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE).join(' - ')], ['Max Viewport Dimensions', 'MAX_VIEWPORT_DIMS', gl.getParameter(gl.MAX_VIEWPORT_DIMS).join(' - ')], ['Max Renderbuffer Size', 'MAX_RENDERBUFFER_SIZE', gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)], ['Framebuffer Red Bits', 'RED_BITS', gl.getParameter(gl.RED_BITS)], ['Framebuffer Green Bits', 'GREEN_BITS', gl.getParameter(gl.GREEN_BITS)], ['Framebuffer Blue Bits', 'BLUE_BITS', gl.getParameter(gl.BLUE_BITS)], ['Framebuffer Alpha Bits', 'ALPHA_BITS', gl.getParameter(gl.ALPHA_BITS)], ['Framebuffer Depth Bits', 'DEPTH_BITS', gl.getParameter(gl.DEPTH_BITS)], ['Framebuffer Stencil Bits', 'STENCIL_BITS', gl.getParameter(gl.STENCIL_BITS)], ['Framebuffer Subpixel Bits', 'SUBPIXEL_BITS', gl.getParameter(gl.SUBPIXEL_BITS)], ['MSAA Samples', 'SAMPLES', gl.getParameter(gl.SAMPLES)], ['MSAA Sample Buffers', 'SAMPLE_BUFFERS', gl.getParameter(gl.SAMPLE_BUFFERS)], ['Supported Formats for UByte Render Targets     ', 'UNSIGNED_BYTE RENDER TARGET FORMATS', [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.UNSIGNED_BYTE) ? 'RGBA' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.UNSIGNED_BYTE) ? 'RGB' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.UNSIGNED_BYTE) ? 'LUMINANCE' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.UNSIGNED_BYTE) ? 'ALPHA' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE) ? 'LUMINANCE_ALPHA' : ''].join(' ')], ['Supported Formats for Half Float Render Targets', 'HALF FLOAT RENDER TARGET FORMATS', [glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGBA, glTextureHalfFloat.HALF_FLOAT_OES) ? 'RGBA' : '', glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGB, glTextureHalfFloat.HALF_FLOAT_OES) ? 'RGB' : '', glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, glTextureHalfFloat.HALF_FLOAT_OES) ? 'LUMINANCE' : '', glTextureHalfFloat && checkRenderTargetSupport(gl, gl.ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? 'ALPHA' : '', glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? 'LUMINANCE_ALPHA' : ''].join(' ')], ['Supported Formats for Full Float Render Targets', 'FLOAT RENDER TARGET FORMATS', [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.FLOAT) ? 'RGBA' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.FLOAT) ? 'RGB' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.FLOAT) ? 'LUMINANCE' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.FLOAT) ? 'ALPHA' : '', glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.FLOAT) ? 'LUMINANCE_ALPHA' : ''].join(' ')], ['Max Multiple Render Targets Buffers', 'MAX_DRAW_BUFFERS_WEBGL', glDrawBuffers ? gl.getParameter(glDrawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 0], ['High Float Precision in Vertex Shader', 'HIGH_FLOAT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMax, '</sup>)'].join('')], ['Medium Float Precision in Vertex Shader', 'MEDIUM_FLOAT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMax, '</sup>)'].join('')], ['Low Float Precision in Vertex Shader', 'LOW_FLOAT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMax, '</sup>)'].join('')], ['High Float Precision in Fragment Shader', 'HIGH_FLOAT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMax, '</sup>)'].join('')], ['Medium Float Precision in Fragment Shader', 'MEDIUM_FLOAT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMax, '</sup>)'].join('')], ['Low Float Precision in Fragment Shader', 'LOW_FLOAT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMax, '</sup>)'].join('')], ['High Int Precision in Vertex Shader', 'HIGH_INT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMax, '</sup>)'].join('')], ['Medium Int Precision in Vertex Shader', 'MEDIUM_INT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMax, '</sup>)'].join('')], ['Low Int Precision in Vertex Shader', 'LOW_INT VERTEX_SHADER', [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMax, '</sup>)'].join('')], ['High Int Precision in Fragment Shader', 'HIGH_INT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMax, '</sup>)'].join('')], ['Medium Int Precision in Fragment Shader', 'MEDIUM_INT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMax, '</sup>)'].join('')], ['Low Int Precision in Fragment Shader', 'LOW_INT FRAGMENT_SHADER', [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).precision, ' (-2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMin, '</sup> - 2<sup>', gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMax, '</sup>)'].join('')], ['Supported Extensions', 'EXTENSIONS', gl.getSupportedExtensions().join('<br/>\t\t\t\t\t    ')], ['WebGL Renderer', 'RENDERER', gl.getParameter(gl.RENDERER)], ['WebGL Vendor', 'VENDOR', gl.getParameter(gl.VENDOR)], ['WebGL Version', 'VERSION', gl.getParameter(gl.VERSION)], ['Shading Language Version', 'SHADING_LANGUAGE_VERSION', gl.getParameter(gl.SHADING_LANGUAGE_VERSION)], ['Unmasked Renderer', 'UNMASKED_RENDERER', glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_RENDERER_WEBGL)], ['Unmasked Vendor', 'UNMASKED_VENDOR', glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_VENDOR_WEBGL)], ['WebGL Version', 'WEBGL_VERSION', model.webgl2 ? 2 : 1]];
      const result = {};
      while (params.length) {
        const [label, key, value] = params.pop();
        if (key) {
          result[key] = {
            label,
            value
          };
        }
      }
      model._glInformation = result;
      return result;
    };
    publicAPI.traverseAllPasses = () => {
      if (model.renderPasses) {
        for (let index = 0; index < model.renderPasses.length; ++index) {
          model.renderPasses[index].traverse(publicAPI, null);
        }
      }
      if (model.notifyStartCaptureImage) {
        getCanvasDataURL();
      }
    };
    publicAPI.disableCullFace = () => {
      if (model.cullFaceEnabled) {
        model.context.disable(model.context.CULL_FACE);
        model.cullFaceEnabled = false;
      }
    };
    publicAPI.enableCullFace = () => {
      if (!model.cullFaceEnabled) {
        model.context.enable(model.context.CULL_FACE);
        model.cullFaceEnabled = true;
      }
    };
    publicAPI.setViewStream = stream => {
      if (model.viewStream === stream) {
        return false;
      }
      if (model.subscription) {
        model.subscription.unsubscribe();
        model.subscription = null;
      }
      model.viewStream = stream;
      if (model.viewStream) {
        // Force background to be transparent + render
        const mainRenderer = model.renderable.getRenderers()[0];
        mainRenderer.getBackgroundByReference()[3] = 0;

        // Enable display of the background image
        publicAPI.setUseBackgroundImage(true);

        // Bind to remote stream
        model.subscription = model.viewStream.onImageReady(e => publicAPI.setBackgroundImage(e.image));
        model.viewStream.setSize(model.size[0], model.size[1]);
        model.viewStream.invalidateCache();
        model.viewStream.render();
        publicAPI.modified();
      }
      return true;
    };
    publicAPI.createSelector = () => {
      const ret = vtkHardwareSelector.newInstance();
      ret.setOpenGLRenderWindow(publicAPI);
      return ret;
    };
    function clearEvents() {
      model.canvas.removeEventListener('webglcontextlost', _preventDefault);
      model.canvas.removeEventListener('webglcontextrestored', publicAPI.restoreContext);
    }
    publicAPI.delete = macro.chain(clearEvents, publicAPI.delete, publicAPI.setViewStream, deleteGLContext);

    // Do not trigger modified for performance reasons
    publicAPI.setActiveFramebuffer = newActiveFramebuffer => {
      model.activeFramebuffer = newActiveFramebuffer;
    };
    const superSetSize = publicAPI.setSize;
    publicAPI.setSize = (width, height) => {
      const modified = superSetSize(width, height);
      if (modified) {
        publicAPI.invokeWindowResizeEvent({
          width,
          height
        });
      }
      return modified;
    };
    publicAPI.getGraphicsResourceForObject = vtkObj => {
      if (!vtkObj) {
        return null;
      }
      const vtko = model._graphicsResources.get(vtkObj);
      const vtkh = model._graphicsResourceHash.get(vtkObj);
      return {
        vtkObj: vtko,
        hash: vtkh
      };
    };
    publicAPI.setGraphicsResourceForObject = (vtkObj, gObj, hash) => {
      if (!vtkObj) {
        return;
      }
      model._graphicsResources.set(vtkObj, gObj);
      model._graphicsResourceHash.set(vtkObj, hash);
    };
    publicAPI.getGraphicsMemoryInfo = () => {
      let memUsed = 0;
      model._graphicsResources.forEach((gObj, vtkObj) => {
        memUsed += gObj.getAllocatedGPUMemoryInBytes();
      });
      return memUsed;
    };
    publicAPI.releaseGraphicsResourcesForObject = vtkObj => {
      if (!vtkObj) {
        return false;
      }
      model._graphicsResources.get(vtkObj)?.releaseGraphicsResources(publicAPI);
      return model._graphicsResources.delete(vtkObj) && model._graphicsResourceHash.delete(vtkObj);
    };
    publicAPI.releaseGraphicsResources = () => {
      // Clear the shader cache
      if (model.shaderCache !== null) {
        model.shaderCache.releaseGraphicsResources(publicAPI);
      }
      // Free cached graphics resources at the context level
      model._graphicsResources.forEach((gObj, vtkObj) => {
        gObj.releaseGraphicsResources(publicAPI);
      });
      model._graphicsResources.clear();
      model._graphicsResourceHash.clear();
      if (model.textureUnitManager !== null) {
        model.textureUnitManager.freeAll();
      }
      // Finally, ask the renderers to release prop resources
      model.renderable.getRenderersByReference().forEach(ren => {
        const glRen = publicAPI.getViewNodeFor(ren);
        glRen?.releaseGraphicsResources();
      });
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$d = {
    cullFaceEnabled: false,
    shaderCache: null,
    initialized: false,
    context: null,
    canvas: null,
    cursorVisibility: true,
    cursor: 'pointer',
    textureUnitManager: null,
    textureResourceIds: null,
    containerSize: null,
    renderPasses: [],
    notifyStartCaptureImage: false,
    webgl2: false,
    defaultToWebgl2: true,
    // attempt webgl2 on by default
    activeFramebuffer: null,
    imageFormat: 'image/png',
    useOffScreen: false,
    useBackgroundImage: false
  };

  // ----------------------------------------------------------------------------

  function extend$d(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$d, initialValues);

    // Inheritance
    vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);

    // Create internal instances
    model.canvas = document.createElement('canvas');
    model.canvas.style.width = '100%';
    createGLContext();
    if (!model.selector) {
      model.selector = vtkHardwareSelector.newInstance();
      model.selector.setOpenGLRenderWindow(publicAPI);
    }

    // Create internal bgImage
    model.bgImage = new Image();
    model.bgImage.style.position = 'absolute';
    model.bgImage.style.left = '0';
    model.bgImage.style.top = '0';
    model.bgImage.style.width = '100%';
    model.bgImage.style.height = '100%';
    model.bgImage.style.zIndex = '-1';
    model._textureResourceIds = new Map();
    model._graphicsResources = new Map();
    model._graphicsResourceHash = new Map();
    model._glInformation = null;
    model.myFactory = vtkViewNodeFactory.newInstance();
    /* eslint-disable no-use-before-define */
    model.myFactory.registerOverride('vtkRenderWindow', newInstance$d);
    /* eslint-enable no-use-before-define */

    model.shaderCache = vtkShaderCache$1.newInstance();
    model.shaderCache.setOpenGLRenderWindow(publicAPI);

    // setup default forward pass rendering
    model.renderPasses[0] = vtkForwardPass$1$1.newInstance();
    macro.event(publicAPI, model, 'imageReady');

    // Build VTK API
    macro.get(publicAPI, model, ['shaderCache', 'textureUnitManager', 'webgl2', 'useBackgroundImage', 'activeFramebuffer']);
    macro.setGet(publicAPI, model, ['initialized', 'context', 'canvas', 'renderPasses', 'notifyStartCaptureImage', 'defaultToWebgl2', 'cursor', 'useOffScreen']);
    macro.setGetArray(publicAPI, model, ['size'], 2);
    macro.event(publicAPI, model, 'windowResizeEvent');

    // Object methods
    vtkOpenGLRenderWindow(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$d = macro.newInstance(extend$d, 'vtkOpenGLRenderWindow');

  // ----------------------------------------------------------------------------
  // Register API specific RenderWindow implementation
  // ----------------------------------------------------------------------------

  registerViewConstructor('WebGL', newInstance$d);

  // methods we forward to the handle
  const forwarded = ['setBindGroup', 'setIndexBuffer', 'setVertexBuffer', 'draw', 'drawIndexed'];

  // ----------------------------------------------------------------------------
  // vtkWebGPURenderEncoder methods
  // ----------------------------------------------------------------------------
  function vtkWebGPURenderEncoder(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPURenderEncoder');
    publicAPI.begin = encoder => {
      model.drawCallbacks = [];
      model.handle = encoder.beginRenderPass(model.description);
      if (model.label) {
        model.handle.pushDebugGroup(model.label);
      }
    };
    publicAPI.end = () => {
      // loop over registered pipelines and their callbacks
      for (let i = 0; i < model.drawCallbacks.length; i++) {
        const pStruct = model.drawCallbacks[i];
        const pl = pStruct.pipeline;
        publicAPI.setPipeline(pl);
        for (let cb = 0; cb < pStruct.callbacks.length; cb++) {
          pStruct.callbacks[cb](publicAPI);
        }
      }
      if (model.label) {
        model.handle.popDebugGroup();
      }
      model.handle.end();
      model.boundPipeline = null;
    };
    publicAPI.setPipeline = pl => {
      if (model.boundPipeline === pl) {
        return;
      }
      model.handle.setPipeline(pl.getHandle());
      const pd = pl.getPipelineDescription();

      // check attachment state
      if (model.colorTextureViews.length !== pd.fragment.targets.length) {
        console.log(`mismatched attachment counts on pipeline ${pd.fragment.targets.length} while encoder has ${model.colorTextureViews.length}`);
        console.trace();
      } else {
        for (let i = 0; i < model.colorTextureViews.length; i++) {
          const fmt = model.colorTextureViews[i].getTexture()?.getFormat();
          if (fmt && fmt !== pd.fragment.targets[i].format) {
            console.log(`mismatched attachments for attachment ${i} on pipeline ${pd.fragment.targets[i].format} while encoder has ${fmt}`);
            console.trace();
          }
        }
      }

      // check depth buffer
      if (!model.depthTextureView !== !('depthStencil' in pd)) {
        console.log('mismatched depth attachments');
        console.trace();
      } else if (model.depthTextureView) {
        const dfmt = model.depthTextureView.getTexture()?.getFormat();
        if (dfmt && dfmt !== pd.depthStencil.format) {
          console.log(`mismatched depth attachments on pipeline ${pd.depthStencil.format} while encoder has ${dfmt}`);
          console.trace();
        }
      }
      model.boundPipeline = pl;
    };
    publicAPI.replaceShaderCode = pipeline => {
      model.replaceShaderCodeFunction(pipeline);
    };
    publicAPI.setColorTextureView = (idx, view) => {
      if (model.colorTextureViews[idx] === view) {
        return;
      }
      model.colorTextureViews[idx] = view;
    };
    publicAPI.activateBindGroup = bg => {
      const device = model.boundPipeline.getDevice();
      const midx = model.boundPipeline.getBindGroupLayoutCount(bg.getLabel());
      model.handle.setBindGroup(midx, bg.getBindGroup(device));
      // verify bind group layout matches
      const bgl1 = device.getBindGroupLayoutDescription(bg.getBindGroupLayout(device));
      const bgl2 = device.getBindGroupLayoutDescription(model.boundPipeline.getBindGroupLayout(midx));
      if (bgl1 !== bgl2) {
        console.log(`renderEncoder ${model.pipelineHash} mismatched bind group layouts bind group has\n${bgl1}\n versus pipeline\n${bgl2}\n`);
        console.trace();
      }
    };
    publicAPI.attachTextureViews = () => {
      // for each texture create a view if we do not already have one
      for (let i = 0; i < model.colorTextureViews.length; i++) {
        if (!model.description.colorAttachments[i]) {
          model.description.colorAttachments[i] = {
            view: model.colorTextureViews[i].getHandle()
          };
        } else {
          model.description.colorAttachments[i].view = model.colorTextureViews[i].getHandle();
        }
      }
      if (model.depthTextureView) {
        model.description.depthStencilAttachment.view = model.depthTextureView.getHandle();
      }
    };

    // register pipeline callbacks from a mapper
    publicAPI.registerDrawCallback = (pipeline, cb) => {
      // if there is a matching pipeline just add the cb
      for (let i = 0; i < model.drawCallbacks.length; i++) {
        if (model.drawCallbacks[i].pipeline === pipeline) {
          model.drawCallbacks[i].callbacks.push(cb);
          return;
        }
      }
      model.drawCallbacks.push({
        pipeline,
        callbacks: [cb]
      });
    };

    // simple forwarders
    for (let i = 0; i < forwarded.length; i++) {
      publicAPI[forwarded[i]] = function () {
        return model.handle[forwarded[i]](...arguments);
      };
    }
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------
  const DEFAULT_VALUES$c = {
    description: null,
    handle: null,
    boundPipeline: null,
    pipelineHash: null,
    pipelineSettings: null,
    replaceShaderCodeFunction: null,
    depthTextureView: null,
    label: null
  };

  // ----------------------------------------------------------------------------
  function extend$c(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$c, initialValues);

    // Build VTK API
    obj(publicAPI, model);
    model.description = {
      colorAttachments: [{
        view: undefined,
        loadOp: 'load',
        storeOp: 'store'
      }],
      depthStencilAttachment: {
        view: undefined,
        depthLoadOp: 'clear',
        depthClearValue: 0.0,
        depthStoreOp: 'store'
      }
    };

    // default shader code just writes out the computedColor
    model.replaceShaderCodeFunction = pipeline => {
      const fDesc = pipeline.getShaderDescription('fragment');
      fDesc.addOutput('vec4<f32>', 'outColor');
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::RenderEncoder::Impl', ['output.outColor = computedColor;']).result;
      fDesc.setCode(code);
    };

    // default pipeline settings
    model.pipelineSettings = {
      primitive: {
        cullMode: 'none'
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: 'greater-equal',
        format: 'depth32float'
      },
      fragment: {
        targets: [{
          format: 'rgba16float',
          blend: {
            color: {
              srcFactor: 'src-alpha',
              dstFactor: 'one-minus-src-alpha'
            },
            alpha: {
              srcfactor: 'one',
              dstFactor: 'one-minus-src-alpha'
            }
          }
        }]
      }
    };
    model.colorTextureViews = [];
    get$1(publicAPI, model, ['boundPipeline', 'colorTextureViews']);
    setGet(publicAPI, model, ['depthTextureView', 'description', 'handle', 'label', 'pipelineHash', 'pipelineSettings', 'replaceShaderCodeFunction']);

    // For more macro methods, see "Sources/macros.js"
    // Object specific methods
    vtkWebGPURenderEncoder(publicAPI, model);
  }

  // ----------------------------------------------------------------------------
  const newInstance$c = newInstance$1I(extend$c, 'vtkWebGPURenderEncoder');

  // ----------------------------------------------------------------------------
  var vtkWebGPURenderEncoder$1 = {
    newInstance: newInstance$c,
    extend: extend$c
  };

  // ----------------------------------------------------------------------------

  function vtkWebGPUOpaquePass(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUOpaquePass');

    // this pass implements a forward rendering pipeline
    // if both volumes and opaque geometry are present
    // it will mix the two together by capturing a zbuffer
    // first
    publicAPI.traverse = (renNode, viewNode) => {
      if (model.deleted) {
        return;
      }

      // we just render our delegates in order
      model._currentParent = viewNode;
      const device = viewNode.getDevice();
      if (!model.renderEncoder) {
        publicAPI.createRenderEncoder();
        model.colorTexture = vtkWebGPUTexture$1.newInstance({
          label: 'opaquePassColor'
        });
        model.colorTexture.create(device, {
          width: viewNode.getCanvas().width,
          height: viewNode.getCanvas().height,
          format: 'rgba16float',
          /* eslint-disable no-undef */
          /* eslint-disable no-bitwise */
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
        });
        const ctView = model.colorTexture.createView('opaquePassColorTexture');
        model.renderEncoder.setColorTextureView(0, ctView);
        model.depthFormat = 'depth32float';
        model.depthTexture = vtkWebGPUTexture$1.newInstance({
          label: 'opaquePassDepth'
        });
        model.depthTexture.create(device, {
          width: viewNode.getCanvas().width,
          height: viewNode.getCanvas().height,
          format: model.depthFormat,
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
        });
        const dView = model.depthTexture.createView('opaquePassDepthTexture');
        model.renderEncoder.setDepthTextureView(dView);
      } else {
        model.colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
        model.depthTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
      }
      model.renderEncoder.attachTextureViews();
      publicAPI.setCurrentOperation('opaquePass');
      renNode.setRenderEncoder(model.renderEncoder);
      renNode.traverse(publicAPI);
    };
    publicAPI.getColorTextureView = () => model.renderEncoder.getColorTextureViews()[0];
    publicAPI.getDepthTextureView = () => model.renderEncoder.getDepthTextureView();
    publicAPI.createRenderEncoder = () => {
      model.renderEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: 'OpaquePass'
      });
      // default settings are fine for this
      model.renderEncoder.setPipelineHash('op');
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$b = {
    renderEncoder: null,
    colorTexture: null,
    depthTexture: null
  };

  // ----------------------------------------------------------------------------

  function extend$b(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$b, initialValues);

    // Build VTK API
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    macro.get(publicAPI, model, ['colorTexture', 'depthTexture']);

    // Object methods
    vtkWebGPUOpaquePass(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$b = macro.newInstance(extend$b, 'vtkWebGPUOpaquePass');

  // ----------------------------------------------------------------------------

  var vtkWebGPUOpaquePass$1 = {
    newInstance: newInstance$b,
    extend: extend$b
  };

  // ----------------------------------------------------------------------------

  const oitpFragTemplate = `
//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));
  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;
  if (reveal == 1.0) { discard; }
  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);
  var total: f32 = max(tcolor.a, 0.01);
  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
  function vtkWebGPUOrderIndependentTranslucentPass(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUOrderIndependentTranslucentPass');

    // this pass implements a forward rendering pipeline
    // if both volumes and opaque geometry are present
    // it will mix the two together by capturing a zbuffer
    // first
    publicAPI.traverse = (renNode, viewNode) => {
      if (model.deleted) {
        return;
      }

      // we just render our delegates in order
      model._currentParent = viewNode;
      const device = viewNode.getDevice();
      if (!model.translucentRenderEncoder) {
        publicAPI.createRenderEncoder();
        publicAPI.createFinalEncoder();
        model.translucentColorTexture = vtkWebGPUTexture$1.newInstance({
          label: 'translucentPassColor'
        });
        model.translucentColorTexture.create(device, {
          width: viewNode.getCanvas().width,
          height: viewNode.getCanvas().height,
          format: 'rgba16float',
          /* eslint-disable no-undef */
          /* eslint-disable no-bitwise */
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
        });
        const v1 = model.translucentColorTexture.createView('oitpColorTexture');
        model.translucentRenderEncoder.setColorTextureView(0, v1);
        model.translucentAccumulateTexture = vtkWebGPUTexture$1.newInstance({
          label: 'translucentPassAccumulate'
        });
        model.translucentAccumulateTexture.create(device, {
          width: viewNode.getCanvas().width,
          height: viewNode.getCanvas().height,
          format: 'r16float',
          /* eslint-disable no-undef */
          /* eslint-disable no-bitwise */
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
        });
        const v2 = model.translucentAccumulateTexture.createView('oitpAccumTexture');
        model.translucentRenderEncoder.setColorTextureView(1, v2);
        model.fullScreenQuad = vtkWebGPUFullScreenQuad$1.newInstance();
        model.fullScreenQuad.setDevice(viewNode.getDevice());
        model.fullScreenQuad.setPipelineHash('oitpfsq');
        model.fullScreenQuad.setTextureViews(model.translucentRenderEncoder.getColorTextureViews());
        model.fullScreenQuad.setFragmentShaderTemplate(oitpFragTemplate);
      } else {
        model.translucentColorTexture.resizeToMatch(model.colorTextureView.getTexture());
        model.translucentAccumulateTexture.resizeToMatch(model.colorTextureView.getTexture());
      }
      model.translucentRenderEncoder.setDepthTextureView(model.depthTextureView);
      model.translucentRenderEncoder.attachTextureViews();
      publicAPI.setCurrentOperation('translucentPass');
      renNode.setRenderEncoder(model.translucentRenderEncoder);
      renNode.traverse(publicAPI);
      publicAPI.finalPass(viewNode, renNode);
    };
    publicAPI.finalPass = (viewNode, renNode) => {
      model.translucentFinalEncoder.setColorTextureView(0, model.colorTextureView);
      model.translucentFinalEncoder.attachTextureViews();
      model.translucentFinalEncoder.begin(viewNode.getCommandEncoder());
      renNode.scissorAndViewport(model.translucentFinalEncoder);
      model.fullScreenQuad.prepareAndDraw(model.translucentFinalEncoder);
      model.translucentFinalEncoder.end();
    };
    publicAPI.getTextures = () => [model.translucentColorTexture, model.translucentAccumulateTexture];
    publicAPI.createRenderEncoder = () => {
      model.translucentRenderEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: 'translucentRender'
      });
      const rDesc = model.translucentRenderEncoder.getDescription();
      rDesc.colorAttachments = [{
        view: undefined,
        clearValue: [0.0, 0.0, 0.0, 0.0],
        loadOp: 'clear',
        storeOp: 'store'
      }, {
        view: undefined,
        clearValue: [1.0, 0.0, 0.0, 0.0],
        loadOp: 'clear',
        storeOp: 'store'
      }];
      rDesc.depthStencilAttachment = {
        view: undefined,
        depthLoadOp: 'load',
        depthStoreOp: 'store'
      };
      model.translucentRenderEncoder.setReplaceShaderCodeFunction(pipeline => {
        const fDesc = pipeline.getShaderDescription('fragment');
        fDesc.addOutput('vec4<f32>', 'outColor');
        fDesc.addOutput('f32', 'outAccum');
        fDesc.addBuiltinInput('vec4<f32>', '@builtin(position) fragPos');
        let code = fDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::RenderEncoder::Impl', [
        // very simple depth weighting in w z ranges from 1.0 near to 0.0
        'var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);', 'output.outColor = vec4<f32>(computedColor.rgb*w, w);', 'output.outAccum = computedColor.a;']).result;
        fDesc.setCode(code);
      });
      model.translucentRenderEncoder.setPipelineHash('oitpr');
      model.translucentRenderEncoder.setPipelineSettings({
        primitive: {
          cullMode: 'none'
        },
        depthStencil: {
          depthWriteEnabled: false,
          depthCompare: 'greater',
          format: 'depth32float'
        },
        fragment: {
          targets: [{
            format: 'rgba16float',
            blend: {
              color: {
                srcFactor: 'one',
                dstFactor: 'one'
              },
              alpha: {
                srcfactor: 'one',
                dstFactor: 'one'
              }
            }
          }, {
            format: 'r16float',
            blend: {
              color: {
                srcFactor: 'zero',
                dstFactor: 'one-minus-src'
              },
              alpha: {
                srcfactor: 'one',
                dstFactor: 'one-minus-src-alpha'
              }
            }
          }]
        }
      });
    };
    publicAPI.createFinalEncoder = () => {
      model.translucentFinalEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: 'translucentFinal'
      });
      model.translucentFinalEncoder.setDescription({
        colorAttachments: [{
          view: null,
          loadOp: 'load',
          storeOp: 'store'
        }]
      });
      model.translucentFinalEncoder.setReplaceShaderCodeFunction(pipeline => {
        const fDesc = pipeline.getShaderDescription('fragment');
        fDesc.addOutput('vec4<f32>', 'outColor');
        fDesc.addBuiltinInput('vec4<f32>', '@builtin(position) fragPos');
        let code = fDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::RenderEncoder::Impl', ['output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);']).result;
        fDesc.setCode(code);
      });
      model.translucentFinalEncoder.setPipelineHash('oitpf');
      model.translucentFinalEncoder.setPipelineSettings({
        primitive: {
          cullMode: 'none'
        },
        fragment: {
          targets: [{
            format: 'rgba16float',
            blend: {
              color: {
                srcFactor: 'src-alpha',
                dstFactor: 'one-minus-src-alpha'
              },
              alpha: {
                srcfactor: 'one',
                dstFactor: 'one-minus-src-alpha'
              }
            }
          }]
        }
      });
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$a = {
    colorTextureView: null,
    depthTextureView: null
  };

  // ----------------------------------------------------------------------------

  function extend$a(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$a, initialValues);

    // Build VTK API
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ['colorTextureView', 'depthTextureView']);

    // Object methods
    vtkWebGPUOrderIndependentTranslucentPass(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$a = macro.newInstance(extend$a, 'vtkWebGPUOrderIndependentTranslucentPass');

  // ----------------------------------------------------------------------------

  var vtkWebGPUOrderIndepenentTranslucentPass = {
    newInstance: newInstance$a,
    extend: extend$a
  };

  const BlendMode = {
    COMPOSITE_BLEND: 0,
    MAXIMUM_INTENSITY_BLEND: 1,
    MINIMUM_INTENSITY_BLEND: 2,
    AVERAGE_INTENSITY_BLEND: 3,
    ADDITIVE_INTENSITY_BLEND: 4,
    RADON_TRANSFORM_BLEND: 5
  };

  const volFragTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::Volume::TraverseDec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

fn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32
{
  // todo multicomponent support
  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;
}

fn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>
{
  var result: vec4<f32>;

  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;
  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;
  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;
  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;
  result.w = 0.0;

  // divide by spacing as that is our delta
  result = result / volumeSSBO.values[vNum].spacing;
  // now we have a gradient in unit tcoords

  var grad: f32 = length(result.xyz);
  if (grad > 0.0)
  {
    // rotate to View Coords, needed for lighting and shading
    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;
    result = nMat * result;
    result = result / length(result);
  }

  // store gradient magnitude in .w
  result.w = grad;

  return result;
}

fn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>
{
  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);

  // convert to tcoords and reject if outside the volume
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;
  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||
      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }

  var scalar: f32 = getTextureValue(vTex, tpos);

  var coord: vec2<f32> =
    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,
      (0.5 + 2.0 * f32(vNum)) / tfunRows);
  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);

  var gofactor: f32 = 1.0;
  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);
  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)
  {
    normal = getGradient(vTex, tpos, vNum, scalar);
    if (componentSSBO.values[cNum].gomin <  1.0)
    {
      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,
      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);
    }
  }

  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);
  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;

  if (volumeSSBO.values[vNum].shade[0] > 0.0)
  {
    color = color*abs(normal.z);
  }

  outColor = vec4<f32>(color.rgb, gofactor * opacity);

  return outColor;
}

// adjust the start and end point of a raycast such that it intersects the unit cube.
// This function is used to take a raycast starting point and step vector
// and numSteps and return the startijng and ending steps for intersecting the
// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates
// that have valid values. So this funtion can be used to take a ray in texture coordinates
// and bound it to intersecting the texture.
//
fn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>
{
  var result: vec2<f32> = vec2<f32>(0.0, numSteps);
  var tpos2: vec4<f32> = tpos + tstep*numSteps;

  // move tpos to the start of the volume
  var adjust: f32 =
    min(
      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),
      min(
        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),
        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));
  if (adjust < 0.0)
  {
    result.x = result.x - adjust;
  }

  // adjust length to the end
  adjust =
    max(
      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),
      max(
        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),
        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));
  if (adjust > 0.0)
  {
    result.y = result.y - adjust;
  }

  return result;
}

fn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>
{
  // how many rows (tfuns) do we have in our tfunTexture
  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);

  var coord: vec2<f32> =
    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,
      (0.5 + 2.0 * f32(vNum)) / tfunRows);
  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);
  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);
  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;
  return vec4<f32>(color.rgb, opacity);
}

fn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var maxVal: f32 = -1.0e37;
  loop
  {
    var scalar: f32 = getTextureValue(vTex, tpos);
    if (scalar > maxVal)
    {
      maxVal = scalar;
    }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);
}

fn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var minVal: f32 = 1.0e37;
  loop
  {
    var scalar: f32 = getTextureValue(vTex, tpos);
    if (scalar < minVal)
    {
      minVal = scalar;
    }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);
}

fn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;
  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var avgVal: f32 = 0.0;
  var sampleCount: f32 = 0.0;
  loop
  {
    var sample: f32 = getTextureValue(vTex, tpos);
    // right now leave filtering off until WebGL changes get merged
    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)
    // {
      avgVal = avgVal + sample;
      sampleCount = sampleCount + 1.0;
    // }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  if (sampleCount <= 0.0)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);
}

fn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)
{
  // convert to tcoords and reject if outside the volume
  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;
  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;
  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);
  var tstep: vec4<f32> = tpos2 - tpos;

  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);

  // did we hit anything
  if (rayBounds.x >= rayBounds.y)
  {
    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);
    return;
  }

  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;
  tpos = tpos + tstep*rayBounds.x;
  var curDist: f32 = rayBounds.x;
  var sumVal: f32 = 0.0;
  loop
  {
    var sample: f32 = getTextureValue(vTex, tpos);
    // right now leave filtering off until WebGL changes get merged
    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)
    // {
      sumVal = sumVal + sample;
    // }

    // increment position
    curDist = curDist + 1.0;
    tpos = tpos + tstep;

    // check if we have reached a terminating condition
    if (curDist > rayBounds.y) { break; }
  }

  // process to get the color and opacity
  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);
}

fn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>
{
  // initial ray position is at the beginning
  var rayPosSC: vec4<f32> = minPosSC;

  // how many rows (tfuns) do we have in our tfunTexture
  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);

  var curDist: f32 = 0.0;
  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);
  var sampleColor: vec4<f32>;
//VTK::Volume::TraverseCalls

  loop
  {
    // for each volume, sample and accumulate color
//VTK::Volume::CompositeCalls

    // increment position
    curDist = curDist + mapperUBO.SampleDistance;
    rayPosSC = rayPosSC + rayStepSC;

    // check if we have reached a terminating condition
    if (curDist > rayLengthSC) { break; }
    if (computedColor.a > 0.98) { break; }
  }
  return computedColor;
}

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;
  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;

  // discard empty rays
  if (rayMax <= rayMin) { discard; }
  else
  {
    // compute start and end ray positions in view coordinates
    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);
    minPosSC = minPosSC * (1.0 / minPosSC.w);
    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);
    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);

    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);
    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);
    rayStepSC.w = 0.0;

    var computedColor: vec4<f32>;

//VTK::Volume::Loop

//VTK::RenderEncoder::Impl
  }

  return output;
}
`;
  const tmpMat4 = new Float64Array(16);
  const tmp2Mat4 = new Float64Array(16);

  // ----------------------------------------------------------------------------
  // vtkWebGPUVolumePassFSQ methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUVolumePassFSQ(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUVolumePassFSQ');
    publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
      const vDesc = pipeline.getShaderDescription('vertex');
      vDesc.addBuiltinOutput('vec4<f32>', '@builtin(position) Position');
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Position::Impl', ['output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);', 'output.Position = vec4<f32>(vertexBC, 1.0);']).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription('fragment');
      fDesc.addBuiltinInput('vec4<f32>', '@builtin(position) fragPos');
    };
    model.shaderReplacements.set('replaceShaderPosition', publicAPI.replaceShaderPosition);
    publicAPI.replaceShaderVolume = (hash, pipeline, vertexInput) => {
      const fDesc = pipeline.getShaderDescription('fragment');
      let code = fDesc.getCode();
      const compositeCalls = [];
      const traverseCalls = [];
      for (let i = 0; i < model.volumes.length; i++) {
        // todo pass rowPos
        const blendMode = model.volumes[i].getRenderable().getMapper().getBlendMode();
        if (blendMode === BlendMode.COMPOSITE_BLEND) {
          compositeCalls.push(`    sampleColor = processVolume(volTexture${i}, ${i}, ${model.rowStarts[i]}, rayPosSC, tfunRows);`);
          compositeCalls.push(`    computedColor = vec4<f32>(
          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,
          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);
        } else {
          traverseCalls.push(`  sampleColor = traverseVals[${i}];`);
          traverseCalls.push(`  computedColor = vec4<f32>(
          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,
          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);`);
        }
      }
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Volume::CompositeCalls', compositeCalls).result;
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Volume::TraverseCalls', traverseCalls).result;
      code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Volume::TraverseDec', [`var<private> traverseVals: array<vec4<f32>,${model.volumes.length}>;`]).result;

      // call the full and partial methods as needed
      let compositeWhileTraversing = false;
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();
        if (blendMode === BlendMode.COMPOSITE_BLEND) {
          compositeWhileTraversing = true;
        } else if (blendMode === BlendMode.MAXIMUM_INTENSITY_BLEND) {
          code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Volume::Loop', [`    traverseMax(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;
        } else if (blendMode === BlendMode.MINIMUM_INTENSITY_BLEND) {
          code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Volume::Loop', [`    traverseMin(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;
        } else if (blendMode === BlendMode.AVERAGE_INTENSITY_BLEND) {
          code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Volume::Loop', [`    traverseAverage(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;
        } else if (blendMode === BlendMode.ADDITIVE_INTENSITY_BLEND) {
          code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Volume::Loop', [`    traverseAdditive(volTexture${vidx}, ${vidx}, ${vidx}, rayLengthSC, minPosSC, rayStepSC);`, `    computedColor = traverseVals[${vidx}];`, '//VTK::Volume::Loop']).result;
        }
      }
      if (compositeWhileTraversing) {
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::Volume::Loop', ['    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);']).result;
      }
      fDesc.setCode(code);
    };
    model.shaderReplacements.set('replaceShaderVolume', publicAPI.replaceShaderVolume);
    publicAPI.updateLUTImage = device => {
      // depends on
      // - volumes array (length and values) - mtime
      // - tfun arrays - renderable/property mtime

      let mtime = publicAPI.getMTime();
      for (let i = 0; i < model.volumes.length; i++) {
        const vol = model.volumes[i].getRenderable();
        const image = vol.getMapper().getInputData();
        mtime = Math.max(mtime, vol.getMTime(), image.getMTime());
      }
      if (mtime < model.lutBuildTime.getMTime()) {
        return;
      }

      // first determine how large the image should be
      model.numRows = 0;
      model.rowStarts = [];
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        model.rowStarts.push(model.numRows);
        const webgpuvol = model.volumes[vidx];
        const actor = webgpuvol.getRenderable();
        const volMapr = actor.getMapper();
        const vprop = actor.getProperty();
        const image = volMapr.getInputData();
        const scalars = image.getPointData() && image.getPointData().getScalars();
        const numComp = scalars.getNumberOfComponents();
        const iComps = vprop.getIndependentComponents();
        const numIComps = iComps ? numComp : 1;
        model.numRows += numIComps;
      }

      // allocate the image array
      const colorArray = new Uint8ClampedArray(model.numRows * 2 * model.rowLength * 4);
      const opacityArray = new Float32Array(model.numRows * 2 * model.rowLength);
      let imgRow = 0;
      const tmpTable = new Float32Array(model.rowLength * 3);
      const rowLength = model.rowLength;
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        const webgpuvol = model.volumes[vidx];
        const actor = webgpuvol.getRenderable();
        const volMapr = actor.getMapper();
        const vprop = actor.getProperty();
        const image = volMapr.getInputData();
        const scalars = image.getPointData() && image.getPointData().getScalars();
        const numComp = scalars.getNumberOfComponents();
        const iComps = vprop.getIndependentComponents();
        const numIComps = iComps ? numComp : 1;
        for (let c = 0; c < numIComps; ++c) {
          const cfun = vprop.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], rowLength, tmpTable, 1);
          let ioffset = imgRow * rowLength * 4;
          for (let i = 0; i < rowLength; ++i) {
            colorArray[ioffset + i * 4] = 255.0 * tmpTable[i * 3];
            colorArray[ioffset + i * 4 + 1] = 255.0 * tmpTable[i * 3 + 1];
            colorArray[ioffset + i * 4 + 2] = 255.0 * tmpTable[i * 3 + 2];
            colorArray[ioffset + i * 4 + 3] = 255.0;
            for (let co = 0; co < 4; co++) {
              colorArray[ioffset + (rowLength + i) * 4 + co] = colorArray[ioffset + i * 4 + co];
            }
          }
          const ofun = vprop.getScalarOpacity(c);
          const opacityFactor = model.sampleDist / vprop.getScalarOpacityUnitDistance(c);
          const oRange = ofun.getRange();
          ofun.getTable(oRange[0], oRange[1], rowLength, tmpTable, 1);
          // adjust for sample distance etc
          ioffset = imgRow * rowLength;
          for (let i = 0; i < rowLength; ++i) {
            opacityArray[ioffset + i] = 1.0 - (1.0 - tmpTable[i]) ** opacityFactor;
            opacityArray[ioffset + i + rowLength] = opacityArray[ioffset + i];
          }
          imgRow += 2;
        }
      }
      {
        const treq = {
          nativeArray: colorArray,
          width: model.rowLength,
          height: model.numRows * 2,
          depth: 1,
          format: 'rgba8unorm'
        };
        const newTex = device.getTextureManager().getTexture(treq);
        const tview = newTex.createView('tfunTexture');
        model.textureViews[2] = tview;
      }
      {
        const treq = {
          nativeArray: opacityArray,
          width: model.rowLength,
          height: model.numRows * 2,
          depth: 1,
          format: 'r16float'
        };
        const newTex = device.getTextureManager().getTexture(treq);
        const tview = newTex.createView('ofunTexture');
        model.textureViews[3] = tview;
      }
      model.lutBuildTime.modified();
    };
    publicAPI.updateSSBO = device => {
      // if any of
      // - color or opacity tfun ranges changed - volume Mtime
      // - any volume matrix changed - volume MTime
      // - stabilized center changed - ren.stabilizedMTime
      // - any volume's input data worldtoindex or dimensions changed - input's mtime
      //
      let mtime = Math.max(publicAPI.getMTime(), model.WebGPURenderer.getStabilizedTime());
      for (let i = 0; i < model.volumes.length; i++) {
        const vol = model.volumes[i].getRenderable();
        const volMapr = vol.getMapper();
        const image = volMapr.getInputData();
        mtime = Math.max(mtime, vol.getMTime(), image.getMTime(), volMapr.getMTime());
      }
      if (mtime < model.SSBO.getSendTime()) {
        return;
      }

      // create the volumeSBBO
      const center = model.WebGPURenderer.getStabilizedCenterByReference();
      model.SSBO.clearData();
      model.SSBO.setNumberOfInstances(model.volumes.length);

      // create SCTC matrices  SC -> world -> model -> index -> tcoord
      //
      // when doing coord conversions from A to C recall
      // the order is mat4.mult(AtoC, BtoC, AtoB);
      //
      const marray = new Float64Array(model.volumes.length * 16);
      const vPlaneArray = new Float64Array(model.volumes.length * 16);
      const tstepArray = new Float64Array(model.volumes.length * 4);
      const shadeArray = new Float64Array(model.volumes.length * 4);
      const spacingArray = new Float64Array(model.volumes.length * 4);
      const ipScalarRangeArray = new Float64Array(model.volumes.length * 4);
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        const webgpuvol = model.volumes[vidx];
        const actor = webgpuvol.getRenderable();
        const volMapr = actor.getMapper();
        const image = volMapr.getInputData();
        identity$3(tmpMat4);
        translate(tmpMat4, tmpMat4, center);
        // tmpMat4 is now SC->World

        const mcwcmat = actor.getMatrix();
        transpose(tmp2Mat4, mcwcmat);
        invert(tmp2Mat4, tmp2Mat4);
        // tmp2Mat4 is now world to model

        multiply$1(tmpMat4, tmp2Mat4, tmpMat4);
        // tmp4Mat is now SC->Model

        // the method on the data is world to index but the volume is in
        // model coordinates so really in this context it is model to index
        const modelToIndex = image.getWorldToIndex();
        multiply$1(tmpMat4, modelToIndex, tmpMat4);
        // tmpMat4 is now SC -> Index

        const dims = image.getDimensions();
        identity$3(tmp2Mat4);
        scale$2(tmp2Mat4, tmp2Mat4, [1.0 / dims[0], 1.0 / dims[1], 1.0 / dims[2]]);
        multiply$1(tmpMat4, tmp2Mat4, tmpMat4);
        // tmpMat4 is now SC -> Tcoord

        for (let j = 0; j < 16; j++) {
          marray[vidx * 16 + j] = tmpMat4[j];
        }
        invert(tmpMat4, tmpMat4);
        // now it is Tcoord To SC

        for (let j = 0; j < 4; j++) {
          vPlaneArray[vidx * 16 + j * 4] = tmpMat4[j * 4];
          vPlaneArray[vidx * 16 + j * 4 + 1] = tmpMat4[j * 4 + 1];
          vPlaneArray[vidx * 16 + j * 4 + 2] = tmpMat4[j * 4 + 2];
          vPlaneArray[vidx * 16 + j * 4 + 3] = 0.0;
        }
        tstepArray[vidx * 4] = 1.0 / dims[0];
        tstepArray[vidx * 4 + 1] = 1.0 / dims[1];
        tstepArray[vidx * 4 + 2] = 1.0 / dims[2];
        tstepArray[vidx * 4 + 3] = 1.0;
        shadeArray[vidx * 4] = actor.getProperty().getShade() ? 1.0 : 0.0;
        const spacing = image.getSpacing();
        spacingArray[vidx * 4] = spacing[0];
        spacingArray[vidx * 4 + 1] = spacing[1];
        spacingArray[vidx * 4 + 2] = spacing[2];
        spacingArray[vidx * 4 + 3] = 1.0;

        // handle filteringMode
        const tScale = model.textureViews[vidx + 4].getTexture().getScale();
        const ipScalarRange = volMapr.getIpScalarRange();
        ipScalarRangeArray[vidx * 4] = ipScalarRange[0] / tScale;
        ipScalarRangeArray[vidx * 4 + 1] = ipScalarRange[1] / tScale;
        ipScalarRangeArray[vidx * 4 + 2] = volMapr.getFilterMode();
      }
      model.SSBO.addEntry('SCTCMatrix', 'mat4x4<f32>');
      model.SSBO.addEntry('planeNormals', 'mat4x4<f32>');
      model.SSBO.addEntry('shade', 'vec4<f32>');
      model.SSBO.addEntry('tstep', 'vec4<f32>');
      model.SSBO.addEntry('spacing', 'vec4<f32>');
      model.SSBO.addEntry('ipScalarRange', 'vec4<f32>');
      model.SSBO.setAllInstancesFromArray('SCTCMatrix', marray);
      model.SSBO.setAllInstancesFromArray('planeNormals', vPlaneArray);
      model.SSBO.setAllInstancesFromArray('shade', shadeArray);
      model.SSBO.setAllInstancesFromArray('tstep', tstepArray);
      model.SSBO.setAllInstancesFromArray('spacing', spacingArray);
      model.SSBO.setAllInstancesFromArray('ipScalarRange', ipScalarRangeArray);
      model.SSBO.send(device);

      // now create the componentSSBO
      model.componentSSBO.clearData();
      model.componentSSBO.setNumberOfInstances(model.numRows);
      const cScaleArray = new Float64Array(model.numRows);
      const cShiftArray = new Float64Array(model.numRows);
      const oScaleArray = new Float64Array(model.numRows);
      const oShiftArray = new Float64Array(model.numRows);
      const gominArray = new Float64Array(model.numRows);
      const gomaxArray = new Float64Array(model.numRows);
      const goshiftArray = new Float64Array(model.numRows);
      const goscaleArray = new Float64Array(model.numRows);
      let rowIdx = 0;
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        const webgpuvol = model.volumes[vidx];
        const actor = webgpuvol.getRenderable();
        const volMapr = actor.getMapper();
        const vprop = actor.getProperty();
        const image = volMapr.getInputData();
        const scalars = image.getPointData() && image.getPointData().getScalars();
        const numComp = scalars.getNumberOfComponents();
        const iComps = vprop.getIndependentComponents();
        // const numIComps = iComps ? numComp : 1;

        // half float?
        const tformat = model.textureViews[vidx + 4].getTexture().getFormat();
        const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(tformat);
        const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === 'float';
        const volInfo = {
          scale: [255.0],
          offset: [0.0]
        };
        if (halfFloat) {
          volInfo.scale[0] = 1.0;
        }

        // three levels of shift scale combined into one
        // for performance in the fragment shader
        for (let compIdx = 0; compIdx < numComp; compIdx++) {
          const target = iComps ? compIdx : 0;
          const sscale = volInfo.scale[compIdx];
          const ofun = vprop.getScalarOpacity(target);
          const oRange = ofun.getRange();
          const oscale = sscale / (oRange[1] - oRange[0]);
          const oshift = (volInfo.offset[compIdx] - oRange[0]) / (oRange[1] - oRange[0]);
          oShiftArray[rowIdx] = oshift;
          oScaleArray[rowIdx] = oscale;
          const cfun = vprop.getRGBTransferFunction(target);
          const cRange = cfun.getRange();
          cShiftArray[rowIdx] = (volInfo.offset[compIdx] - cRange[0]) / (cRange[1] - cRange[0]);
          cScaleArray[rowIdx] = sscale / (cRange[1] - cRange[0]);

          // todo sscale for dependent should be based off of the A channel?
          // not target (which is 0 in that case)
          const useGO = vprop.getUseGradientOpacity(target);
          if (useGO) {
            const gomin = vprop.getGradientOpacityMinimumOpacity(target);
            const gomax = vprop.getGradientOpacityMaximumOpacity(target);
            gominArray[rowIdx] = gomin;
            gomaxArray[rowIdx] = gomax;
            const goRange = [vprop.getGradientOpacityMinimumValue(target), vprop.getGradientOpacityMaximumValue(target)];
            goscaleArray[rowIdx] = sscale * (gomax - gomin) / (goRange[1] - goRange[0]);
            goshiftArray[rowIdx] = -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin;
          } else {
            gominArray[rowIdx] = 1.0;
            gomaxArray[rowIdx] = 1.0;
            goscaleArray[rowIdx] = 0.0;
            goshiftArray[rowIdx] = 1.0;
          }
          rowIdx++;
        }
      }
      model.componentSSBO.addEntry('cScale', 'f32');
      model.componentSSBO.addEntry('cShift', 'f32');
      model.componentSSBO.addEntry('oScale', 'f32');
      model.componentSSBO.addEntry('oShift', 'f32');
      model.componentSSBO.addEntry('goShift', 'f32');
      model.componentSSBO.addEntry('goScale', 'f32');
      model.componentSSBO.addEntry('gomin', 'f32');
      model.componentSSBO.addEntry('gomax', 'f32');
      model.componentSSBO.setAllInstancesFromArray('cScale', cScaleArray);
      model.componentSSBO.setAllInstancesFromArray('cShift', cShiftArray);
      model.componentSSBO.setAllInstancesFromArray('oScale', oScaleArray);
      model.componentSSBO.setAllInstancesFromArray('oShift', oShiftArray);
      model.componentSSBO.setAllInstancesFromArray('goScale', goscaleArray);
      model.componentSSBO.setAllInstancesFromArray('goShift', goshiftArray);
      model.componentSSBO.setAllInstancesFromArray('gomin', gominArray);
      model.componentSSBO.setAllInstancesFromArray('gomax', gomaxArray);
      model.componentSSBO.send(device);
    };
    const superClassUpdateBuffers = publicAPI.updateBuffers;
    publicAPI.updateBuffers = () => {
      superClassUpdateBuffers();
      // compute the min step size
      let sampleDist = model.volumes[0].getRenderable().getMapper().getSampleDistance();
      for (let i = 0; i < model.volumes.length; i++) {
        const vol = model.volumes[i];
        const volMapr = vol.getRenderable().getMapper();
        const sd = volMapr.getSampleDistance();
        if (sd < sampleDist) {
          sampleDist = sd;
        }
      }
      if (model.sampleDist !== sampleDist) {
        model.sampleDist = sampleDist;
        model.UBO.setValue('SampleDistance', sampleDist);
        model.UBO.sendIfNeeded(model.device);
      }

      // add in 3d volume textures
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        const webgpuvol = model.volumes[vidx];
        const actor = webgpuvol.getRenderable();
        const volMapr = actor.getMapper();
        const image = volMapr.getInputData();
        const newTex = model.device.getTextureManager().getTextureForImageData(image);
        if (!model.textureViews[vidx + 4] || model.textureViews[vidx + 4].getTexture() !== newTex) {
          const tview = newTex.createView(`volTexture${vidx}`);
          model.textureViews[vidx + 4] = tview;
        }
      }

      // clear any old leftovers
      if (model.volumes.length < model.lastVolumeLength) {
        // we may have gaps in the array right now so no splice
        for (let i = model.volumes.length; i < model.lastVolumeLength; i++) {
          model.textureViews.pop();
        }
      }
      model.lastVolumeLength = model.volumes.length;
      publicAPI.updateLUTImage(model.device);
      publicAPI.updateSSBO(model.device);
      if (!model.clampSampler) {
        model.clampSampler = vtkWebGPUSampler$1.newInstance({
          label: 'clampSampler'
        });
        model.clampSampler.create(model.device, {
          minFilter: 'linear',
          magFilter: 'linear'
        });
      }
    };
    publicAPI.computePipelineHash = () => {
      model.pipelineHash = 'volfsq';
      for (let vidx = 0; vidx < model.volumes.length; vidx++) {
        const blendMode = model.volumes[vidx].getRenderable().getMapper().getBlendMode();
        model.pipelineHash += `${blendMode}`;
      }
    };

    // marks modified when needed
    publicAPI.setVolumes = val => {
      if (!model.volumes || model.volumes.length !== val.length) {
        model.volumes = [...val];
        publicAPI.modified();
        return;
      }
      for (let i = 0; i < val.length; i++) {
        if (val[i] !== model.volumes[i]) {
          model.volumes = [...val];
          publicAPI.modified();
          return;
        }
      }
    };
    const superclassGetBindables = publicAPI.getBindables;
    publicAPI.getBindables = () => {
      const bindables = superclassGetBindables();
      bindables.push(model.componentSSBO);
      bindables.push(model.clampSampler);
      return bindables;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$9 = {
    volumes: null,
    rowLength: 1024,
    lastVolumeLength: 0
  };

  // ----------------------------------------------------------------------------

  function extend$9(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$9, initialValues);

    // Inheritance
    vtkWebGPUFullScreenQuad$1.extend(publicAPI, model, initialValues);
    model.fragmentShaderTemplate = volFragTemplate;
    model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
      label: 'mapperUBO'
    });
    model.UBO.addEntry('SampleDistance', 'f32');
    model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
      label: 'volumeSSBO'
    });
    model.componentSSBO = vtkWebGPUStorageBuffer$1.newInstance({
      label: 'componentSSBO'
    });
    model.lutBuildTime = {};
    macro.obj(model.lutBuildTime, {
      mtime: 0
    });

    // Object methods
    vtkWebGPUVolumePassFSQ(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$9 = macro.newInstance(extend$9, 'vtkWebGPUVolumePassFSQ');

  // ----------------------------------------------------------------------------

  var vtkWebGPUVolumePassFSQ$1 = {
    newInstance: newInstance$9,
    extend: extend$9
  };

  const {
    Representation
  } = vtkProperty$1;
  const {
    BufferUsage,
    PrimitiveTypes
  } = vtkWebGPUBufferManager$1;

  // The volume rendering pass consists of two sub passes. The first
  // (depthRange) renders polygonal cubes for the volumes to compute min and
  // max bounds in depth for the image. This is then fed into the second pass
  // (final) which actually does the raycasting between those bounds sampling
  // the volumes along the way. So the first pass tends to be very fast whicle
  // the second is where most of the work is done.

  // given x then y then z ordering
  //
  //     2-----3
  //   / |   / |
  //  6-----7  |
  //  |  |  |  |
  //  |  0-----1
  //  |/    |/
  //  4-----5
  //
  const cubeFaceTriangles = [[0, 4, 6], [0, 6, 2], [1, 3, 7], [1, 7, 5], [0, 5, 4], [0, 1, 5], [2, 6, 7], [2, 7, 3], [0, 3, 1], [0, 2, 3], [4, 5, 7], [4, 7, 6]];
  const DepthBoundsFS = `
//VTK::Renderer::Dec

//VTK::Select::Dec

//VTK::VolumePass::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  //VTK::Select::Impl

  //VTK::TCoord::Impl

  //VTK::VolumePass::Impl

  // use the maximum (closest) of the current value and the zbuffer
  // the blend func will then take the min to find the farthest stop value
  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));

  //VTK::RenderEncoder::Impl
  return output;
}
`;
  const volumeCopyFragTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,
    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);

  //VTK::RenderEncoder::Impl
  return output;
}
`;

  /* eslint-disable no-undef */
  /* eslint-disable no-bitwise */

  // ----------------------------------------------------------------------------

  function vtkWebGPUVolumePass(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUVolumePass');

    // create the required textures, encoders, FSQ etc
    publicAPI.initialize = viewNode => {
      if (!model._clearEncoder) {
        publicAPI.createClearEncoder(viewNode);
      }
      if (!model._mergeEncoder) {
        publicAPI.createMergeEncoder(viewNode);
      }
      if (!model._copyEncoder) {
        publicAPI.createCopyEncoder(viewNode);
      }
      if (!model._depthRangeEncoder) {
        publicAPI.createDepthRangeEncoder(viewNode);
      }
      if (!model.fullScreenQuad) {
        model.fullScreenQuad = vtkWebGPUVolumePassFSQ$1.newInstance();
        model.fullScreenQuad.setDevice(viewNode.getDevice());
        model.fullScreenQuad.setTextureViews([...model._depthRangeEncoder.getColorTextureViews()]);
      }
      if (!model._volumeCopyQuad) {
        model._volumeCopyQuad = vtkWebGPUFullScreenQuad$1.newInstance();
        model._volumeCopyQuad.setPipelineHash('volpassfsq');
        model._volumeCopyQuad.setDevice(viewNode.getDevice());
        model._volumeCopyQuad.setFragmentShaderTemplate(volumeCopyFragTemplate);
        model._copyUBO = vtkWebGPUUniformBuffer$1.newInstance({
          label: 'mapperUBO'
        });
        model._copyUBO.addEntry('tscale', 'vec2<f32>');
        model._volumeCopyQuad.setUBO(model._copyUBO);
        model._volumeCopyQuad.setTextureViews([model._colorTextureView]);
      }
    };
    publicAPI.traverse = (renNode, viewNode) => {
      if (model.deleted) {
        return;
      }

      // we just render our delegates in order
      model._currentParent = viewNode;

      // create stuff we need
      publicAPI.initialize(viewNode);

      // determine if we are rendering a small size
      publicAPI.computeTiming(viewNode);

      // first render the boxes to generate a min max depth
      // map for all the volumes
      publicAPI.renderDepthBounds(renNode, viewNode);

      // always mark true
      model._firstGroup = true;
      const device = viewNode.getDevice();

      // determine how many volumes we can render at a time. We subtract
      // 4 because we use know we use textures for min, max, ofun and tfun
      const maxVolumes = device.getHandle().limits.maxSampledTexturesPerShaderStage - 4;

      // if we have to make multiple passes then break the volumes up into groups
      // rendered from farthest to closest
      if (model.volumes.length > maxVolumes) {
        const cameraPos = renNode.getRenderable().getActiveCamera().getPosition();
        // sort from back to front based on volume centroid
        const distances = [];
        for (let v = 0; v < model.volumes.length; v++) {
          const bounds = model.volumes[v].getRenderable().getBounds();
          const centroid = [0.5 * (bounds[1] + bounds[0]), 0.5 * (bounds[3] + bounds[2]), 0.5 * (bounds[5] + bounds[4])];
          distances[v] = distance2BetweenPoints(centroid, cameraPos);
        }

        // sort by distance
        const volumeOrder = [...Array(model.volumes.length).keys()];
        volumeOrder.sort((a, b) => distances[b] - distances[a]);

        // render in chunks back to front
        let volumesToRender = [];
        // start with smallest chunk so that the last (closest) chunk
        // has a full maxVolumes;
        let chunkSize = volumeOrder.length % maxVolumes;
        for (let v = 0; v < volumeOrder.length; v++) {
          volumesToRender.push(model.volumes[volumeOrder[v]]);
          if (volumesToRender.length >= chunkSize) {
            publicAPI.rayCastPass(viewNode, renNode, volumesToRender);
            volumesToRender = [];
            chunkSize = maxVolumes;
            model._firstGroup = false;
          }
        }
      } else {
        // if not rendering in chunks then just draw all of them at once
        publicAPI.rayCastPass(viewNode, renNode, model.volumes);
      }

      // copy back to the original color buffer

      // final composite
      model._volumeCopyQuad.setWebGPURenderer(renNode);
      if (model._useSmallViewport) {
        const width = model._colorTextureView.getTexture().getWidth();
        const height = model._colorTextureView.getTexture().getHeight();
        model._copyUBO.setArray('tscale', [model._smallViewportWidth / width, model._smallViewportHeight / height]);
      } else {
        model._copyUBO.setArray('tscale', [1.0, 1.0]);
      }
      model._copyUBO.sendIfNeeded(device);
      model._copyEncoder.setColorTextureView(0, model.colorTextureView);
      model._copyEncoder.attachTextureViews();
      model._copyEncoder.begin(viewNode.getCommandEncoder());
      renNode.scissorAndViewport(model._copyEncoder);
      model._volumeCopyQuad.prepareAndDraw(model._copyEncoder);
      model._copyEncoder.end();
    };

    // unsubscribe from our listeners
    publicAPI.delete = macro.chain(() => {
      if (model._animationRateSubscription) {
        model._animationRateSubscription.unsubscribe();
        model._animationRateSubscription = null;
      }
    }, publicAPI.delete);
    publicAPI.computeTiming = viewNode => {
      const rwi = viewNode.getRenderable().getInteractor();
      if (model._lastScale == null) {
        const firstMapper = model.volumes[0].getRenderable().getMapper();
        model._lastScale = firstMapper.getInitialInteractionScale() || 1.0;
      }
      model._useSmallViewport = false;
      if (rwi.isAnimating() && model._lastScale > 1.5) {
        model._useSmallViewport = true;
      }
      model._colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
      if (!model._animationRateSubscription) {
        // when the animation frame rate changes recompute the scale factor
        model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(() => {
          const firstMapper = model.volumes[0].getRenderable().getMapper();
          if (firstMapper.getAutoAdjustSampleDistances()) {
            const frate = rwi.getRecentAnimationFrameRate();
            const targetScale = model._lastScale * rwi.getDesiredUpdateRate() / frate;
            model._lastScale = targetScale;
            // clamp scale to some reasonable values.
            // Below 1.5 we will just be using full resolution as that is close enough
            // Above 400 seems like a lot so we limit to that 1/20th per axis
            if (model._lastScale > 400) {
              model._lastScale = 400;
            }
          } else {
            model._lastScale = firstMapper.getImageSampleDistance() * firstMapper.getImageSampleDistance();
          }
          if (model._lastScale < 1.5) {
            model._lastScale = 1.5;
          }
        });
      }
    };
    publicAPI.rayCastPass = (viewNode, renNode, volumes) => {
      const encoder = model._firstGroup ? model._clearEncoder : model._mergeEncoder;
      encoder.attachTextureViews();
      encoder.begin(viewNode.getCommandEncoder());
      let width = model._colorTextureView.getTexture().getWidth();
      let height = model._colorTextureView.getTexture().getHeight();
      if (model._useSmallViewport) {
        const canvas = viewNode.getCanvas();
        const scaleFactor = 1 / Math.sqrt(model._lastScale);
        model._smallViewportWidth = Math.ceil(scaleFactor * canvas.width);
        model._smallViewportHeight = Math.ceil(scaleFactor * canvas.height);
        width = model._smallViewportWidth;
        height = model._smallViewportHeight;
      }
      encoder.getHandle().setViewport(0, 0, width, height, 0.0, 1.0);
      // set scissor
      encoder.getHandle().setScissorRect(0, 0, width, height);
      model.fullScreenQuad.setWebGPURenderer(renNode);
      model.fullScreenQuad.setVolumes(volumes);
      model.fullScreenQuad.prepareAndDraw(encoder);
      encoder.end();
    };
    publicAPI.renderDepthBounds = (renNode, viewNode) => {
      publicAPI.updateDepthPolyData(renNode);
      const pd = model._boundsPoly;
      const points = pd.getPoints();
      const cells = pd.getPolys();
      let buffRequest = {
        hash: `vp${cells.getMTime()}`,
        usage: BufferUsage.Index,
        cells,
        numberOfPoints: points.getNumberOfPoints(),
        primitiveType: PrimitiveTypes.Triangles,
        representation: Representation.SURFACE
      };
      const indexBuffer = viewNode.getDevice().getBufferManager().getBuffer(buffRequest);
      model._mapper.getVertexInput().setIndexBuffer(indexBuffer);

      // points
      buffRequest = {
        usage: BufferUsage.PointArray,
        format: 'float32x4',
        hash: `vp${points.getMTime()}${cells.getMTime()}`,
        dataArray: points,
        indexBuffer,
        packExtra: true
      };
      const buff = viewNode.getDevice().getBufferManager().getBuffer(buffRequest);
      model._mapper.getVertexInput().addBuffer(buff, ['vertexBC']);
      model._mapper.setNumberOfVertices(buff.getSizeInBytes() / buff.getStrideInBytes());
      publicAPI.drawDepthRange(renNode, viewNode);
    };
    publicAPI.updateDepthPolyData = renNode => {
      // check mtimes first
      let update = false;
      for (let i = 0; i < model.volumes.length; i++) {
        const mtime = model.volumes[i].getMTime();
        if (!model._lastMTimes[i] || mtime !== model._lastMTimes[i]) {
          update = true;
          model._lastMTimes[i] = mtime;
        }
      }

      // also check stabilized time
      const stime = renNode.getStabilizedTime();
      if (model._lastMTimes.length <= model.volumes.length || stime !== model._lastMTimes[model.volumes.length]) {
        update = true;
        model._lastMTimes[model.volumes.length] = stime;
      }

      // if no need to update then return
      if (!update) {
        return;
      }

      // rebuild
      const center = renNode.getStabilizedCenterByReference();
      const numPts = model.volumes.length * 8;
      const points = new Float64Array(numPts * 3);
      const numTris = model.volumes.length * 12;
      const polys = new Uint16Array(numTris * 4);

      // add points and cells
      for (let i = 0; i < model.volumes.length; i++) {
        model.volumes[i].getBoundingCubePoints(points, i * 24);
        let cellIdx = i * 12 * 4;
        const offset = i * 8;
        for (let t = 0; t < 12; t++) {
          polys[cellIdx++] = 3;
          polys[cellIdx++] = offset + cubeFaceTriangles[t][0];
          polys[cellIdx++] = offset + cubeFaceTriangles[t][1];
          polys[cellIdx++] = offset + cubeFaceTriangles[t][2];
        }
      }
      for (let p = 0; p < points.length; p += 3) {
        points[p] -= center[0];
        points[p + 1] -= center[1];
        points[p + 2] -= center[2];
      }
      model._boundsPoly.getPoints().setData(points, 3);
      model._boundsPoly.getPoints().modified();
      model._boundsPoly.getPolys().setData(polys, 1);
      model._boundsPoly.getPolys().modified();
      model._boundsPoly.modified();
    };
    publicAPI.drawDepthRange = (renNode, viewNode) => {
      // copy current depth buffer to
      model._depthRangeTexture.resizeToMatch(model.colorTextureView.getTexture());
      model._depthRangeTexture2.resizeToMatch(model.colorTextureView.getTexture());
      model._depthRangeEncoder.attachTextureViews();
      publicAPI.setCurrentOperation('volumeDepthRangePass');
      renNode.setRenderEncoder(model._depthRangeEncoder);
      renNode.volumeDepthRangePass(true);
      model._mapper.setWebGPURenderer(renNode);
      model._mapper.prepareToDraw(model._depthRangeEncoder);
      model._mapper.registerDrawCallback(model._depthRangeEncoder);
      renNode.volumeDepthRangePass(false);
    };
    publicAPI.createDepthRangeEncoder = viewNode => {
      const device = viewNode.getDevice();
      model._depthRangeEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: 'VolumePass DepthRange'
      });
      model._depthRangeEncoder.setPipelineHash('volr');
      model._depthRangeEncoder.setReplaceShaderCodeFunction(pipeline => {
        const fDesc = pipeline.getShaderDescription('fragment');
        fDesc.addOutput('vec4<f32>', 'outColor1');
        fDesc.addOutput('vec4<f32>', 'outColor2');
        let code = fDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::RenderEncoder::Impl', ['output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);', 'output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);']).result;
        fDesc.setCode(code);
      });
      model._depthRangeEncoder.setDescription({
        colorAttachments: [{
          view: null,
          clearValue: [0.0, 0.0, 0.0, 0.0],
          loadOp: 'clear',
          storeOp: 'store'
        }, {
          view: null,
          clearValue: [1.0, 1.0, 1.0, 1.0],
          loadOp: 'clear',
          storeOp: 'store'
        }]
      });
      model._depthRangeEncoder.setPipelineSettings({
        primitive: {
          cullMode: 'none'
        },
        fragment: {
          targets: [{
            format: 'r16float',
            blend: {
              color: {
                srcFactor: 'one',
                dstFactor: 'one',
                operation: 'max'
              },
              alpha: {
                srcfactor: 'one',
                dstFactor: 'one',
                operation: 'max'
              }
            }
          }, {
            format: 'r16float',
            blend: {
              color: {
                srcFactor: 'one',
                dstFactor: 'one',
                operation: 'min'
              },
              alpha: {
                srcfactor: 'one',
                dstFactor: 'one',
                operation: 'min'
              }
            }
          }]
        }
      });

      // and the textures it needs
      model._depthRangeTexture = vtkWebGPUTexture$1.newInstance({
        label: 'volumePassMaxDepth'
      });
      model._depthRangeTexture.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: 'r16float',
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      const maxView = model._depthRangeTexture.createView('maxTexture');
      model._depthRangeEncoder.setColorTextureView(0, maxView);
      model._depthRangeTexture2 = vtkWebGPUTexture$1.newInstance({
        label: 'volumePassDepthMin'
      });
      model._depthRangeTexture2.create(device, {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: 'r16float',
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      const minView = model._depthRangeTexture2.createView('minTexture');
      model._depthRangeEncoder.setColorTextureView(1, minView);
      model._mapper.setDevice(viewNode.getDevice());
      model._mapper.setTextureViews([model.depthTextureView]);
    };
    publicAPI.createClearEncoder = viewNode => {
      model._colorTexture = vtkWebGPUTexture$1.newInstance({
        label: 'volumePassColor'
      });
      model._colorTexture.create(viewNode.getDevice(), {
        width: viewNode.getCanvas().width,
        height: viewNode.getCanvas().height,
        format: 'bgra8unorm',
        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
      });
      model._colorTextureView = model._colorTexture.createView('volumePassColorTexture');
      model._colorTextureView.addSampler(viewNode.getDevice(), {
        minFilter: 'linear',
        magFilter: 'linear'
      });
      model._clearEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: 'VolumePass Clear'
      });
      model._clearEncoder.setColorTextureView(0, model._colorTextureView);
      model._clearEncoder.setDescription({
        colorAttachments: [{
          view: null,
          clearValue: [0.0, 0.0, 0.0, 0.0],
          loadOp: 'clear',
          storeOp: 'store'
        }]
      });
      model._clearEncoder.setPipelineHash('volpf');
      model._clearEncoder.setPipelineSettings({
        primitive: {
          cullMode: 'none'
        },
        fragment: {
          targets: [{
            format: 'bgra8unorm',
            blend: {
              color: {
                srcFactor: 'src-alpha',
                dstFactor: 'one-minus-src-alpha'
              },
              alpha: {
                srcfactor: 'one',
                dstFactor: 'one-minus-src-alpha'
              }
            }
          }]
        }
      });
    };
    publicAPI.createCopyEncoder = viewNode => {
      model._copyEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: 'volumePassCopy'
      });
      model._copyEncoder.setDescription({
        colorAttachments: [{
          view: null,
          loadOp: 'load',
          storeOp: 'store'
        }]
      });
      model._copyEncoder.setPipelineHash('volcopypf');
      model._copyEncoder.setPipelineSettings({
        primitive: {
          cullMode: 'none'
        },
        fragment: {
          targets: [{
            format: 'rgba16float',
            blend: {
              color: {
                srcFactor: 'one',
                dstFactor: 'one-minus-src-alpha'
              },
              alpha: {
                srcfactor: 'one',
                dstFactor: 'one-minus-src-alpha'
              }
            }
          }]
        }
      });
    };
    publicAPI.createMergeEncoder = viewNode => {
      model._mergeEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: 'volumePassMerge'
      });
      model._mergeEncoder.setColorTextureView(0, model._colorTextureView);
      model._mergeEncoder.setDescription({
        colorAttachments: [{
          view: null,
          loadOp: 'load',
          storeOp: 'store'
        }]
      });
      model._mergeEncoder.setReplaceShaderCodeFunction(pipeline => {
        const fDesc = pipeline.getShaderDescription('fragment');
        fDesc.addOutput('vec4<f32>', 'outColor');
        let code = fDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::RenderEncoder::Impl', ['output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);']).result;
        fDesc.setCode(code);
      });
      model._mergeEncoder.setPipelineHash('volpf');
      model._mergeEncoder.setPipelineSettings({
        primitive: {
          cullMode: 'none'
        },
        fragment: {
          targets: [{
            format: 'bgra8unorm',
            blend: {
              color: {
                srcFactor: 'src-alpha',
                dstFactor: 'one-minus-src-alpha'
              },
              alpha: {
                srcfactor: 'one',
                dstFactor: 'one-minus-src-alpha'
              }
            }
          }]
        }
      });
    };

    // marks modified when needed
    publicAPI.setVolumes = val => {
      if (!model.volumes || model.volumes.length !== val.length) {
        model.volumes = [...val];
        publicAPI.modified();
        return;
      }
      for (let i = 0; i < val.length; i++) {
        if (val[i] !== model.volumes[i]) {
          model.volumes = [...val];
          publicAPI.modified();
          return;
        }
      }
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$8 = {
    colorTextureView: null,
    depthTextureView: null,
    volumes: null
  };

  // ----------------------------------------------------------------------------

  function extend$8(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$8, initialValues);

    // Build VTK API
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    model._mapper = vtkWebGPUSimpleMapper$1.newInstance();
    model._mapper.setFragmentShaderTemplate(DepthBoundsFS);
    model._mapper.getShaderReplacements().set('replaceShaderVolumePass', (hash, pipeline, vertexInput) => {
      const fDesc = pipeline.getShaderDescription('fragment');
      fDesc.addBuiltinInput('vec4<f32>', '@builtin(position) fragPos');
    });
    model._boundsPoly = vtkPolyData$1.newInstance();
    model._lastMTimes = [];
    macro.setGet(publicAPI, model, ['colorTextureView', 'depthTextureView']);

    // Object methods
    vtkWebGPUVolumePass(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$8 = macro.newInstance(extend$8, 'vtkWebGPUVolumePass');

  // ----------------------------------------------------------------------------

  var vtkWebGPUVolumePass$1 = {
    newInstance: newInstance$8,
    extend: extend$8
  };

  const finalBlitFragTemplate = `
//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));

  //VTK::RenderEncoder::Impl
  return output;
}
`;

  // ----------------------------------------------------------------------------

  function vtkForwardPass(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkForwardPass');

    // this pass implements a forward rendering pipeline
    // if both volumes and opaque geometry are present
    // it will mix the two together by capturing a zbuffer
    // first
    publicAPI.traverse = function (viewNode) {
      let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      if (model.deleted) {
        return;
      }

      // we just render our delegates in order
      model._currentParent = parent;

      // build
      publicAPI.setCurrentOperation('buildPass');
      viewNode.traverse(publicAPI);
      if (!model.opaquePass) {
        model.opaquePass = vtkWebGPUOpaquePass$1.newInstance();
      }
      const numlayers = viewNode.getRenderable().getNumberOfLayers();

      // iterate over renderers
      const renderers = viewNode.getChildren();
      for (let i = 0; i < numlayers; i++) {
        for (let index = 0; index < renderers.length; index++) {
          const renNode = renderers[index];
          const ren = viewNode.getRenderable().getRenderers()[index];
          if (ren.getDraw() && ren.getLayer() === i) {
            // check for both opaque and volume actors
            model.opaqueActorCount = 0;
            model.translucentActorCount = 0;
            model.volumes = [];
            publicAPI.setCurrentOperation('queryPass');
            renNode.traverse(publicAPI);
            publicAPI.setCurrentOperation('cameraPass');
            renNode.traverse(publicAPI);

            // always do opaque pass to get a valid color and zbuffer, even if empty
            model.opaquePass.traverse(renNode, viewNode);

            // optional translucent pass
            if (model.translucentActorCount > 0) {
              if (!model.translucentPass) {
                model.translucentPass = vtkWebGPUOrderIndepenentTranslucentPass.newInstance();
              }
              model.translucentPass.setColorTextureView(model.opaquePass.getColorTextureView());
              model.translucentPass.setDepthTextureView(model.opaquePass.getDepthTextureView());
              model.translucentPass.traverse(renNode, viewNode);
            }

            // optional volume pass
            if (model.volumes.length > 0) {
              if (!model.volumePass) {
                model.volumePass = vtkWebGPUVolumePass$1.newInstance();
              }
              model.volumePass.setColorTextureView(model.opaquePass.getColorTextureView());
              model.volumePass.setDepthTextureView(model.opaquePass.getDepthTextureView());
              model.volumePass.setVolumes(model.volumes);
              model.volumePass.traverse(renNode, viewNode);
            }

            // blit the result into the swap chain
            publicAPI.finalPass(viewNode, renNode);
          }
        }
      }
    };
    publicAPI.finalPass = (viewNode, renNode) => {
      if (!model._finalBlitEncoder) {
        publicAPI.createFinalBlitEncoder(viewNode);
      }
      model._finalBlitOutputTextureView.createFromTextureHandle(viewNode.getCurrentTexture(), {
        depth: 1,
        format: viewNode.getPresentationFormat()
      });
      model._finalBlitEncoder.attachTextureViews();
      model._finalBlitEncoder.begin(viewNode.getCommandEncoder());
      renNode.scissorAndViewport(model._finalBlitEncoder);
      model._fullScreenQuad.prepareAndDraw(model._finalBlitEncoder);
      model._finalBlitEncoder.end();
    };
    publicAPI.createFinalBlitEncoder = viewNode => {
      model._finalBlitEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: 'forwardPassBlit'
      });
      model._finalBlitEncoder.setDescription({
        colorAttachments: [{
          view: null,
          loadOp: 'load',
          storeOp: 'store'
        }]
      });
      model._finalBlitEncoder.setPipelineHash('fpf');
      model._finalBlitEncoder.setPipelineSettings({
        primitive: {
          cullMode: 'none'
        },
        fragment: {
          targets: [{
            format: viewNode.getPresentationFormat(),
            blend: {
              color: {
                srcFactor: 'src-alpha',
                dstFactor: 'one-minus-src-alpha'
              },
              alpha: {
                srcfactor: 'one',
                dstFactor: 'one-minus-src-alpha'
              }
            }
          }]
        }
      });
      model._fsqSampler = vtkWebGPUSampler$1.newInstance({
        label: 'finalPassSampler'
      });
      model._fsqSampler.create(viewNode.getDevice(), {
        minFilter: 'linear',
        magFilter: 'linear'
      });
      model._fullScreenQuad = vtkWebGPUFullScreenQuad$1.newInstance();
      model._fullScreenQuad.setDevice(viewNode.getDevice());
      model._fullScreenQuad.setPipelineHash('fpfsq');
      model._fullScreenQuad.setTextureViews([model.opaquePass.getColorTextureView()]);
      model._fullScreenQuad.setAdditionalBindables([model._fsqSampler]);
      model._fullScreenQuad.setFragmentShaderTemplate(finalBlitFragTemplate);
      model._finalBlitOutputTextureView = vtkWebGPUTextureView$1.newInstance();
      model._finalBlitEncoder.setColorTextureView(0, model._finalBlitOutputTextureView);
    };
    publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;
    publicAPI.incrementTranslucentActorCount = () => model.translucentActorCount++;
    publicAPI.addVolume = volume => {
      model.volumes.push(volume);
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$7 = {
    opaqueActorCount: 0,
    translucentActorCount: 0,
    volumes: null,
    opaqueRenderEncoder: null,
    translucentPass: null,
    volumePass: null
  };

  // ----------------------------------------------------------------------------

  function extend$7(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$7, initialValues);

    // Build VTK API
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    macro.setGet(publicAPI, model, ['opaquePass', 'translucentPass', 'volumePass']);

    // Object methods
    vtkForwardPass(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$7 = macro.newInstance(extend$7, 'vtkForwardPass');

  // ----------------------------------------------------------------------------

  var vtkForwardPass$1 = {
    newInstance: newInstance$7,
    extend: extend$7
  };

  const {
    VtkDataTypes
  } = vtkDataArray$1;

  // ----------------------------------------------------------------------------
  // Global methods
  // ----------------------------------------------------------------------------

  // ----------------------------------------------------------------------------
  // vtkWebGPUTextureManager methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUTextureManager(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUTextureManager');

    // fills in request values based on what is missing/provided
    function _fillRequest(req) {
      // fill in values based on imageData if the request has it
      if (req.imageData) {
        req.dataArray = req.imageData.getPointData().getScalars();
        req.time = req.dataArray.getMTime();
        req.nativeArray = req.dataArray.getData();
        const dims = req.imageData.getDimensions();
        req.width = dims[0];
        req.height = dims[1];
        req.depth = dims[2];
        const numComp = req.dataArray.getNumberOfComponents();
        // todo fix handling of 3 component
        switch (numComp) {
          case 1:
            req.format = 'r';
            break;
          case 2:
            req.format = 'rg';
            break;
          case 3:
          case 4:
          default:
            req.format = 'rgba';
            break;
        }
        const dataType = req.dataArray.getDataType();
        switch (dataType) {
          case VtkDataTypes.UNSIGNED_CHAR:
            req.format += '8unorm';
            break;
          // todo extend to other types that are not filterable
          // as they can be useful
          case VtkDataTypes.FLOAT:
          case VtkDataTypes.UNSIGNED_INT:
          case VtkDataTypes.INT:
          case VtkDataTypes.DOUBLE:
          case VtkDataTypes.UNSIGNED_SHORT:
          case VtkDataTypes.SHORT:
          default:
            req.format += '16float';
            break;
        }
      }

      // fill in values based on image if the request has it
      if (req.image) {
        req.width = req.image.width;
        req.height = req.image.height;
        req.depth = 1;
        req.format = 'rgba8unorm';
      }

      // fill in based on js imageData
      if (req.jsImageData) {
        req.width = req.jsImageData.width;
        req.height = req.jsImageData.height;
        req.depth = 1;
        req.format = 'rgba8unorm';
        req.flip = true;
        req.nativeArray = req.jsImageData.data;
      }
      if (req.canvas) {
        req.width = req.canvas.width;
        req.height = req.canvas.height;
        req.depth = 1;
        req.format = 'rgba8unorm';
        req.flip = true;
        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        req.usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT;
        /* eslint-enable no-undef */
        /* eslint-enable no-bitwise */
      }
    }

    // create a texture (used by getTexture)
    function _createTexture(req) {
      const newTex = vtkWebGPUTexture$1.newInstance();
      newTex.create(model.device, {
        width: req.width,
        height: req.height,
        depth: req.depth,
        format: req.format,
        usage: req.usage,
        mipLevel: req.mipLevel
      });

      // fill the texture if we have data
      if (req.nativeArray || req.image || req.canvas) {
        newTex.writeImageData(req);
      }
      return newTex;
    }

    // get a texture or create it if not cached.
    // this is the main entry point
    publicAPI.getTexture = req => {
      // if we have a source the get/create/cache the texture
      if (req.hash) {
        // if a matching texture already exists then return it
        return model.device.getCachedObject(req.hash, _createTexture, req);
      }
      return _createTexture(req);
    };
    publicAPI.getTextureForImageData = imgData => {
      const treq = {
        time: imgData.getMTime()
      };
      treq.imageData = imgData;
      // fill out the req time and format based on imageData/image
      _fillRequest(treq);
      treq.hash = treq.time + treq.format + treq.mipLevel;
      return model.device.getTextureManager().getTexture(treq);
    };
    publicAPI.getTextureForVTKTexture = srcTexture => {
      const treq = {
        time: srcTexture.getMTime()
      };
      if (srcTexture.getInputData()) {
        treq.imageData = srcTexture.getInputData();
      } else if (srcTexture.getImage()) {
        treq.image = srcTexture.getImage();
      } else if (srcTexture.getJsImageData()) {
        treq.jsImageData = srcTexture.getJsImageData();
      } else if (srcTexture.getCanvas()) {
        treq.canvas = srcTexture.getCanvas();
      }
      // fill out the req time and format based on imageData/image
      _fillRequest(treq);
      treq.mipLevel = srcTexture.getMipLevel();
      treq.hash = treq.time + treq.format + treq.mipLevel;
      return model.device.getTextureManager().getTexture(treq);
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$6 = {
    handle: null,
    device: null
  };

  // ----------------------------------------------------------------------------

  function extend$6(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$6, initialValues);

    // Object methods
    macro.obj(publicAPI, model);
    macro.setGet(publicAPI, model, ['device']);
    vtkWebGPUTextureManager(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$6 = macro.newInstance(extend$6);

  // ----------------------------------------------------------------------------

  var vtkWebGPUTextureManager$1 = {
    newInstance: newInstance$6,
    extend: extend$6
  };

  /**
   * provide a simple WeakRefMap class to share device objects based on
   * hash values so that buffers/textures etc can be shared betwen mappers.
   * This is roughly based on WeakLRUCache but without the actual caching
   * behavior. This is just a map of key -> WeakRef(value)
   */

  /* eslint-disable no-undef */
  class WeakRefMap extends Map {
    constructor() {
      super();
      this.registry = new FinalizationRegistry(key => {
        const entry = super.get(key);
        if (entry && entry.deref && entry.deref() === undefined) super.delete(key);
      });
    }
    getValue(key) {
      const entry = super.get(key);
      if (entry) {
        const value = entry.deref();
        if (value !== undefined) return value;
        super.delete(key);
      }
      return undefined;
    }
    setValue(key, value) {
      let entry;
      if (value && typeof value === 'object') {
        entry = new WeakRef(value);
        this.registry.register(value, key);
        super.set(key, entry);
      }
      // else entry is undefined
      return entry;
    }
  }
  /* eslint-enable no-undef */

  // ----------------------------------------------------------------------------
  // vtkWebGPUDevice methods
  // ----------------------------------------------------------------------------
  function vtkWebGPUDevice(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUDevice');
    publicAPI.initialize = handle => {
      model.handle = handle;
    };
    publicAPI.createCommandEncoder = () => model.handle.createCommandEncoder();
    publicAPI.submitCommandEncoder = commandEncoder => {
      model.handle.queue.submit([commandEncoder.finish()]);
    };
    publicAPI.getShaderModule = sd => model.shaderCache.getShaderModule(sd);

    /* eslint-disable no-bitwise */
    /* eslint-disable no-undef */
    publicAPI.getBindGroupLayout = val => {
      if (!val.entries) {
        return null;
      }

      // add in basic required values if missing
      for (let i = 0; i < val.entries.length; i++) {
        const ent = val.entries[i];
        ent.binding = ent.binding || 0;
        ent.visibility = ent.visibility || GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT;
      }

      // do we already have one?
      const sval = JSON.stringify(val);
      for (let i = 0; i < model.bindGroupLayouts.length; i++) {
        if (model.bindGroupLayouts[i].sval === sval) {
          return model.bindGroupLayouts[i].layout;
        }
      }

      // create one and store it
      const layout = model.handle.createBindGroupLayout(val);

      // we actually only store the stringified version
      // as that is what we always compare against
      model.bindGroupLayouts.push({
        sval,
        layout
      });
      return layout;
    };
    publicAPI.getBindGroupLayoutDescription = layout => {
      for (let i = 0; i < model.bindGroupLayouts.length; i++) {
        if (model.bindGroupLayouts[i].layout === layout) {
          return model.bindGroupLayouts[i].sval;
        }
      }
      vtkErrorMacro('layout not found');
      console.trace();
      return null;
    };
    publicAPI.getPipeline = hash => {
      if (hash in model.pipelines) {
        return model.pipelines[hash];
      }
      return null;
    };
    publicAPI.createPipeline = (hash, pipeline) => {
      pipeline.initialize(publicAPI, hash);
      model.pipelines[hash] = pipeline;
    };
    publicAPI.onSubmittedWorkDone = () => model.handle.queue.onSubmittedWorkDone();

    // The Device has an object cache that can be used to cache buffers,
    // textures and other objects that can be shared. The basic approach is to
    // call getCachedObject with a request and a create function. The request
    // is based on a hash. The cache lookup just returns any entry that has a
    // matching hash. If a match isn't found then the create function is
    // called with any extra arguments.

    // is the object already cached?
    publicAPI.hasCachedObject = hash => model.objectCache.getValue(hash);
    publicAPI.getCachedObject = function (hash, creator) {
      if (!hash) {
        vtkErrorMacro('attempt to cache an object without a hash');
        return null;
      }
      const existingValue = model.objectCache.getValue(hash);
      if (existingValue) {
        return existingValue;
      }
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      const createdObject = creator(...args);
      model.objectCache.setValue(hash, createdObject);
      return createdObject;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------
  const DEFAULT_VALUES$5 = {
    handle: null,
    pipelines: null,
    shaderCache: null,
    bindGroupLayouts: null,
    bufferManager: null,
    textureManager: null
  };

  // ----------------------------------------------------------------------------
  function extend$5(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$5, initialValues);

    // Build VTK API
    obj(publicAPI, model);
    setGet(publicAPI, model, ['handle']);
    get$1(publicAPI, model, ['bufferManager', 'shaderCache', 'textureManager']);

    // this is a weak ref cache implementation, we create it without
    // an expirer (so it is strictly based on garbage collection and
    // objects are not held if there are no external references)
    // model.objectCache = new WeakLRUCache({ expirer: false });
    model.objectCache = new WeakRefMap();
    model.shaderCache = vtkWebGPUShaderCache$1.newInstance();
    model.shaderCache.setDevice(publicAPI);
    model.bindGroupLayouts = [];
    model.bufferManager = vtkWebGPUBufferManager$1.newInstance();
    model.bufferManager.setDevice(publicAPI);
    model.textureManager = vtkWebGPUTextureManager$1.newInstance();
    model.textureManager.setDevice(publicAPI);
    model.pipelines = {};

    // For more macro methods, see "Sources/macros.js"
    // Object specific methods
    vtkWebGPUDevice(publicAPI, model);
  }

  // ----------------------------------------------------------------------------
  const newInstance$5 = newInstance$1I(extend$5, 'vtkWebGPUDevice');

  // ----------------------------------------------------------------------------
  var vtkWebGPUDevice$1 = {
    newInstance: newInstance$5,
    extend: extend$5
  };

  // ----------------------------------------------------------------------------

  function vtkWebGPUHardwareSelectionPass(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUHardwareSelectionPass');

    // this pass implements a forward rendering pipeline
    // if both volumes and opaque geometry are present
    // it will mix the two together by capturing a zbuffer
    // first
    publicAPI.traverse = (viewNode, renNode) => {
      if (model.deleted) {
        return;
      }
      model._currentParent = null;

      // build
      publicAPI.setCurrentOperation('buildPass');
      viewNode.traverse(publicAPI);
      const device = viewNode.getDevice();
      if (!model.selectionRenderEncoder) {
        publicAPI.createRenderEncoder();

        // create color texture
        model.colorTexture = vtkWebGPUTexture$1.newInstance({
          label: 'hardwareSelectorColor'
        });
        model.colorTexture.create(device, {
          width: viewNode.getCanvas().width,
          height: viewNode.getCanvas().height,
          format: 'rgba32uint',
          /* eslint-disable no-undef */
          /* eslint-disable no-bitwise */
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
        });
        const v1 = model.colorTexture.createView('hardwareSelectColorTexture');
        model.selectionRenderEncoder.setColorTextureView(0, v1);

        // create depth texture
        model.depthTexture = vtkWebGPUTexture$1.newInstance({
          label: 'hardwareSelectorDepth'
        });
        model.depthTexture.create(device, {
          width: viewNode.getCanvas().width,
          height: viewNode.getCanvas().height,
          format: 'depth32float',
          /* eslint-disable no-undef */
          /* eslint-disable no-bitwise */
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
        });
        const v2 = model.depthTexture.createView('hardwareSelectDepthTexture');
        model.selectionRenderEncoder.setDepthTextureView(v2);
      } else {
        model.colorTexture.resize(viewNode.getCanvas().width, viewNode.getCanvas().height);
        model.depthTexture.resizeToMatch(model.colorTexture);
      }
      model.selectionRenderEncoder.attachTextureViews();
      renNode.setRenderEncoder(model.selectionRenderEncoder);
      publicAPI.setCurrentOperation('cameraPass');
      renNode.traverse(publicAPI);
      // opaque pass is used for selection
      publicAPI.setCurrentOperation('opaquePass');
      renNode.traverse(publicAPI);
    };
    publicAPI.createRenderEncoder = () => {
      model.selectionRenderEncoder = vtkWebGPURenderEncoder$1.newInstance({
        label: 'HardwareSelectionPass'
      });
      // default settings are fine for this
      model.selectionRenderEncoder.setPipelineHash('sel');
      model.selectionRenderEncoder.setReplaceShaderCodeFunction(pipeline => {
        const fDesc = pipeline.getShaderDescription('fragment');
        fDesc.addOutput('vec4<u32>', 'outColor');
        let code = fDesc.getCode();
        code = vtkWebGPUShaderCache$1.substitute(code, '//VTK::RenderEncoder::Impl', ['output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);']).result;
        fDesc.setCode(code);
      });
      const renDesc = model.selectionRenderEncoder.getDescription();
      renDesc.colorAttachments[0].clearValue = [0.0, 0.0, 0.0, 0.0];
      model.selectionRenderEncoder.setPipelineSettings({
        primitive: {
          cullMode: 'none'
        },
        depthStencil: {
          depthWriteEnabled: true,
          depthCompare: 'greater',
          format: 'depth32float'
        },
        fragment: {
          targets: [{
            format: 'rgba32uint',
            blend: undefined
          }]
        }
      });
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$4 = {
    selectionRenderEncoder: null,
    colorTexture: null,
    depthTexture: null
  };

  // ----------------------------------------------------------------------------

  function extend$4(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$4, initialValues);

    // Build VTK API
    vtkRenderPass$1.extend(publicAPI, model, initialValues);
    macro.get(publicAPI, model, ['colorTexture', 'depthTexture']);

    // Object methods
    vtkWebGPUHardwareSelectionPass(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$4 = macro.newInstance(extend$4, 'vtkWebGPUHardwareSelectionPass');

  // ----------------------------------------------------------------------------

  var vtkWebGPUHardwareSelectionPass$1 = {
    newInstance: newInstance$4,
    extend: extend$4
  };

  const {
    SelectionContent,
    SelectionField
  } = vtkSelectionNode$1;
  const {
    FieldAssociations
  } = vtkDataSet$1;
  const {
    vtkErrorMacro: vtkErrorMacro$4
  } = macro;
  function getInfoHash(info) {
    return `${info.propID} ${info.compositeID}`;
  }
  function convert(xx, yy, buffdata, channel) {
    const offset = ((buffdata.height - yy - 1) * buffdata.colorBufferWidth + xx) * 4 + channel;
    return buffdata.colorValues[offset];
  }
  function getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
    // Base case
    const maxDist = maxDistance < 0 ? 0 : maxDistance;
    if (maxDist === 0) {
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      if (inDisplayPosition[0] < 0 || inDisplayPosition[0] >= buffdata.width || inDisplayPosition[1] < 0 || inDisplayPosition[1] >= buffdata.height) {
        return null;
      }
      const actorid = convert(inDisplayPosition[0], inDisplayPosition[1], buffdata, 0);
      if (actorid <= 0) {
        // the pixel did not hit any actor.
        return null;
      }
      const info = {};
      info.propID = actorid;
      let compositeID = convert(inDisplayPosition[0], inDisplayPosition[1], buffdata, 1);
      if (compositeID < 0 || compositeID > 0xffffff) {
        compositeID = 0;
      }
      info.compositeID = compositeID;
      if (buffdata.captureZValues) {
        const offset = (buffdata.height - inDisplayPosition[1] - 1) * buffdata.zbufferBufferWidth + inDisplayPosition[0];
        info.zValue = buffdata.depthValues[offset];
        info.zValue = buffdata.webGPURenderer.convertToOpenGLDepth(info.zValue);
        info.displayPosition = inDisplayPosition;
      }
      return info;
    }

    // Iterate over successively growing boxes.
    // They recursively call the base case to handle single pixels.
    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
    const curPos = [0, 0];
    let info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);
    if (info) {
      return info;
    }
    for (let dist = 1; dist < maxDist; ++dist) {
      // Vertical sides of box.
      for (let y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
        curPos[1] = y;
        if (dispPos[0] >= dist) {
          curPos[0] = dispPos[0] - dist;
          info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
          if (info) {
            return info;
          }
        }
        curPos[0] = dispPos[0] + dist;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info) {
          return info;
        }
      }
      // Horizontal sides of box.
      for (let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
        curPos[0] = x;
        if (dispPos[1] >= dist) {
          curPos[1] = dispPos[1] - dist;
          info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
          if (info) {
            return info;
          }
        }
        curPos[1] = dispPos[1] + dist;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info) {
          return info;
        }
      }
    }

    // nothing hit.
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    return null;
  }

  //-----------------------------------------------------------------------------
  function convertSelection(fieldassociation, dataMap, buffdata) {
    const sel = [];
    let count = 0;
    dataMap.forEach((value, key) => {
      const child = vtkSelectionNode$1.newInstance();
      child.setContentType(SelectionContent.INDICES);
      switch (fieldassociation) {
        case FieldAssociations.FIELD_ASSOCIATION_CELLS:
          child.setFieldType(SelectionField.CELL);
          break;
        case FieldAssociations.FIELD_ASSOCIATION_POINTS:
          child.setFieldType(SelectionField.POINT);
          break;
        default:
          vtkErrorMacro$4('Unknown field association');
      }
      child.getProperties().propID = value.info.propID;
      const wprop = buffdata.webGPURenderer.getPropFromID(value.info.propID);
      child.getProperties().prop = wprop.getRenderable();
      child.getProperties().compositeID = value.info.compositeID;
      child.getProperties().pixelCount = value.pixelCount;
      if (buffdata.captureZValues) {
        child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
        child.getProperties().worldPosition = buffdata.webGPURenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, buffdata.renderer);
      }
      child.setSelectionList(value.attributeIDs);
      sel[count] = child;
      count++;
    });
    return sel;
  }

  //----------------------------------------------------------------------------
  function generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {
    const x1 = Math.floor(fx1);
    const y1 = Math.floor(fy1);
    const x2 = Math.floor(fx2);
    const y2 = Math.floor(fy2);
    const dataMap = new Map();
    const outSelectedPosition = [0, 0];
    for (let yy = y1; yy <= y2; yy++) {
      for (let xx = x1; xx <= x2; xx++) {
        const pos = [xx, yy];
        const info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);
        if (info) {
          const hash = getInfoHash(info);
          if (!dataMap.has(hash)) {
            dataMap.set(hash, {
              info,
              pixelCount: 1,
              attributeIDs: [info.attributeID]
            });
          } else {
            const dmv = dataMap.get(hash);
            dmv.pixelCount++;
            if (buffdata.captureZValues) {
              if (info.zValue < dmv.info.zValue) {
                dmv.info = info;
              }
            }
            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
              dmv.attributeIDs.push(info.attributeID);
            }
          }
        }
      }
    }
    return convertSelection(buffdata.fieldAssociation, dataMap, buffdata);
  }

  // ----------------------------------------------------------------------------
  // vtkWebGPUHardwareSelector methods
  // ----------------------------------------------------------------------------

  function vtkWebGPUHardwareSelector(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPUHardwareSelector');

    //----------------------------------------------------------------------------
    publicAPI.endSelection = () => {
      model.WebGPURenderer.setSelector(null);
    };

    //----------------------------------------------------------------------------
    // note we ignore the x,y arguments as WebGPU has to do buffer copies
    // of the entire depth bufer. We could realloc hardware selection textures
    // based on the passed in size etc but it gets messy so for now we always
    // render the full size window and copy it to the buffers.
    publicAPI.getSourceDataAsync = async renderer => {
      if (!renderer || !model._WebGPURenderWindow) {
        vtkErrorMacro$4('Renderer and view must be set before calling Select.');
        return false;
      }

      // todo revisit making selection part of core
      // then we can do this in core
      model._WebGPURenderWindow.getRenderable().preRender();
      if (!model._WebGPURenderWindow.getInitialized()) {
        model._WebGPURenderWindow.initialize();
        await new Promise(resolve => {
          model._WebGPURenderWindow.onInitialized(resolve);
        });
      }
      const webGPURenderer = model._WebGPURenderWindow.getViewNodeFor(renderer);
      if (!webGPURenderer) {
        return false;
      }

      // Initialize renderer for selection.
      // change the renderer's background to black, which will indicate a miss
      const originalSuppress = webGPURenderer.getSuppressClear();
      webGPURenderer.setSuppressClear(true);
      model._selectionPass.traverse(model._WebGPURenderWindow, webGPURenderer);

      // restore original background
      webGPURenderer.setSuppressClear(originalSuppress);
      const device = model._WebGPURenderWindow.getDevice();
      const texture = model._selectionPass.getColorTexture();
      const depthTexture = model._selectionPass.getDepthTexture();

      // as this is async we really don't want to store things in
      // the class as multiple calls may start before resolving
      // so anything specific to this request gets put into the
      // result object (by value in most cases)
      const result = {
        area: [0, 0, texture.getWidth() - 1, texture.getHeight() - 1],
        captureZValues: model.captureZValues,
        fieldAssociation: model.fieldAssociation,
        renderer,
        webGPURenderer,
        webGPURenderWindow: model._WebGPURenderWindow,
        width: texture.getWidth(),
        height: texture.getHeight()
      };

      // must be a multiple of 256 bytes, so 16 texels with rgba32uint
      result.colorBufferWidth = 16 * Math.floor((result.width + 15) / 16);
      result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 4 * 4;
      const colorBuffer = vtkWebGPUBuffer$1.newInstance({
        label: 'hardwareSelectColorBuffer'
      });
      colorBuffer.setDevice(device);
      /* eslint-disable no-bitwise */
      /* eslint-disable no-undef */
      colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
      /* eslint-enable no-bitwise */
      /* eslint-enable no-undef */

      const cmdEnc = model._WebGPURenderWindow.getCommandEncoder();
      cmdEnc.copyTextureToBuffer({
        texture: texture.getHandle()
      }, {
        buffer: colorBuffer.getHandle(),
        bytesPerRow: 16 * result.colorBufferWidth,
        rowsPerImage: result.height
      }, {
        width: result.width,
        height: result.height,
        depthOrArrayLayers: 1
      });
      let zbuffer;
      if (model.captureZValues) {
        result.zbufferBufferWidth = 64 * Math.floor((result.width + 63) / 64);
        zbuffer = vtkWebGPUBuffer$1.newInstance({
          label: 'hardwareSelectDepthBuffer'
        });
        zbuffer.setDevice(device);
        result.zbufferSizeInBytes = result.height * result.zbufferBufferWidth * 4;
        /* eslint-disable no-bitwise */
        /* eslint-disable no-undef */
        zbuffer.create(result.zbufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
        /* eslint-enable no-bitwise */
        /* eslint-enable no-undef */

        cmdEnc.copyTextureToBuffer({
          texture: depthTexture.getHandle(),
          aspect: 'depth-only'
        }, {
          buffer: zbuffer.getHandle(),
          bytesPerRow: 4 * result.zbufferBufferWidth,
          rowsPerImage: result.height
        }, {
          width: result.width,
          height: result.height,
          depthOrArrayLayers: 1
        });
      }
      device.submitCommandEncoder(cmdEnc);

      /* eslint-disable no-undef */
      const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);
      if (model.captureZValues) {
        const zLoad = zbuffer.mapAsync(GPUMapMode.READ);
        await Promise.all([cLoad, zLoad]);
        result.depthValues = new Float32Array(zbuffer.getMappedRange().slice());
        zbuffer.unmap();
      } else {
        await cLoad;
      }
      /* eslint-enable no-undef */

      result.colorValues = new Uint32Array(colorBuffer.getMappedRange().slice());
      colorBuffer.unmap();
      result.generateSelection = (fx1, fy1, fx2, fy2) => generateSelectionWithData(result, fx1, fy1, fx2, fy2);
      return result;
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$3 = {
    // WebGPURenderWindow: null,
  };

  // ----------------------------------------------------------------------------

  function extend$3(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$3, initialValues);

    // Build VTK API
    vtkHardwareSelector$1$1.extend(publicAPI, model, initialValues);
    model._selectionPass = vtkWebGPUHardwareSelectionPass$1.newInstance();
    macro.setGet(publicAPI, model, ['_WebGPURenderWindow']);
    macro.moveToProtected(publicAPI, model, ['WebGPURenderWindow']);

    // Object methods
    vtkWebGPUHardwareSelector(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$3 = macro.newInstance(extend$3, 'vtkWebGPUHardwareSelector');

  // ----------------------------------------------------------------------------

  var vtkWebGPUHardwareSelector$1 = {
    newInstance: newInstance$3,
    extend: extend$3
  };

  const {
    vtkErrorMacro: vtkErrorMacro$3
  } = macro;
  // const IS_CHROME = navigator.userAgent.indexOf('Chrome') !== -1;
  const SCREENSHOT_PLACEHOLDER = {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%'
  };

  // ----------------------------------------------------------------------------
  // vtkWebGPURenderWindow methods
  // ----------------------------------------------------------------------------

  function vtkWebGPURenderWindow(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkWebGPURenderWindow');
    publicAPI.getViewNodeFactory = () => model.myFactory;

    // Auto update style
    const previousSize = [0, 0];
    function updateWindow() {
      // Canvas size
      if (model.renderable) {
        if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
          previousSize[0] = model.size[0];
          previousSize[1] = model.size[1];
          model.canvas.setAttribute('width', model.size[0]);
          model.canvas.setAttribute('height', model.size[1]);
          publicAPI.recreateSwapChain();
        }
      }

      // ImageStream size
      if (model.viewStream) {
        // If same size that's a NoOp
        model.viewStream.setSize(model.size[0], model.size[1]);
      }

      // Offscreen ?
      model.canvas.style.display = model.useOffScreen ? 'none' : 'block';

      // Cursor type
      if (model.el) {
        model.el.style.cursor = model.cursorVisibility ? model.cursor : 'none';
      }

      // Invalidate cached DOM container size
      model.containerSize = null;
    }
    publicAPI.onModified(updateWindow);
    publicAPI.recreateSwapChain = () => {
      if (model.context) {
        model.context.unconfigure();
        model.presentationFormat = navigator.gpu.getPreferredCanvasFormat(model.adapter);

        /* eslint-disable no-undef */
        /* eslint-disable no-bitwise */
        model.context.configure({
          device: model.device.getHandle(),
          format: model.presentationFormat,
          alphaMode: 'premultiplied',
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,
          width: model.size[0],
          height: model.size[1]
        });
        model._configured = true;
      }
    };
    publicAPI.getCurrentTexture = () => model.context.getCurrentTexture();

    // Builds myself.
    publicAPI.buildPass = prepass => {
      if (prepass) {
        if (!model.renderable) {
          return;
        }
        publicAPI.prepareNodes();
        publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
        publicAPI.removeUnusedNodes();
        publicAPI.initialize();
      } else if (model.initialized) {
        if (!model._configured) {
          publicAPI.recreateSwapChain();
        }
        model.commandEncoder = model.device.createCommandEncoder();
      }
    };

    // publicAPI.traverseRenderers = (renPass) => {
    //   // iterate over renderers
    //   const numlayers = publicAPI.getRenderable().getNumberOfLayers();
    //   const renderers = publicAPI.getChildren();
    //   for (let i = 0; i < numlayers; i++) {
    //     for (let index = 0; index < renderers.length; index++) {
    //       const renNode = renderers[index];
    //       const ren = publicAPI.getRenderable().getRenderers()[index];
    //       if (ren.getDraw() && ren.getLayer() === i) {
    //         renNode.traverse(renPass);
    //       }
    //     }
    //   }
    // };

    publicAPI.initialize = () => {
      if (!model.initializing) {
        model.initializing = true;
        if (!navigator.gpu) {
          vtkErrorMacro$3('WebGPU is not enabled.');
          return;
        }
        publicAPI.create3DContextAsync().then(() => {
          model.initialized = true;
          if (model.deleted) {
            return;
          }
          publicAPI.invokeInitialized();
        });
      }
    };
    publicAPI.setContainer = el => {
      if (model.el && model.el !== el) {
        if (model.canvas.parentNode !== model.el) {
          vtkErrorMacro$3('Error: canvas parent node does not match container');
        }

        // Remove canvas from previous container
        model.el.removeChild(model.canvas);

        // If the renderer has previously added
        // a background image, remove it from the DOM.
        if (model.el.contains(model.bgImage)) {
          model.el.removeChild(model.bgImage);
        }
      }
      if (model.el !== el) {
        model.el = el;
        if (model.el) {
          model.el.appendChild(model.canvas);

          // If the renderer is set to use a background
          // image, attach it to the DOM.
          if (model.useBackgroundImage) {
            model.el.appendChild(model.bgImage);
          }
        }

        // Trigger modified()
        publicAPI.modified();
      }
    };
    publicAPI.getContainer = () => model.el;
    publicAPI.getContainerSize = () => {
      if (!model.containerSize && model.el) {
        const {
          width,
          height
        } = model.el.getBoundingClientRect();
        model.containerSize = [width, height];
      }
      return model.containerSize || model.size;
    };
    publicAPI.getFramebufferSize = () => model.size;
    publicAPI.create3DContextAsync = async () => {
      // Get a GPU device to render with
      model.adapter = await navigator.gpu.requestAdapter({
        powerPreference: 'high-performance'
      });
      if (model.deleted) {
        return;
      }
      // console.log([...model.adapter.features]);
      model.device = vtkWebGPUDevice$1.newInstance();
      model.device.initialize(await model.adapter.requestDevice());
      if (model.deleted) {
        model.device = null;
        return;
      }
      // model.device.getHandle().lost.then((info) => {
      //   console.log(`${info.message}`);
      //   publicAPI.releaseGraphicsResources();
      // });
      model.context = model.canvas.getContext('webgpu');
    };
    publicAPI.releaseGraphicsResources = () => {
      const rp = vtkRenderPass$1.newInstance();
      rp.setCurrentOperation('Release');
      rp.traverse(publicAPI, null);
      model.adapter = null;
      model.device = null;
      model.context = null;
      model.initialized = false;
      model.initializing = false;
    };
    publicAPI.setBackgroundImage = img => {
      model.bgImage.src = img.src;
    };
    publicAPI.setUseBackgroundImage = value => {
      model.useBackgroundImage = value;

      // Add or remove the background image from the
      // DOM as specified.
      if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
        model.el.appendChild(model.bgImage);
      } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    };
    async function getCanvasDataURL() {
      let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : model.imageFormat;
      // Copy current canvas to not modify the original
      const temporaryCanvas = document.createElement('canvas');
      const temporaryContext = temporaryCanvas.getContext('2d');
      temporaryCanvas.width = model.canvas.width;
      temporaryCanvas.height = model.canvas.height;
      const result = await publicAPI.getPixelsAsync();
      const imageData = new ImageData(result.colorValues, result.width, result.height);
      // temporaryCanvas.putImageData(imageData, 0, 0);
      temporaryContext.putImageData(imageData, 0, 0);

      // Get current client rect to place canvas
      const mainBoundingClientRect = model.canvas.getBoundingClientRect();
      const renderWindow = model.renderable;
      const renderers = renderWindow.getRenderers();
      renderers.forEach(renderer => {
        const viewProps = renderer.getViewProps();
        viewProps.forEach(viewProp => {
          // Check if the prop has a container that should have canvas
          if (viewProp.getContainer) {
            const container = viewProp.getContainer();
            const canvasList = container.getElementsByTagName('canvas');
            // Go throughout all canvas and copy it into temporary main canvas
            for (let i = 0; i < canvasList.length; i++) {
              const currentCanvas = canvasList[i];
              const boundingClientRect = currentCanvas.getBoundingClientRect();
              const newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
              const newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
              temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
            }
          }
        });
      });
      const screenshot = temporaryCanvas.toDataURL(format);
      temporaryCanvas.remove();
      publicAPI.invokeImageReady(screenshot);
    }
    publicAPI.captureNextImage = function () {
      let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';
      let {
        resetCamera = false,
        size = null,
        scale = 1
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (model.deleted) {
        return null;
      }
      model.imageFormat = format;
      const previous = model.notifyStartCaptureImage;
      model.notifyStartCaptureImage = true;
      model._screenshot = {
        size: !!size || scale !== 1 ? size || model.size.map(val => val * scale) : null
      };
      return new Promise((resolve, reject) => {
        const subscription = publicAPI.onImageReady(imageURL => {
          if (model._screenshot.size === null) {
            model.notifyStartCaptureImage = previous;
            subscription.unsubscribe();
            if (model._screenshot.placeHolder) {
              // resize the main canvas back to its original size and show it
              model.size = model._screenshot.originalSize;

              // process the resize
              publicAPI.modified();

              // restore the saved camera parameters, if applicable
              if (model._screenshot.cameras) {
                model._screenshot.cameras.forEach(_ref => {
                  let {
                    restoreParamsFn,
                    arg
                  } = _ref;
                  return restoreParamsFn(arg);
                });
              }

              // Trigger a render at the original size
              publicAPI.traverseAllPasses();

              // Remove and clean up the placeholder, revealing the original
              model.el.removeChild(model._screenshot.placeHolder);
              model._screenshot.placeHolder.remove();
              model._screenshot = null;
            }
            resolve(imageURL);
          } else {
            // Create a placeholder image overlay while we resize and render
            const tmpImg = document.createElement('img');
            tmpImg.style = SCREENSHOT_PLACEHOLDER;
            tmpImg.src = imageURL;
            model._screenshot.placeHolder = model.el.appendChild(tmpImg);

            // hide the main canvas
            model.canvas.style.display = 'none';

            // remember the main canvas original size, then resize it
            model._screenshot.originalSize = model.size;
            model.size = model._screenshot.size;
            model._screenshot.size = null;

            // process the resize
            publicAPI.modified();
            if (resetCamera) {
              const isUserResetCamera = resetCamera !== true;

              // If resetCamera was requested, we first save camera parameters
              // from all the renderers, so we can restore them later
              model._screenshot.cameras = model.renderable.getRenderers().map(renderer => {
                const camera = renderer.getActiveCamera();
                const params = camera.get('focalPoint', 'position', 'parallelScale');
                return {
                  resetCameraArgs: isUserResetCamera ? {
                    renderer
                  } : undefined,
                  resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,
                  restoreParamsFn: camera.set,
                  // "clone" the params so we don't keep refs to properties
                  arg: JSON.parse(JSON.stringify(params))
                };
              });

              // Perform the resetCamera() on each renderer only after capturing
              // the params from all active cameras, in case there happen to be
              // linked cameras among the renderers.
              model._screenshot.cameras.forEach(_ref2 => {
                let {
                  resetCameraFn,
                  resetCameraArgs
                } = _ref2;
                return resetCameraFn(resetCameraArgs);
              });
            }

            // Trigger a render at the custom size
            publicAPI.traverseAllPasses();
          }
        });
      });
    };
    publicAPI.traverseAllPasses = () => {
      if (model.deleted) {
        return;
      }
      // if we are not initialized then we call initialize
      // which is async so we will not actually get a render
      // so we queue up another traverse for when we are initialized
      if (!model.initialized) {
        publicAPI.initialize();
        const subscription = publicAPI.onInitialized(() => {
          subscription.unsubscribe();
          publicAPI.traverseAllPasses();
        });
      } else {
        if (model.renderPasses) {
          for (let index = 0; index < model.renderPasses.length; ++index) {
            model.renderPasses[index].traverse(publicAPI, null);
          }
        }
        if (model.commandEncoder) {
          model.device.submitCommandEncoder(model.commandEncoder);
          model.commandEncoder = null;
          if (model.notifyStartCaptureImage) {
            model.device.onSubmittedWorkDone().then(() => {
              getCanvasDataURL();
            });
          }
        }
      }
    };
    publicAPI.setViewStream = stream => {
      if (model.viewStream === stream) {
        return false;
      }
      if (model.subscription) {
        model.subscription.unsubscribe();
        model.subscription = null;
      }
      model.viewStream = stream;
      if (model.viewStream) {
        // Force background to be transparent + render
        const mainRenderer = model.renderable.getRenderers()[0];
        mainRenderer.getBackgroundByReference()[3] = 0;

        // Enable display of the background image
        publicAPI.setUseBackgroundImage(true);

        // Bind to remote stream
        model.subscription = model.viewStream.onImageReady(e => publicAPI.setBackgroundImage(e.image));
        model.viewStream.setSize(model.size[0], model.size[1]);
        model.viewStream.invalidateCache();
        model.viewStream.render();
        publicAPI.modified();
      }
      return true;
    };
    publicAPI.getUniquePropID = () => model.nextPropID++;
    publicAPI.getPropFromID = id => {
      for (let i = 0; i < model.children.length; i++) {
        const res = model.children[i].getPropFromID(id);
        if (res !== null) {
          return res;
        }
      }
      return null;
    };
    publicAPI.getPixelsAsync = async () => {
      const device = model.device;
      const texture = model.renderPasses[0].getOpaquePass().getColorTexture();

      // as this is async we really don't want to store things in
      // the class as multiple calls may start before resolving
      // so anything specific to this request gets put into the
      // result object (by value in most cases)
      const result = {
        width: texture.getWidth(),
        height: texture.getHeight()
      };

      // must be a multiple of 256 bytes, so 32 texels with rgba16
      result.colorBufferWidth = 32 * Math.floor((result.width + 31) / 32);
      result.colorBufferSizeInBytes = result.colorBufferWidth * result.height * 8;
      const colorBuffer = vtkWebGPUBuffer$1.newInstance();
      colorBuffer.setDevice(device);
      /* eslint-disable no-bitwise */
      /* eslint-disable no-undef */
      colorBuffer.create(result.colorBufferSizeInBytes, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
      /* eslint-enable no-bitwise */
      /* eslint-enable no-undef */

      const cmdEnc = model.device.createCommandEncoder();
      cmdEnc.copyTextureToBuffer({
        texture: texture.getHandle()
      }, {
        buffer: colorBuffer.getHandle(),
        bytesPerRow: 8 * result.colorBufferWidth,
        rowsPerImage: result.height
      }, {
        width: result.width,
        height: result.height,
        depthOrArrayLayers: 1
      });
      device.submitCommandEncoder(cmdEnc);

      /* eslint-disable no-undef */
      const cLoad = colorBuffer.mapAsync(GPUMapMode.READ);
      await cLoad;
      /* eslint-enable no-undef */

      result.colorValues = new Uint16Array(colorBuffer.getMappedRange().slice());
      colorBuffer.unmap();
      // repack the array
      const tmparray = new Uint8ClampedArray(result.height * result.width * 4);
      for (let y = 0; y < result.height; y++) {
        for (let x = 0; x < result.width; x++) {
          const doffset = (y * result.width + x) * 4;
          const soffset = (y * result.colorBufferWidth + x) * 4;
          tmparray[doffset] = 255.0 * HalfFloat.fromHalf(result.colorValues[soffset]);
          tmparray[doffset + 1] = 255.0 * HalfFloat.fromHalf(result.colorValues[soffset + 1]);
          tmparray[doffset + 2] = 255.0 * HalfFloat.fromHalf(result.colorValues[soffset + 2]);
          tmparray[doffset + 3] = 255.0 * HalfFloat.fromHalf(result.colorValues[soffset + 3]);
        }
      }
      result.colorValues = tmparray;
      return result;
    };
    publicAPI.createSelector = () => {
      const ret = vtkWebGPUHardwareSelector$1.newInstance();
      ret.setWebGPURenderWindow(publicAPI);
      return ret;
    };
    const superSetSize = publicAPI.setSize;
    publicAPI.setSize = (width, height) => {
      const modified = superSetSize(width, height);
      if (modified) {
        publicAPI.invokeWindowResizeEvent({
          width,
          height
        });
      }
      return modified;
    };
    publicAPI.delete = macro.chain(publicAPI.delete, publicAPI.setViewStream);
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$2 = {
    initialized: false,
    context: null,
    adapter: null,
    device: null,
    canvas: null,
    cursorVisibility: true,
    cursor: 'pointer',
    containerSize: null,
    renderPasses: [],
    notifyStartCaptureImage: false,
    imageFormat: 'image/png',
    useOffScreen: false,
    useBackgroundImage: false,
    nextPropID: 1,
    xrSupported: false,
    presentationFormat: null
  };

  // ----------------------------------------------------------------------------

  function extend$2(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$2, initialValues);

    // Create internal instances
    model.canvas = document.createElement('canvas');
    model.canvas.style.width = '100%';

    // Create internal bgImage
    model.bgImage = new Image();
    model.bgImage.style.position = 'absolute';
    model.bgImage.style.left = '0';
    model.bgImage.style.top = '0';
    model.bgImage.style.width = '100%';
    model.bgImage.style.height = '100%';
    model.bgImage.style.zIndex = '-1';

    // Inheritance
    vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);
    model.myFactory = vtkWebGPUViewNodeFactory$1.newInstance();
    /* eslint-disable no-use-before-define */
    model.myFactory.registerOverride('vtkRenderWindow', newInstance$2);
    /* eslint-enable no-use-before-define */

    // setup default forward pass rendering
    model.renderPasses[0] = vtkForwardPass$1.newInstance();
    if (!model.selector) {
      model.selector = vtkWebGPUHardwareSelector$1.newInstance();
      model.selector.setWebGPURenderWindow(publicAPI);
    }
    macro.event(publicAPI, model, 'imageReady');
    macro.event(publicAPI, model, 'initialized');

    // Build VTK API
    macro.get(publicAPI, model, ['commandEncoder', 'device', 'presentationFormat', 'useBackgroundImage', 'xrSupported']);
    macro.setGet(publicAPI, model, ['initialized', 'context', 'canvas', 'device', 'renderPasses', 'notifyStartCaptureImage', 'cursor', 'useOffScreen']);
    macro.setGetArray(publicAPI, model, ['size'], 2);
    macro.event(publicAPI, model, 'windowResizeEvent');

    // Object methods
    vtkWebGPURenderWindow(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$2 = macro.newInstance(extend$2, 'vtkWebGPURenderWindow');

  // ----------------------------------------------------------------------------
  // Register API specific RenderWindow implementation
  // ----------------------------------------------------------------------------

  registerViewConstructor('WebGPU', newInstance$2);

  // Process arguments from URL
  const userParams = vtkURLExtract.extractURLParameters();
  const STYLE_CONTAINER = {
    margin: '0',
    padding: '0',
    position: 'absolute',
    top: '0',
    left: '0',
    width: '100%',
    height: '100%',
    overflow: 'hidden'
  };
  const STYLE_CONTROL_PANEL = {
    position: 'absolute',
    left: '25px',
    top: '25px',
    backgroundColor: 'white',
    borderRadius: '5px',
    listStyle: 'none',
    padding: '5px 10px',
    margin: '0',
    display: 'block',
    border: 'solid 1px black',
    maxWidth: 'calc(100% - 70px)',
    maxHeight: 'calc(100% - 60px)',
    overflow: 'auto'
  };
  function applyStyle(el, style) {
    Object.keys(style).forEach(key => {
      el.style[key] = style[key];
    });
  }
  function vtkFullScreenRenderWindow(publicAPI, model) {
    model.classHierarchy.push('vtkFullScreenRenderWindow');
    const body = document.querySelector('body');

    // Full screen DOM handler
    if (!model.rootContainer) {
      model.rootContainer = body;
    }
    if (!model.container) {
      model.container = document.createElement('div');
      applyStyle(model.container, model.containerStyle || STYLE_CONTAINER);
      model.rootContainer.appendChild(model.container);
    }

    // apply 100% to html and body for fullscreen
    if (model.rootContainer === body) {
      document.documentElement.style.height = '100%';
      body.style.height = '100%';
      body.style.padding = '0';
      body.style.margin = '0';
    }

    // VTK renderWindow/renderer
    model.renderWindow = vtkRenderWindow$1.newInstance();
    model.renderer = vtkRenderer$1.newInstance();
    model.renderWindow.addRenderer(model.renderer);

    // apiSpecificRenderWindow
    model.apiSpecificRenderWindow = model.renderWindow.newAPISpecificView(userParams.viewAPI ?? model.defaultViewAPI);
    model.apiSpecificRenderWindow.setContainer(model.container);
    model.renderWindow.addView(model.apiSpecificRenderWindow);

    // Interactor
    model.interactor = vtkRenderWindowInteractor$1.newInstance();
    model.interactor.setInteractorStyle(vtkInteractorStyleTrackballCamera$1.newInstance());
    model.interactor.setView(model.apiSpecificRenderWindow);
    model.interactor.initialize();
    model.interactor.bindEvents(model.container);

    // Expose background
    publicAPI.setBackground = model.renderer.setBackground;
    publicAPI.removeController = () => {
      const el = model.controlContainer;
      if (el) {
        el.parentNode.removeChild(el);
      }
    };
    publicAPI.setControllerVisibility = visible => {
      model.controllerVisibility = visible;
      if (model.controlContainer) {
        if (visible) {
          model.controlContainer.style.display = 'block';
        } else {
          model.controlContainer.style.display = 'none';
        }
      }
    };
    publicAPI.toggleControllerVisibility = () => {
      publicAPI.setControllerVisibility(!model.controllerVisibility);
    };
    publicAPI.addController = html => {
      model.controlContainer = document.createElement('div');
      applyStyle(model.controlContainer, model.controlPanelStyle || STYLE_CONTROL_PANEL);
      model.rootContainer.appendChild(model.controlContainer);
      model.controlContainer.innerHTML = html;
      publicAPI.setControllerVisibility(model.controllerVisibility);
      model.rootContainer.addEventListener('keypress', e => {
        if (String.fromCharCode(e.charCode) === 'c') {
          publicAPI.toggleControllerVisibility();
        }
      });
    };

    // Update BG color
    publicAPI.setBackground(...model.background);

    // Representation API
    publicAPI.addRepresentation = representation => {
      representation.getActors().forEach(actor => {
        model.renderer.addActor(actor);
      });
    };
    publicAPI.removeRepresentation = representation => {
      representation.getActors().forEach(actor => model.renderer.removeActor(actor));
    };

    // Properly release GL context
    publicAPI.delete = macro.chain(publicAPI.setContainer, model.apiSpecificRenderWindow.delete, publicAPI.delete);

    // Handle window resize
    publicAPI.resize = () => {
      const dims = model.container.getBoundingClientRect();
      const devicePixelRatio = window.devicePixelRatio || 1;
      model.apiSpecificRenderWindow.setSize(Math.floor(dims.width * devicePixelRatio), Math.floor(dims.height * devicePixelRatio));
      if (model.resizeCallback) {
        model.resizeCallback(dims);
      }
      model.renderWindow.render();
    };
    publicAPI.setResizeCallback = cb => {
      model.resizeCallback = cb;
      publicAPI.resize();
    };
    if (model.listenWindowResize) {
      window.addEventListener('resize', publicAPI.resize);
    }
    publicAPI.resize();
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES$1 = {
    background: [0.32, 0.34, 0.43],
    containerStyle: null,
    controlPanelStyle: null,
    // defaultViewAPI: undefined,
    listenWindowResize: true,
    resizeCallback: null,
    controllerVisibility: true
  };

  // ----------------------------------------------------------------------------

  function extend$1(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES$1, initialValues);

    // Object methods
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ['renderWindow', 'renderer', 'apiSpecificRenderWindow', 'interactor', 'rootContainer', 'container', 'controlContainer']);

    // Object specific methods
    vtkFullScreenRenderWindow(publicAPI, model);
  }

  // ----------------------------------------------------------------------------

  const newInstance$1 = macro.newInstance(extend$1);

  // ----------------------------------------------------------------------------

  var vtkFullScreenRenderWindow$1 = {
    newInstance: newInstance$1,
    extend: extend$1
  };

  /**
   * Converts a binary buffer in an ArrayBuffer to a string.
   *
   * Note this does not take encoding into consideration, so don't
   * expect proper Unicode or any other encoding.
   */
  function arrayBufferToString(arrayBuffer) {
    const decoder = new TextDecoder('latin1');
    return decoder.decode(arrayBuffer);
  }

  /**
   * Extracts binary data out of a file ArrayBuffer given a prefix/suffix.
   */
  function extractBinary(arrayBuffer, prefixRegex) {
    let suffixRegex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    const str = arrayBufferToString(arrayBuffer);
    const prefixMatch = prefixRegex.exec(str);
    if (!prefixMatch) {
      return {
        text: str
      };
    }
    const dataStartIndex = prefixMatch.index + prefixMatch[0].length;
    const strFirstHalf = str.substring(0, dataStartIndex);
    let retVal = null;
    const suffixMatch = suffixRegex ? suffixRegex.exec(str) : null;
    if (suffixMatch) {
      const strSecondHalf = str.substr(suffixMatch.index);
      retVal = {
        text: strFirstHalf + strSecondHalf,
        binaryBuffer: arrayBuffer.slice(dataStartIndex, suffixMatch.index)
      };
    } else {
      // no suffix, so just take all the data starting from dataStartIndex
      retVal = {
        text: strFirstHalf,
        binaryBuffer: arrayBuffer.slice(dataStartIndex)
      };
    }
    return retVal;
  }
  var BinaryHelper = {
    arrayBufferToString,
    extractBinary
  };

  const TYPE_MAPPING = {};
  function has(type) {
    return !!TYPE_MAPPING[type];
  }
  function get() {
    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http';
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return TYPE_MAPPING[type](options);
  }
  function registerType(type, fn) {
    TYPE_MAPPING[type] = fn;
  }
  var DataAccessHelper = {
    get,
    has,
    registerType
  };

  const NoOp = v => v;
  const EPSILON = 1e-6;
  class Transform {
    constructor() {
      let useDegree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.matrix = identity$3(new Float64Array(16));
      this.tmp = new Float64Array(3);
      this.angleConv = useDegree ? toRadian : NoOp;
    }
    rotateFromDirections(originDirection, targetDirection) {
      const src = new Float64Array(3);
      const dst = new Float64Array(3);
      const transf = new Float64Array(16);
      set$1(src, originDirection[0], originDirection[1], originDirection[2]);
      set$1(dst, targetDirection[0], targetDirection[1], targetDirection[2]);
      normalize$4(src, src);
      normalize$4(dst, dst);
      const cosAlpha = dot$1(src, dst);
      if (cosAlpha >= 1) {
        return this;
      }
      cross$1(this.tmp, src, dst);
      if (length(this.tmp) < EPSILON) {
        // cross product is 0, so pick arbitrary axis perpendicular
        // to originDirection.
        cross$1(this.tmp, [1, 0, 0], originDirection);
        if (length(this.tmp) < EPSILON) {
          cross$1(this.tmp, [0, 1, 0], originDirection);
        }
      }
      fromRotation(transf, Math.acos(cosAlpha), this.tmp);
      multiply$1(this.matrix, this.matrix, transf);
      return this;
    }
    rotate(angle, axis) {
      set$1(this.tmp, ...axis);
      normalize$4(this.tmp, this.tmp);
      rotate(this.matrix, this.matrix, this.angleConv(angle), this.tmp);
      return this;
    }
    rotateX(angle) {
      rotateX(this.matrix, this.matrix, this.angleConv(angle));
      return this;
    }
    rotateY(angle) {
      rotateY(this.matrix, this.matrix, this.angleConv(angle));
      return this;
    }
    rotateZ(angle) {
      rotateZ(this.matrix, this.matrix, this.angleConv(angle));
      return this;
    }
    translate(x, y, z) {
      set$1(this.tmp, x, y, z);
      translate(this.matrix, this.matrix, this.tmp);
      return this;
    }
    scale(sx, sy, sz) {
      set$1(this.tmp, sx, sy, sz);
      scale$2(this.matrix, this.matrix, this.tmp);
      return this;
    }
    multiply(mat4x4) {
      multiply$1(this.matrix, this.matrix, mat4x4);
      return this;
    }
    multiply3x3(mat3x3) {
      multiply$1(this.matrix, this.matrix, [mat3x3[0], mat3x3[1], mat3x3[2], 0, mat3x3[3], mat3x3[4], mat3x3[5], 0, mat3x3[6], mat3x3[7], mat3x3[8], 0, 0, 0, 0, 1]);
      return this;
    }
    invert() {
      invert(this.matrix, this.matrix);
      return this;
    }
    identity() {
      identity$3(this.matrix);
      return this;
    }

    //-----------

    apply(typedArray) {
      let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      let nbIterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      if (areMatricesEqual(IDENTITY, this.matrix)) {
        // Make sure we can chain apply...
        return this;
      }
      const size = nbIterations === -1 ? typedArray.length : offset + nbIterations * 3;
      for (let i = offset; i < size; i += 3) {
        set$1(this.tmp, typedArray[i], typedArray[i + 1], typedArray[i + 2]);
        transformMat4$1(this.tmp, this.tmp, this.matrix);
        typedArray[i] = this.tmp[0];
        typedArray[i + 1] = this.tmp[1];
        typedArray[i + 2] = this.tmp[2];
      }

      // Make sure we can chain apply...
      return this;
    }
    getMatrix() {
      return this.matrix;
    }
    setMatrix(mat4x4) {
      if (!!mat4x4 && mat4x4.length === 16) {
        copy$1(this.matrix, mat4x4);
      }
      return this;
    }
  }
  function buildFromDegree() {
    return new Transform(true);
  }
  function buildFromRadian() {
    return new Transform(false);
  }
  var vtkMatrixBuilder = {
    buildFromDegree,
    buildFromRadian
  };

  function getEndianness() {
    const a = new ArrayBuffer(4);
    const b = new Uint8Array(a);
    const c = new Uint32Array(a);
    b[0] = 0xa1;
    b[1] = 0xb2;
    b[2] = 0xc3;
    b[3] = 0xd4;
    if (c[0] === 0xd4c3b2a1) return 'LittleEndian';
    if (c[0] === 0xa1b2c3d4) return 'BigEndian';
    return null;
  }
  const ENDIANNESS = getEndianness();
  function swapBytes(buffer, wordSize) {
    if (wordSize < 2) {
      return;
    }
    const bytes = new Int8Array(buffer);
    const size = bytes.length;
    const tempBuffer = [];
    for (let i = 0; i < size; i += wordSize) {
      for (let j = 0; j < wordSize; j++) {
        tempBuffer.push(bytes[i + j]);
      }
      for (let j = 0; j < wordSize; j++) {
        bytes[i + j] = tempBuffer.pop();
      }
    }
  }
  var Endian = {
    ENDIANNESS,
    getEndianness,
    swapBytes
  };

  const {
    vtkErrorMacro: vtkErrorMacro$2,
    vtkDebugMacro
  } = macro;
  const REJECT_COMPRESSION = () => {
    vtkErrorMacro$2('LiteHttpDataAccessHelper does not support compression. Need to register HttpDataAccessHelper instead.');
    return Promise.reject(new Error('LiteHttpDataAccessHelper does not support compression. Need to register HttpDataAccessHelper instead.'));
  };

  /* eslint-disable prefer-promise-reject-errors */
  let requestCount = 0;
  function openAsyncXHR(method, url) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const xhr = new XMLHttpRequest();
    xhr.open(method, url, true);
    if (options.headers) {
      Object.entries(options.headers).forEach(_ref => {
        let [key, value] = _ref;
        return xhr.setRequestHeader(key, value);
      });
    }
    if (options.progressCallback) {
      xhr.addEventListener('progress', options.progressCallback);
    }
    return xhr;
  }
  function fetchBinary(url) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new Promise((resolve, reject) => {
      const xhr = openAsyncXHR('GET', url, options);
      xhr.onreadystatechange = e => {
        if (xhr.readyState === 4) {
          if (xhr.status === 200 || xhr.status === 0) {
            resolve(xhr.response);
          } else {
            reject({
              xhr,
              e
            });
          }
        }
      };

      // Make request
      xhr.responseType = 'arraybuffer';
      xhr.send();
    });
  }
  function fetchArray(instance, baseURL, array) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    if (options && options.compression) {
      return REJECT_COMPRESSION();
    }
    if (array.ref && !array.ref.pending) {
      return new Promise((resolve, reject) => {
        const url = [baseURL, array.ref.basepath, array.ref.id].join('/');
        const xhr = openAsyncXHR('GET', url, options);
        xhr.onreadystatechange = e => {
          if (xhr.readyState === 1) {
            array.ref.pending = true;
            if (++requestCount === 1 && instance?.invokeBusy) {
              instance.invokeBusy(true);
            }
          }
          if (xhr.readyState === 4) {
            array.ref.pending = false;
            if (xhr.status === 200 || xhr.status === 0) {
              array.buffer = xhr.response;
              if (array.ref.encode === 'JSON') {
                array.values = JSON.parse(array.buffer);
              } else {
                if (Endian.ENDIANNESS !== array.ref.encode && Endian.ENDIANNESS) {
                  // Need to swap bytes
                  vtkDebugMacro(`Swap bytes of ${array.name}`);
                  Endian.swapBytes(array.buffer, DataTypeByteSize[array.dataType]);
                }
                array.values = macro.newTypedArray(array.dataType, array.buffer);
              }
              if (array.values.length !== array.size) {
                vtkErrorMacro$2(`Error in FetchArray: ${array.name}, does not have the proper array size. Got ${array.values.length}, instead of ${array.size}`);
              }

              // Done with the ref and work
              delete array.ref;
              if (--requestCount === 0 && instance?.invokeBusy) {
                instance.invokeBusy(false);
              }
              if (instance?.modified) {
                instance.modified();
              }
              resolve(array);
            } else {
              reject({
                xhr,
                e
              });
            }
          }
        };

        // Make request
        xhr.responseType = array.dataType !== 'string' ? 'arraybuffer' : 'text';
        xhr.send();
      });
    }
    return Promise.resolve(array);
  }

  // ----------------------------------------------------------------------------

  function fetchJSON(instance, url) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (options && options.compression) {
      return REJECT_COMPRESSION();
    }
    return new Promise((resolve, reject) => {
      const xhr = openAsyncXHR('GET', url, options);
      xhr.onreadystatechange = e => {
        if (xhr.readyState === 1) {
          if (++requestCount === 1 && instance?.invokeBusy) {
            instance.invokeBusy(true);
          }
        }
        if (xhr.readyState === 4) {
          if (--requestCount === 0 && instance?.invokeBusy) {
            instance.invokeBusy(false);
          }
          if (xhr.status === 200 || xhr.status === 0) {
            resolve(JSON.parse(xhr.responseText));
          } else {
            reject({
              xhr,
              e
            });
          }
        }
      };

      // Make request
      xhr.responseType = 'text';
      xhr.send();
    });
  }

  // ----------------------------------------------------------------------------

  function fetchText(instance, url) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (options && options.compression) {
      return REJECT_COMPRESSION();
    }
    return new Promise((resolve, reject) => {
      const xhr = openAsyncXHR('GET', url, options);
      xhr.onreadystatechange = e => {
        if (xhr.readyState === 1) {
          if (++requestCount === 1 && instance?.invokeBusy) {
            instance.invokeBusy(true);
          }
        }
        if (xhr.readyState === 4) {
          if (--requestCount === 0 && instance?.invokeBusy) {
            instance.invokeBusy(false);
          }
          if (xhr.status === 200 || xhr.status === 0) {
            resolve(xhr.responseText);
          } else {
            reject({
              xhr,
              e
            });
          }
        }
      };

      // Make request
      xhr.responseType = 'text';
      xhr.send();
    });
  }

  // ----------------------------------------------------------------------------

  function fetchImage(instance, url) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return new Promise((resolve, reject) => {
      const img = new Image();
      if (options.crossOrigin) {
        img.crossOrigin = options.crossOrigin;
      }
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = url;
    });
  }
  /* eslint-enable prefer-promise-reject-errors */

  // ----------------------------------------------------------------------------

  const LiteHttpDataAccessHelper = {
    fetchArray,
    fetchJSON,
    fetchText,
    fetchBinary,
    // Only for HTTP
    fetchImage
  };

  // The lite version should never override a full feature one...
  if (!has('http')) {
    registerType('http', options => LiteHttpDataAccessHelper);
  }

  // import 'vtk.js/Sources/IO/Core/DataAccessHelper/HttpDataAccessHelper'; // HTTP + zip
  // import 'vtk.js/Sources/IO/Core/DataAccessHelper/HtmlDataAccessHelper'; // html + base64 + zip
  // import 'vtk.js/Sources/IO/Core/DataAccessHelper/JSZipDataAccessHelper'; // zip

  const {
    vtkErrorMacro: vtkErrorMacro$1
  } = macro;
  function parseHeader(headerString) {
    const headerSubStr = headerString.split(' ');
    const fieldValues = headerSubStr.filter(e => e.indexOf('=') > -1);
    const header = {};
    for (let i = 0; i < fieldValues.length; ++i) {
      const fieldValueStr = fieldValues[i];
      const fieldValueSubStr = fieldValueStr.split('=');
      if (fieldValueSubStr.length === 2) {
        header[fieldValueSubStr[0]] = fieldValueSubStr[1];
      }
    }
    return header;
  }
  function addValuesToArray(src, dst) {
    for (let i = 0; i < src.length; i++) {
      dst.push(src[i]);
    }
  }

  // facet normal ni nj nk
  //     outer loop
  //         vertex v1x v1y v1z
  //         vertex v2x v2y v2z
  //         vertex v3x v3y v3z
  //     endloop
  // endfacet
  function readTriangle(lines, offset, points, cellArray, cellNormals) {
    const normalLine = lines[offset];
    if (normalLine === undefined) {
      return -1;
    }
    if (normalLine.indexOf('endfacet') !== -1) {
      return offset + 1;
    }
    if (normalLine.indexOf('facet') === -1) {
      return offset + 1; // Move to next line
    }

    let nbVertex = 0;
    let nbConsumedLines = 2;
    const firstVertexIndex = points.length / 3;
    const normal = normalLine.split(/[ \t]+/).filter(i => i).slice(-3).map(Number);
    addValuesToArray(normal, cellNormals);
    while (lines[offset + nbConsumedLines].indexOf('vertex') !== -1) {
      const line = lines[offset + nbConsumedLines];
      const coords = line.split(/[ \t]+/).filter(i => i).slice(-3).map(Number);
      addValuesToArray(coords, points);
      nbVertex++;
      nbConsumedLines++;
    }
    cellArray.push(nbVertex);
    for (let i = 0; i < nbVertex; i++) {
      cellArray.push(firstVertexIndex + i);
    }
    while (lines[offset + nbConsumedLines] && lines[offset + nbConsumedLines].indexOf('endfacet') !== -1) {
      nbConsumedLines++;
    }
    // +1 (endfacet) +1 (next facet)
    return offset + nbConsumedLines + 2;
  }

  // ----------------------------------------------------------------------------
  // vtkSTLReader methods
  // ----------------------------------------------------------------------------

  function vtkSTLReader(publicAPI, model) {
    // Set our className
    model.classHierarchy.push('vtkSTLReader');

    // Create default dataAccessHelper if not available
    if (!model.dataAccessHelper) {
      model.dataAccessHelper = DataAccessHelper.get('http');
    }

    // Internal method to fetch Array
    function fetchData(url) {
      let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const compression = option.compression !== undefined ? option.compression : model.compression;
      const progressCallback = option.progressCallback !== undefined ? option.progressCallback : model.progressCallback;
      if (option.binary) {
        return model.dataAccessHelper.fetchBinary(url, {
          compression,
          progressCallback
        });
      }
      return model.dataAccessHelper.fetchText(publicAPI, url, {
        compression,
        progressCallback
      });
    }

    // Set DataSet url
    publicAPI.setUrl = function (url) {
      let option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        binary: true
      };
      model.url = url;

      // Remove the file in the URL
      const path = url.split('/');
      path.pop();
      model.baseURL = path.join('/');

      // Fetch metadata
      return publicAPI.loadData(option);
    };

    // Fetch the actual data arrays
    publicAPI.loadData = function () {
      let option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const promise = fetchData(model.url, option);
      promise.then(publicAPI.parse);
      return promise;
    };
    publicAPI.parse = content => {
      if (typeof content === 'string') {
        publicAPI.parseAsText(content);
      } else {
        publicAPI.parseAsArrayBuffer(content);
      }
    };
    publicAPI.parseAsArrayBuffer = content => {
      if (!content) {
        return;
      }
      if (content !== model.parseData) {
        publicAPI.modified();
      } else {
        return;
      }
      model.parseData = content;

      // ascii/binary detection
      let isBinary = false;
      // 80=STL header, 4=uint32 of num of triangles (le)
      const dview = new DataView(content, 0, 80 + 4);
      const numTriangles = dview.getUint32(80, true);
      // 50 bytes per triangle
      isBinary = 84 + numTriangles * 50 === content.byteLength;

      // Check if ascii format
      if (!isBinary) {
        publicAPI.parseAsText(BinaryHelper.arrayBufferToString(content));
        return;
      }

      // Binary parsing
      // Header
      const headerData = content.slice(0, 80);
      const headerStr = BinaryHelper.arrayBufferToString(headerData);
      const header = parseHeader(headerStr);

      // Data
      const dataView = new DataView(content, 84);
      // global.dataview = dataView;
      const nbFaces = (content.byteLength - 84) / 50;
      const pointValues = new Float32Array(nbFaces * 9);
      const normalValues = new Float32Array(nbFaces * 3);
      const cellValues = new Uint32Array(nbFaces * 4);
      const cellDataValues = new Uint16Array(nbFaces);
      let cellOffset = 0;
      for (let faceIdx = 0; faceIdx < nbFaces; faceIdx++) {
        const offset = faceIdx * 50;
        normalValues[faceIdx * 3 + 0] = dataView.getFloat32(offset + 0, true);
        normalValues[faceIdx * 3 + 1] = dataView.getFloat32(offset + 4, true);
        normalValues[faceIdx * 3 + 2] = dataView.getFloat32(offset + 8, true);
        pointValues[faceIdx * 9 + 0] = dataView.getFloat32(offset + 12, true);
        pointValues[faceIdx * 9 + 1] = dataView.getFloat32(offset + 16, true);
        pointValues[faceIdx * 9 + 2] = dataView.getFloat32(offset + 20, true);
        pointValues[faceIdx * 9 + 3] = dataView.getFloat32(offset + 24, true);
        pointValues[faceIdx * 9 + 4] = dataView.getFloat32(offset + 28, true);
        pointValues[faceIdx * 9 + 5] = dataView.getFloat32(offset + 32, true);
        pointValues[faceIdx * 9 + 6] = dataView.getFloat32(offset + 36, true);
        pointValues[faceIdx * 9 + 7] = dataView.getFloat32(offset + 40, true);
        pointValues[faceIdx * 9 + 8] = dataView.getFloat32(offset + 44, true);
        cellValues[cellOffset++] = 3;
        cellValues[cellOffset++] = faceIdx * 3 + 0;
        cellValues[cellOffset++] = faceIdx * 3 + 1;
        cellValues[cellOffset++] = faceIdx * 3 + 2;
        cellDataValues[faceIdx] = dataView.getUint16(offset + 48, true);
      }

      // Rotate points
      const orientationField = 'SPACE';
      if (orientationField in header && header[orientationField] !== 'LPS') {
        const XYZ = header[orientationField];
        const mat4 = new Float32Array(16);
        mat4[15] = 1;
        switch (XYZ[0]) {
          case 'L':
            mat4[0] = 1;
            break;
          case 'R':
            mat4[0] = -1;
            break;
          default:
            vtkErrorMacro$1(`Can not convert STL file from ${XYZ} to LPS space: ` + `permutations not supported. Use itk.js STL reader instead.`);
            return;
        }
        switch (XYZ[1]) {
          case 'P':
            mat4[5] = 1;
            break;
          case 'A':
            mat4[5] = -1;
            break;
          default:
            vtkErrorMacro$1(`Can not convert STL file from ${XYZ} to LPS space: ` + `permutations not supported. Use itk.js STL reader instead.`);
            return;
        }
        switch (XYZ[2]) {
          case 'S':
            mat4[10] = 1;
            break;
          case 'I':
            mat4[10] = -1;
            break;
          default:
            vtkErrorMacro$1(`Can not convert STL file from ${XYZ} to LPS space: ` + `permutations not supported. Use itk.js STL reader instead.`);
            return;
        }
        vtkMatrixBuilder.buildFromDegree().setMatrix(mat4).apply(pointValues).apply(normalValues);
      }
      const polydata = vtkPolyData$1.newInstance();
      polydata.getPoints().setData(pointValues, 3);
      polydata.getPolys().setData(cellValues);
      polydata.getCellData().setScalars(vtkDataArray$1.newInstance({
        name: 'Attribute',
        values: cellDataValues
      }));
      polydata.getCellData().setNormals(vtkDataArray$1.newInstance({
        name: 'Normals',
        values: normalValues,
        numberOfComponents: 3
      }));

      // Add new output
      model.output[0] = polydata;
    };
    publicAPI.parseAsText = content => {
      if (!content) {
        return;
      }
      if (content !== model.parseData) {
        publicAPI.modified();
      } else {
        return;
      }
      model.parseData = content;
      const lines = content.split('\n');
      let offset = 1;
      const points = [];
      const cellArray = [];
      const cellNormals = [];
      while (offset !== -1) {
        offset = readTriangle(lines, offset, points, cellArray, cellNormals);
      }
      const polydata = vtkPolyData$1.newInstance();
      polydata.getPoints().setData(Float32Array.from(points), 3);
      polydata.getPolys().setData(Uint32Array.from(cellArray));
      polydata.getCellData().setNormals(vtkDataArray$1.newInstance({
        name: 'Normals',
        values: Float32Array.from(cellNormals),
        numberOfComponents: 3
      }));

      // Add new output
      model.output[0] = polydata;
    };
    publicAPI.requestData = (inData, outData) => {
      publicAPI.parse(model.parseData);
    };
  }

  // ----------------------------------------------------------------------------
  // Object factory
  // ----------------------------------------------------------------------------

  const DEFAULT_VALUES = {
    // baseURL: null,
    // dataAccessHelper: null,
    // url: null,
  };

  // ----------------------------------------------------------------------------

  function extend(publicAPI, model) {
    let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    Object.assign(model, DEFAULT_VALUES, initialValues);

    // Build VTK API
    macro.obj(publicAPI, model);
    macro.get(publicAPI, model, ['url', 'baseURL']);
    macro.setGet(publicAPI, model, ['dataAccessHelper']);
    macro.algo(publicAPI, model, 0, 1);

    // vtkSTLReader methods
    vtkSTLReader(publicAPI, model);

    // To support destructuring
    if (!model.compression) {
      model.compression = null;
    }
    if (!model.progressCallback) {
      model.progressCallback = null;
    }
  }

  // ----------------------------------------------------------------------------

  const newInstance = macro.newInstance(extend, 'vtkSTLReader');

  // ----------------------------------------------------------------------------

  var vtkSTLReader$1 = {
    extend,
    newInstance
  };

  document.addEventListener("DOMContentLoaded", () => {

      const fullScreenRenderer = vtkFullScreenRenderWindow$1.newInstance();
      const renderer = fullScreenRenderer.getRenderer();
      const renderWindow = fullScreenRenderer.getRenderWindow();

      const reader = vtkSTLReader$1.newInstance();
      const mapper = vtkMapper$1.newInstance({ scalarVisibility: false });
      let actor = vtkActor$1.newInstance();

      actor.setMapper(mapper);
      mapper.setInputConnection(reader.getOutputPort());

      let renderBtn = document.getElementById("render-button");
      renderBtn.addEventListener("click", handleRender);

      function handleRender(){

          let fileInput = document.getElementById('file-input');
          let file = fileInput.files[0];
          if(!checkFile(file)) return;
          parseFile(file);
      }

      function parseFile(file){

          const fileReader = new FileReader();
          fileReader.readAsArrayBuffer(file);
          fileReader.onload = () => {
              reader.parseAsArrayBuffer(fileReader.result);
              update();
          };
      }

      function checkFile(file){
          if(!file){
              alert("Please pick a file to load!");
              return false; 
          }
          if(file.size < 84){
              alert("File is too small!");
              return false;
          }
          let ext = getExtension(file.name);
          if(ext.toLowerCase() != 'stl'){
              alert("Only stl files are supported!");
              return false;
          }
          return true;
      }

      function getExtension(filename) {

          var parts = filename.split('.');
          return parts[parts.length - 1];
      }

      function update() {

          actor.getProperty().setColor(1.0, 1.0, 1.0);
          renderer.addActor(actor);
          renderer.resetCamera();
          renderWindow.render();
      }
  });

})();
